--- START OF FILE .gitattributes ---
# Auto detect text files and perform LF normalization
* text=auto

--- END OF FILE .gitattributes ---

--- START OF FILE analysis_options.yaml ---
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule
    # prefer_const_constructors: true # Example of enabling a rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options

--- END OF FILE analysis_options.yaml ---

--- START OF FILE pubspec.lock ---
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  _fe_analyzer_shared:
    dependency: transitive
    description:
      name: _fe_analyzer_shared
      sha256: e55636ed79578b9abca5fecf9437947798f5ef7456308b5cb85720b793eac92f
      url: "https://pub.dev"
    source: hosted
    version: "82.0.0"
  _flutterfire_internals:
    dependency: transitive
    description:
      name: _flutterfire_internals
      sha256: "214e6f07e2a44f45972e0365c7b537eaeaddb4598db0778dd4ac64b4acd3f5b1"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.55"
  analyzer:
    dependency: transitive
    description:
      name: analyzer
      sha256: "904ae5bb474d32c38fb9482e2d925d5454cda04ddd0e55d2e6826bc72f6ba8c0"
      url: "https://pub.dev"
    source: hosted
    version: "7.4.5"
  args:
    dependency: transitive
    description:
      name: args
      sha256: d0481093c50b1da8910eb0bb301626d4d8eb7284aa739614d2b394ee09e3ea04
      url: "https://pub.dev"
    source: hosted
    version: "2.7.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "758e6d74e971c3e5aceb4110bfd6698efc7f501675bcfe0c775459a8140750eb"
      url: "https://pub.dev"
    source: hosted
    version: "2.13.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "8aab1771e1243a5063b8b0ff68042d67334e3feab9e95b9490f9a6ebf73b42ea"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  build:
    dependency: transitive
    description:
      name: build
      sha256: cef23f1eda9b57566c81e2133d196f8e3df48f244b317368d65c5943d91148f0
      url: "https://pub.dev"
    source: hosted
    version: "2.4.2"
  built_collection:
    dependency: transitive
    description:
      name: built_collection
      sha256: "376e3dd27b51ea877c28d525560790aee2e6fbb5f20e2f85d5081027d94e2100"
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  built_value:
    dependency: transitive
    description:
      name: built_value
      sha256: ea90e81dc4a25a043d9bee692d20ed6d1c4a1662a28c03a96417446c093ed6b4
      url: "https://pub.dev"
    source: hosted
    version: "8.9.5"
  change_app_package_name:
    dependency: "direct dev"
    description:
      name: change_app_package_name
      sha256: "8e43b754fe960426904d77ed4c62fa8c9834deaf6e293ae40963fa447482c4c5"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.0"
  characters:
    dependency: transitive
    description:
      name: characters
      sha256: f71061c654a3380576a52b451dd5532377954cf9dbd272a78fc8479606670803
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  clock:
    dependency: transitive
    description:
      name: clock
      sha256: fddb70d9b5277016c77a80201021d40a2247104d9f4aa7bab7157b7e3f05b84b
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  cloud_firestore:
    dependency: "direct main"
    description:
      name: cloud_firestore
      sha256: d25c956be5261c14bc9a69c9662de8addb308376b4b53a64469aade52e7b02f8
      url: "https://pub.dev"
    source: hosted
    version: "5.6.8"
  cloud_firestore_platform_interface:
    dependency: transitive
    description:
      name: cloud_firestore_platform_interface
      sha256: ee2b8f8c602ede36073afd3741e99cfea9dd982b4a44833daf665134d151c32a
      url: "https://pub.dev"
    source: hosted
    version: "6.6.8"
  cloud_firestore_web:
    dependency: transitive
    description:
      name: cloud_firestore_web
      sha256: b99bc4f1f70787f694b73bc6fce238d4d6cc822c9b31ba8ef1578b180b6f77bc
      url: "https://pub.dev"
    source: hosted
    version: "4.4.8"
  code_builder:
    dependency: transitive
    description:
      name: code_builder
      sha256: "0ec10bf4a89e4c613960bf1e8b42c64127021740fb21640c29c909826a5eea3e"
      url: "https://pub.dev"
    source: hosted
    version: "4.10.1"
  collection:
    dependency: "direct main"
    description:
      name: collection
      sha256: "2f5709ae4d3d59dd8f7cd309b4e023046b57d8a6c82130785d2b0e5868084e76"
      url: "https://pub.dev"
    source: hosted
    version: "1.19.1"
  convert:
    dependency: transitive
    description:
      name: convert
      sha256: b30acd5944035672bc15c6b7a8b47d773e41e2f17de064350988c5d02adb1c68
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: "1e445881f28f22d6140f181e07737b22f1e099a5e1ff94b0af2f9e4a463f4855"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.6"
  cupertino_icons:
    dependency: "direct main"
    description:
      name: cupertino_icons
      sha256: ba631d1c7f7bef6b729a622b7b752645a2d076dba9976925b8f25725a30e1ee6
      url: "https://pub.dev"
    source: hosted
    version: "1.0.8"
  dart_style:
    dependency: transitive
    description:
      name: dart_style
      sha256: "27eb0ae77836989a3bc541ce55595e8ceee0992807f14511552a898ddd0d88ac"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.1"
  equatable:
    dependency: transitive
    description:
      name: equatable
      sha256: "567c64b3cb4cf82397aac55f4f0cbd3ca20d77c6c03bedbc4ceaddc08904aef7"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.7"
  fake_async:
    dependency: transitive
    description:
      name: fake_async
      sha256: "5368f224a74523e8d2e7399ea1638b37aecfca824a3cc4dfdf77bf1fa905ac44"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.3"
  file:
    dependency: transitive
    description:
      name: file
      sha256: a3b4f84adafef897088c160faf7dfffb7696046cb13ae90b508c2cbc95d3b8d4
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  firebase_auth:
    dependency: "direct main"
    description:
      name: firebase_auth
      sha256: "10cd3f00a247f33b0a5c77574011a87379432bf3fec77a500b55f2bcc30ddd8b"
      url: "https://pub.dev"
    source: hosted
    version: "5.5.4"
  firebase_auth_platform_interface:
    dependency: transitive
    description:
      name: firebase_auth_platform_interface
      sha256: "2d15872a8899b0459fab6b4c148fd142e135acfc8a303d383d80b455e4dba7bd"
      url: "https://pub.dev"
    source: hosted
    version: "7.6.3"
  firebase_auth_web:
    dependency: transitive
    description:
      name: firebase_auth_web
      sha256: efba45393050ca03d992eae1d305d5fc8c0c9f5980624053512e935c23767c4f
      url: "https://pub.dev"
    source: hosted
    version: "5.14.3"
  firebase_core:
    dependency: "direct main"
    description:
      name: firebase_core
      sha256: "8cfe3c900512399ce8d50fcc817e5758ff8615eeb6fa5c846a4cc47bbf6353b6"
      url: "https://pub.dev"
    source: hosted
    version: "3.13.1"
  firebase_core_platform_interface:
    dependency: "direct main"
    description:
      name: firebase_core_platform_interface
      sha256: d7253d255ff10f85cfd2adaba9ac17bae878fa3ba577462451163bd9f1d1f0bf
      url: "https://pub.dev"
    source: hosted
    version: "5.4.0"
  firebase_core_web:
    dependency: transitive
    description:
      name: firebase_core_web
      sha256: ddd72baa6f727e5b23f32d9af23d7d453d67946f380bd9c21daf474ee0f7326e
      url: "https://pub.dev"
    source: hosted
    version: "2.23.0"
  fixnum:
    dependency: transitive
    description:
      name: fixnum
      sha256: b6dc7065e46c974bc7c5f143080a6764ec7a4be6da1285ececdc37be96de53be
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  fl_chart:
    dependency: "direct main"
    description:
      name: fl_chart
      sha256: "577aeac8ca414c25333334d7c4bb246775234c0e44b38b10a82b559dd4d764e7"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_app_name:
    dependency: "direct dev"
    description:
      name: flutter_app_name
      sha256: a93a558ca7b5d344b0be65c03018a2cde728c1f151fec5376538ad0afe80c020
      url: "https://pub.dev"
    source: hosted
    version: "0.1.1"
  flutter_colorpicker:
    dependency: "direct main"
    description:
      name: flutter_colorpicker
      sha256: "969de5f6f9e2a570ac660fb7b501551451ea2a1ab9e2097e89475f60e07816ea"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      sha256: "5398f14efa795ffb7a33e9b6a08798b26a180edac4ad7db3f231e40f82ce11e1"
      url: "https://pub.dev"
    source: hosted
    version: "5.0.0"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_web_plugins:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  glob:
    dependency: transitive
    description:
      name: glob
      sha256: c3f1ee72c96f8f78935e18aa8cecced9ab132419e8625dc187e1c2408efc20de
      url: "https://pub.dev"
    source: hosted
    version: "2.1.3"
  google_generative_ai:
    dependency: "direct main"
    description:
      name: google_generative_ai
      sha256: "71f613d0247968992ad87a0eb21650a566869757442ba55a31a81be6746e0d1f"
      url: "https://pub.dev"
    source: hosted
    version: "0.4.7"
  http:
    dependency: transitive
    description:
      name: http
      sha256: "2c11f3f94c687ee9bad77c171151672986360b2b001d109814ee7140b2cf261b"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "178d74305e7866013777bab2c3d8726205dc5a4dd935297175b19a23a2e66571"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.2"
  intl:
    dependency: "direct main"
    description:
      name: intl
      sha256: "3df61194eb431efc39c4ceba583b95633a403f46c9fd341e550ce0bfa50e9aa5"
      url: "https://pub.dev"
    source: hosted
    version: "0.20.2"
  leak_tracker:
    dependency: transitive
    description:
      name: leak_tracker
      sha256: "6bb818ecbdffe216e81182c2f0714a2e62b593f4a4f13098713ff1685dfb6ab0"
      url: "https://pub.dev"
    source: hosted
    version: "10.0.9"
  leak_tracker_flutter_testing:
    dependency: transitive
    description:
      name: leak_tracker_flutter_testing
      sha256: f8b613e7e6a13ec79cfdc0e97638fddb3ab848452eff057653abd3edba760573
      url: "https://pub.dev"
    source: hosted
    version: "3.0.9"
  leak_tracker_testing:
    dependency: transitive
    description:
      name: leak_tracker_testing
      sha256: "6ba465d5d76e67ddf503e1161d1f4a6bc42306f9d66ca1e8f079a47290fb06d3"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.1"
  lints:
    dependency: transitive
    description:
      name: lints
      sha256: c35bb79562d980e9a453fc715854e1ed39e24e7d0297a880ef54e17f9874a9d7
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  logging:
    dependency: transitive
    description:
      name: logging
      sha256: c8245ada5f1717ed44271ed1c26b8ce85ca3228fd2ffdb75468ab01979309d61
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: dc58c723c3c24bf8d3e2d3ad3f2f9d7bd9cf43ec6feaa64181775e60190153f2
      url: "https://pub.dev"
    source: hosted
    version: "0.12.17"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      sha256: f7142bb1154231d7ea5f96bc7bde4bda2a0945d2806bb11670e30b850d56bdec
      url: "https://pub.dev"
    source: hosted
    version: "0.11.1"
  material_design_icons_flutter:
    dependency: "direct main"
    description:
      name: material_design_icons_flutter
      sha256: "6f986b7a51f3ad4c00e33c5c84e8de1bdd140489bbcdc8b66fc1283dad4dea5a"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.7296"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: e3641ec5d63ebf0d9b41bd43201a66e3fc79a65db5f61fc181f04cd27aab950c
      url: "https://pub.dev"
    source: hosted
    version: "1.16.0"
  mockito:
    dependency: "direct dev"
    description:
      name: mockito
      sha256: "4546eac99e8967ea91bae633d2ca7698181d008e95fa4627330cf903d573277a"
      url: "https://pub.dev"
    source: hosted
    version: "5.4.6"
  nested:
    dependency: transitive
    description:
      name: nested
      sha256: "03bac4c528c64c95c722ec99280375a6f2fc708eec17c7b3f07253b626cd2a20"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  package_config:
    dependency: transitive
    description:
      name: package_config
      sha256: f096c55ebb7deb7e384101542bfba8c52696c1b56fca2eb62827989ef2353bbc
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  path:
    dependency: transitive
    description:
      name: path
      sha256: "75cca69d1490965be98c73ceaea117e8a04dd21217b37b292c9ddbec0d955bc5"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.1"
  petitparser:
    dependency: transitive
    description:
      name: petitparser
      sha256: cb3798bef7fc021ac45b308f4b51208a152792445cce0448c9a4ba5879dd8750
      url: "https://pub.dev"
    source: hosted
    version: "5.4.0"
  plugin_platform_interface:
    dependency: transitive
    description:
      name: plugin_platform_interface
      sha256: "4820fbfdb9478b1ebae27888254d445073732dae3d6ea81f0b7e06d5dedc3f02"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.8"
  provider:
    dependency: "direct main"
    description:
      name: provider
      sha256: "4abbd070a04e9ddc287673bf5a030c7ca8b685ff70218720abab8b092f53dd84"
      url: "https://pub.dev"
    source: hosted
    version: "6.1.5"
  pub_semver:
    dependency: transitive
    description:
      name: pub_semver
      sha256: "5bfcf68ca79ef689f8990d1160781b4bad40a3bd5e5218ad4076ddb7f4081585"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  source_gen:
    dependency: transitive
    description:
      name: source_gen
      sha256: "35c8150ece9e8c8d263337a265153c3329667640850b9304861faea59fc98f6b"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "254ee5351d6cb365c859e20ee823c3bb479bf4a293c22d17a9f1bf144ce86f7c"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.1"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "8b27215b45d22309b5cddda1aa2b19bdfec9df0e765f2de506401c071d38d1b1"
      url: "https://pub.dev"
    source: hosted
    version: "1.12.1"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: "969e04c80b8bcdf826f8f16579c7b14d780458bd97f56d107d3950fdbeef059d"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "921cd31725b72fe181906c6a94d987c78e3b98c2e205b397ea399d4054872b43"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: "7f554798625ea768a7518313e58f83891c7f5024f88e46e7182a4558850a4b8e"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.2"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: fb31f383e2ee25fbbfe06b40fe21e1e458d14080e3c67e7ba0acfde4df4e0bbd
      url: "https://pub.dev"
    source: hosted
    version: "0.7.4"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: f9049c039ebfeb4cf7a7104a675823cd72dba8297f264b6637062516699fa006
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      sha256: "80b3257d1492ce4d091729e3a67a60407d227c27241d6927be0130c98e741803"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: ddfa8d30d89985b96407efce8acbdd124701f96741f2d981ca860662f1c0dc02
      url: "https://pub.dev"
    source: hosted
    version: "15.0.0"
  watcher:
    dependency: transitive
    description:
      name: watcher
      sha256: "69da27e49efa56a15f8afe8f4438c4ec02eff0a117df1b22ea4aad194fe1c104"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  web:
    dependency: transitive
    description:
      name: web
      sha256: "868d88a33d8a87b18ffc05f9f030ba328ffefba92d6c127917a2ba740f9cfe4a"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  xml:
    dependency: transitive
    description:
      name: xml
      sha256: "80d494c09849dc3f899d227a78c30c5b949b985ededf884cb3f3bcd39f4b447a"
      url: "https://pub.dev"
    source: hosted
    version: "5.4.1"
  yaml:
    dependency: transitive
    description:
      name: yaml
      sha256: b9da305ac7c39faa3f030eccd175340f968459dae4af175130b3fc47e40d76ce
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
sdks:
  dart: ">=3.7.0 <4.0.0"
  flutter: ">=3.27.4"

--- END OF FILE pubspec.lock ---

--- START OF FILE ai.txt ---
Make the following changes:


Now, recreate projrct_snapshot.txt only for the files that are changed in the original format
--- END OF FILE ai.txt ---

--- START OF FILE firebase.json ---
{"flutter":{"platforms":{"android":{"default":{"projectId":"task-dominion","appId":"1:1059901273076:android:bdeb039da1e16ab1843fa1","fileOutput":"android/app/google-services.json"}},"dart":{"lib/firebase_options.dart":{"projectId":"task-dominion","configurations":{"android":"1:1059901273076:android:bdeb039da1e16ab1843fa1","web":"1:1059901273076:web:86c0ab680c91dc5f843fa1","windows":"1:1059901273076:web:86c0ab680c91dc5f843fa1"}}}}}}
--- END OF FILE firebase.json ---

--- START OF FILE .metadata ---
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "be698c48a6750c8cb8e61c740ca9991bb947aba2"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
    - platform: android
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
    - platform: ios
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
    - platform: linux
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
    - platform: macos
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
    - platform: web
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
    - platform: windows
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'

--- END OF FILE .metadata ---

--- START OF FILE .gitignore ---
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.pub-cache/
.pub/
build/
ios/Pods/
ios/DerivedData/
ios/.symlinks/
ios/Flutter/App.framework
ios/Flutter/Flutter.framework
ios/Flutter/Generated.xcconfig
ios/Flutter/flutter_export_environment.sh
# Flutter web builds
web/
app.*.symbols # Android symbols
app.*.map.json # KSM map

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release


# Rider files
.idea/
*.sln
*.suo
*.user
*.rider.*

# VS Code specific
.vscode/settings.json
.vscode/tasks.json
.vscode/launch.json
.vscode/extensions.json
*.code-workspace

# Output files
coverage/
# Ignore files specific to RubyMotion
.repl_history

# Windows builds
windows/flutter/generated_plugins.cmake
windows/flutter/generated_plugin_registrant.cc
windows/flutter/generated_plugin_registrant.h
windows/runner/Debug/
windows/runner/Profile/
windows/runner/Release/
windows/runner/flutter_window.h
windows/runner/flutter_window.cpp
windows/runner/main.cpp
windows/runner/utils.h
windows/runner/utils.cpp
windows/runner/win3.1_resource.rc
windows/plugins/

# Linux builds
linux/flutter/generated_plugins.cmake
linux/flutter/generated_plugin_registrant.cc
linux/flutter/generated_plugin_registrant.h
linux/flutter/ephemeral/
linux/flutter/ephemeral.stamp

# macOS builds
macos/Flutter/GeneratedPluginRegistrant.swift
macos/Flutter/Generated.xcconfig
macos/Flutter/ephemeral_dir_path
macos/Flutter/ephemeral.app
macos/Flutter/Flutter- আরো একবার.h

--- END OF FILE .gitignore ---

--- START OF FILE README.md ---
# myapp_flutter

A Flutter version of the Task Dominion application.

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://docs.flutter.dev/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://docs.flutter.dev/cookbook)

For help getting started with Flutter development, view the
[online documentation](https://docs.flutter.dev/), which offers tutorials,
samples, guidance on mobile development, and a full API reference.

## Firebase Setup

This project uses Firebase. To configure it:
1. Make sure you have the FlutterFire CLI installed: `flutter`
2. Run `flutterfire configure` in the project root and select your Firebase project. This will generate `lib/firebase_options.dart`.

## API Keys

AI features require API keys. Create a file `lib/src/config/api_keys.dart` with your Gemini API keys:
```dart
// lib/src/config/api_keys.dart
// IMPORTANT: Add this file to your .gitignore
const List<String> GEMINI_API_KEYS = ['YOUR_GEMINI_API_KEY_1_HERE'];
const String GEMINI_MODEL_NAME = 'gemini-1.5-flash-latest'; // Or your preferred model
```
Ensure this file is added to your `.gitignore`.

--- END OF FILE README.md ---

--- START OF FILE pubspec.yaml ---
name: myapp_flutter
description: "A Flutter version of the Task Dominion application."
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

version: 1.0.2+2 # Incremented version

environment:
  sdk: '>=3.3.0 <4.0.0'


dependencies:
  flutter:
    sdk: flutter

  # Firebase
  firebase_core: ^3.13.1
  firebase_core_platform_interface: ^5.4.0
  firebase_auth: ^5.5.4
  cloud_firestore: ^5.6.8

  # State Management
  provider: ^6.1.2

  # AI
  google_generative_ai: ^0.4.0 

  # UI & Utilities
  cupertino_icons: ^1.0.6
  intl: ^0.20.2 # For date formatting
  fl_chart: ^1.0.0 # For charts
  material_design_icons_flutter: ^7.0.7296 # For extra icons
  collection: ^1.18.0 
  flutter_colorpicker: ^1.1.0 # For task color selection


dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0
  mockito: ^5.4.4 
  change_app_package_name: ^1.1.0 
  flutter_app_name: ^0.1.1

flutter_app_name:
  name: "TaskDominion" # Changed name to be more aligned with project

flutter:
  uses-material-design: true

  assets: []
  #   - assets/images/valorant-bg-example.png # Example if adding a background image

  fonts:
    - family: RobotoCondensed
      fonts:
        - asset: assets/fonts/RobotoCondensed-Regular.ttf
        - asset: assets/fonts/RobotoCondensed-Bold.ttf
          weight: 700
    - family: OpenSans
      fonts:
        - asset: assets/fonts/OpenSans-Regular.ttf
        - asset: assets/fonts/OpenSans-SemiBold.ttf
          weight: 600
    # Note: For true Valorant fonts like "Tungsten" or "DIN Next LT Pro",
    # you would need to acquire the font files (ensure licensing) and declare them here.
    # Example:
    # - family: Tungsten
    #   fonts:
    #     - asset: assets/fonts/Tungsten-Bold.ttf # (if you had this file)
    #       weight: 700

--- END OF FILE pubspec.yaml ---

--- START OF FILE .idx/dev.nix ---
# To learn more about how to use Nix to configure your environment
# see: https://firebase.google.com/docs/studio/customize-workspace
{ pkgs, ... }: {
  # Which nixpkgs channel to use.
  channel = "stable-24.05"; # or "unstable"
  # Use https://search.nixos.org/packages to find packages
  packages = [
    pkgs.flutter # Add Flutter SDK
    pkgs.jdk17   # For Android development
    pkgs.unzip   # General utility
    # For Android SDK command line tools if not managed by Flutter/Android Studio
    # pkgs.android-tools 
  ];
  # Sets environment variables in the workspace
  env = {
     # Example: If Android SDK is installed via Nix and not auto-detected by Flutter
     # ANDROID_SDK_ROOT = "${pkgs.android-sdk}/libexec/android-sdk";
  };
  idx = {
    # Search for the extensions you want on https://open-vsx.org/ and use "publisher.id"
    extensions = [
      "Dart-Code.flutter"
      "Dart-Code.dart-code"
    ];
    workspace = {
      # Runs when a workspace is first created with this `dev.nix` file
      onCreate = {
        # Optional: Run flutter doctor to check setup
        flutter-doctor = "flutter doctor";
        flutter-setup1 = "cd ..;wget https://storage.googleapis.com/flutter_infra_release/releases/stable/linux/flutter_linux_3.32.0-stable.tar.xz && tar -xJvf ./flutter_linux_3.32.0-stable.tar.xz ";
      };
      # To run something each time the workspace is (re)started, use the `onStart` hook
    };
    # Enable previews and customize configuration
    previews = {
      enable = true;
      previews = {
        web = {
          command = ["/home/user/flutter/bin/flutter" "run" "--machine" "-d" "web-server" "--web-hostname" "0.0.0.0" "--web-port" "$PORT"];
          manager = "flutter";
        };
        # Android preview might require more setup for emulators within Project IDX
       android = {
           command = ["/home/user/flutter/bin/flutter" "run" "--machine" "-d" "android" "-d" "localhost:5555"];
           manager = "flutter";
         };
      };
    };
  };
}

--- END OF FILE .idx/dev.nix ---

--- START OF FILE lib/firebase_options.dart ---
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for ios - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyC1VzXpHEKVCNfXZAHQ1eWJQo1ruzO1-oY',
    appId: '1:1059901273076:web:86c0ab680c91dc5f843fa1',
    messagingSenderId: '1059901273076',
    projectId: 'task-dominion',
    authDomain: 'task-dominion.firebaseapp.com',
    databaseURL: 'https://task-dominion-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'task-dominion.firebasestorage.app',
    measurementId: 'G-TZTWWCQMCY',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyBeZsAoZiV38vUrdzbZP4wBGbOCBGluAZg',
    appId: '1:1059901273076:android:bdeb039da1e16ab1843fa1',
    messagingSenderId: '1059901273076',
    projectId: 'task-dominion',
    databaseURL: 'https://task-dominion-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'task-dominion.firebasestorage.app',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyC1VzXpHEKVCNfXZAHQ1eWJQo1ruzO1-oY',
    appId: '1:1059901273076:web:86c0ab680c91dc5f843fa1',
    messagingSenderId: '1059901273076',
    projectId: 'task-dominion',
    authDomain: 'task-dominion.firebaseapp.com',
    databaseURL: 'https://task-dominion-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'task-dominion.firebasestorage.app',
    measurementId: 'G-TZTWWCQMCY',
  );
}

--- END OF FILE lib/firebase_options.dart ---

--- START OF FILE lib/main.dart ---
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:myapp_flutter/src/app.dart';
import 'package:myapp_flutter/firebase_options.dart'; // Auto-generated by FlutterFire
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:provider/provider.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(
    ChangeNotifierProvider(
      create: (context) => GameProvider(),
      child: const MyApp(),
    ),
  );
}
--- END OF FILE lib/main.dart ---

--- START OF FILE lib/src/app.dart ---
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/screens/home_screen.dart';
import 'package:myapp_flutter/src/screens/login_screen.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:provider/provider.dart';

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    print("[MyApp] Building MaterialApp"); // DEBUG
    return MaterialApp(
      title: 'Task Dominion',
      theme: AppTheme.getThemeData(primaryAccent: AppTheme.fhAccentTealFixed),
      debugShowCheckedModeBanner: false,
      home: Consumer<GameProvider>(
        builder: (context, gameProvider, child) {
          print("[MyApp Consumer] AuthLoading: ${gameProvider.authLoading}, CurrentUser: ${gameProvider.currentUser?.uid}, DataLoadingAfterLogin: ${gameProvider.isDataLoadingAfterLogin}"); // DEBUG
          if (gameProvider.authLoading || (gameProvider.currentUser != null && gameProvider.isDataLoadingAfterLogin)) {
            print("[MyApp Consumer] Showing loading indicator"); // DEBUG
            return const Scaffold(
              body: Center(child: CircularProgressIndicator()),
            );
          }
          if (gameProvider.currentUser == null) {
            print("[MyApp Consumer] Showing LoginScreen"); // DEBUG
            return const LoginScreen();
          }
          print("[MyApp Consumer] Showing HomeScreen"); // DEBUG
          return const HomeScreen();
        },
      ),
    );
  }
}
--- END OF FILE lib/src/app.dart ---

--- START OF FILE lib/src/utils/helpers.dart ---
import 'package:intl/intl.dart';

String getTodayDateString() {
  return DateFormat('yyyy-MM-dd').format(DateTime.now());
}

String romanize(int num) {
  if (num.isNaN || num == 0) return "0";
  if (num > 3999 || num < 1) return num.toString(); // Simplified for typical game levels

  const List<String> rnOnes = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
  const List<String> rnTens = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"];
  const List<String> rnHundreds = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"];
  const List<String> rnThousands = ["", "M", "MM", "MMM"];

  String thousands = rnThousands[(num / 1000).floor()];
  String hundreds = rnHundreds[((num % 1000) / 100).floor()];
  String tens = rnTens[((num % 100) / 10).floor()];
  String ones = rnOnes[num % 10];

  return thousands + hundreds + tens + ones;
}

double xpForLevel(int level, double xpPerLevelBase, double xpLevelMultiplier) {
  if (level <= 1) return 0;
  double totalXp = 0;
  for (int i = 1; i < level; i++) {
    totalXp += (xpPerLevelBase * (xpLevelMultiplierPow(xpLevelMultiplier, i - 1))).floor();
  }
  return totalXp;
}

double xpToNext(int currentLevel, double xpPerLevelBase, double xpLevelMultiplier) {
  return (xpPerLevelBase * (xpLevelMultiplierPow(xpLevelMultiplier, currentLevel - 1))).floorToDouble();
}

// Custom power function to avoid dart:math for simple integer powers
// ignore_for_file: non_constant_identifier_names
double xpLevelMultiplierPow(double base, int exponent) {
  double result = 1.0;
  for (int i = 0; i < exponent; i++) {
    result *= base;
  }
  return result;
}

String formatTime(double totalSeconds) {
  int hours = (totalSeconds / 3600).floor();
  int minutes = ((totalSeconds % 3600) / 60).floor();
  int seconds = (totalSeconds % 60).floor();

  String paddedHours = hours.toString().padLeft(2, '0');
  String paddedMinutes = minutes.toString().padLeft(2, '0');
  String paddedSeconds = seconds.toString().padLeft(2, '0');

  if (hours > 0) {
    return "$paddedHours:$paddedMinutes:$paddedSeconds";
  }
  return "$paddedMinutes:$paddedSeconds";
}

--- END OF FILE lib/src/utils/helpers.dart ---

--- START OF FILE lib/src/utils/constants.dart ---
// lib/src/utils/constants.dart
import 'package:myapp_flutter/src/models/game_models.dart'; // For PlayerStat, MainTaskTemplate

// Initial Main Task Templates (Moved from game_models.dart)
List<MainTaskTemplate> initialMainTaskTemplates = [
  MainTaskTemplate(
      id: "proj_ui_ai",
      name: "Summer Project",
      description: "Develop UI, integrate AI, and gamify applications.",
      theme: "tech",
      colorHex: "FF00F8F8"), // Cyan
  MainTaskTemplate(
      id: "research_pinn",
      name: "Research on PINNs",
      description: "Deep dive into Physics Informed Neural Networks.",
      theme: "knowledge",
      colorHex: "FF8A2BE2"), // Purple
  MainTaskTemplate(
      id: "study_next_sem",
      name: "Internship and Sem Prep",
      description: "Prepare materials for upcoming academic semester.",
      theme: "learning",
      colorHex: "FFFF7043"), // Orange
  MainTaskTemplate(
      id: "learn_kungfu",
      name: "Lifestyle: Kung Fu",
      description: "Practice Kung Fu forms and techniques.",
      theme: "discipline",
      colorHex: "FFFD4556"), // Red
  MainTaskTemplate(
      id: "build_routine",
      name: "Routine & Reflection",
      description: "Establish routines, track progress, reflect.",
      theme: "order",
      colorHex: "FF4CAF50") // Green
];


Map<String, PlayerStat> basePlayerGameStats = {
  'strength': PlayerStat(name: 'STRENGTH', value: 10, base: 10, description: 'Increases physical damage dealt.', icon: 'mdi-sword'), // MDI Icon
  'runic': PlayerStat(name: 'RUNIC', value: 5, base: 5, description: 'Increases elemental and special attack damage.', icon: 'mdi-fire'), // MDI Icon
  'defense': PlayerStat(name: 'DEFENSE', value: 5, base: 5, description: 'Reduces all damage taken.', icon: 'mdi-shield'), // MDI Icon
  'vitality': PlayerStat(name: 'VITALITY', value: 100, base: 100, description: 'Increases maximum Health.', icon: 'mdi-heart'), // MDI Icon
  'luck': PlayerStat(name: 'LUCK', value: 1, base: 1, description: 'Increases Perk activation, XP, and Coin gains.', icon: 'mdi-clover'), // MDI Icon
  'cooldown': PlayerStat(name: 'COOLDOWN', value: 0, base: 0, description: 'Reduces recharge time of special abilities.', icon: 'mdi-clock-fast'), // MDI Icon
  // bonusXPMod is handled dynamically in GameProvider, not a base displayed stat.
};


// Game constants
// ignore_for_file: constant_identifier_names
const double xpPerLevelBase = 120; 
const double xpLevelMultiplier = 1.18; 
const double baseMaxPlayerEnergy = 100;
const double playerEnergyPerLevelVitality = 5;
const double energyPerAttack = 10;
const double energyRegenPerMinuteTasked = 2;

const double subtaskCompletionXpBase = 5;
const double subtaskCompletionCoinBase = 2;

const double xpPerMinuteSubtask = 0.2;
const double coinsPerMinuteSubtask = 0.05;
const double xpPerCountUnitSubtask = 0.5;
const double coinsPerCountUnitSubtask = 0.1;

const double subSubtaskCompletionXpBase = 1;
const double subSubtaskCompletionCoinBase = 0.5;

const double xpPerCountUnitSubSubtask = 0.1;
const double coinsPerCountUnitSubSubtask = 0.02;

const double blacksmithUpgradeCostMultiplier = 1.5;
const int dailyTaskGoalMinutes = 15;
const double streakBonusCoins = 10;
const double streakBonusXp = 20;
const double artifactSellPercentage = 0.3;

// Initial Game Locations (Moved from game_models.dart and made part of constants for pre-build)
// AI can add to this list via GameProvider.
List<GameLocation> initialGameLocations = [
  GameLocation(id: "loc_dark_forest", name: "Dark Forest", description: "A menacing forest teeming with shadowy beasts.", minPlayerLevelToUnlock: 1, iconEmoji: "🌲", associatedTheme: "nature", bossEnemyIdToUnlockNextLocation: "enemy_forest_guardian"),
  GameLocation(id: "loc_ruined_temple", name: "Ruined Temple", description: "Ancient ruins guarded by forgotten constructs.", minPlayerLevelToUnlock: 3, iconEmoji: "🏛️", associatedTheme: "ancient", bossEnemyIdToUnlockNextLocation: "enemy_temple_golem"),
  // AI can generate more, or they can be added here.
];

// Initial Enemy Templates
List<EnemyTemplate> initialEnemyTemplates = [
  EnemyTemplate(id: "enemy_goblin_scout", name: "Goblin Scout", theme: "nature", locationKey: "loc_dark_forest", minPlayerLevel: 1, health: 40, attack: 6, defense: 2, coinReward: 10, xpReward: 15, description: "A nimble but weak forest scout."),
  EnemyTemplate(id: "enemy_forest_spider", name: "Giant Forest Spider", theme: "nature", locationKey: "loc_dark_forest", minPlayerLevel: 1, health: 60, attack: 8, defense: 3, coinReward: 15, xpReward: 25, description: "A large, venomous arachnid."),
  EnemyTemplate(id: "enemy_forest_guardian", name: "Forest Guardian (Boss)", theme: "nature", locationKey: "loc_dark_forest", minPlayerLevel: 2, health: 150, attack: 12, defense: 5, coinReward: 50, xpReward: 70, description: "An ancient protector of the woods."),
  EnemyTemplate(id: "enemy_stone_servant", name: "Stone Servant", theme: "ancient", locationKey: "loc_ruined_temple", minPlayerLevel: 3, health: 80, attack: 10, defense: 8, coinReward: 25, xpReward: 40, description: "A magically animated stone guard."),
  EnemyTemplate(id: "enemy_temple_golem", name: "Temple Golem (Boss)", theme: "ancient", locationKey: "loc_ruined_temple", minPlayerLevel: 4, health: 200, attack: 15, defense: 10, coinReward: 80, xpReward: 100, description: "The formidable guardian of the temple's heart."),
];

// Initial Artifact Templates
List<ArtifactTemplate> initialArtifactTemplates = [
  // Weapons
  ArtifactTemplate(id: "art_rusty_sword", name: "Rusty Sword", type: "weapon", theme: null, description: "A basic, somewhat worn sword.", cost: 20, icon: "mdi-sword", baseAtt: 2, maxLevel: 3, upgradeBonus: {"att": 1}),
  ArtifactTemplate(id: "art_hunter_bow", name: "Hunter's Bow", type: "weapon", theme: "nature", description: "A simple bow, good for hunting.", cost: 50, icon: "mdi-bow-arrow", baseAtt: 3, baseLuck: 1, maxLevel: 5, upgradeBonus: {"att": 1, "luck": 1}),
  // Armor
  ArtifactTemplate(id: "art_leather_jerkin", name: "Leather Jerkin", type: "armor", theme: null, description: "Basic leather protection.", cost: 30, icon: "mdi-tshirt-crew-outline", baseDef: 1, baseHealth: 5, maxLevel: 3, upgradeBonus: {"def": 1, "health": 5}),
  ArtifactTemplate(id: "art_iron_greaves", name: "Iron Greaves", type: "armor", theme: "tech", description: "Sturdy leg protection.", cost: 60, icon: "mdi-shoe-sneaker", baseDef: 2, baseHealth: 10, maxLevel: 5, upgradeBonus: {"def": 1, "health": 8}), // Changed icon to mdi-shoe-sneaker
  // Talismans
  ArtifactTemplate(id: "art_lucky_clover", name: "Lucky Clover", type: "talisman", theme: "nature", description: "Might bring good fortune.", cost: 40, icon: "mdi-clover", baseLuck: 2, bonusXPMod: 0.02, maxLevel: 3, upgradeBonus: {"luck": 1, "bonusXPMod": 0}),
  // Powerups
  ArtifactTemplate(id: "art_healing_draught", name: "Healing Draught", type: "powerup", theme: null, description: "Restores a small amount of health.", cost: 25, icon: "mdi-bottle-tonic-plus", effectType: "heal_player", effectValue: 30, uses: 1),
];
--- END OF FILE lib/src/utils/constants.dart ---

--- START OF FILE lib/src/widgets/task_navigation_drawer.dart ---
// lib/src/widgets/task_navigation_drawer.dart
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:myapp_flutter/src/models/game_models.dart'; // Added import

// import 'package:flutter_colorpicker/flutter_colorpicker.dart'; // For color picker

class TaskNavigationDrawer extends StatefulWidget {
  const TaskNavigationDrawer({super.key});

  @override
  State<TaskNavigationDrawer> createState() => _TaskNavigationDrawerState();
}

class _TaskNavigationDrawerState extends State<TaskNavigationDrawer> {
  final _newTaskNameController = TextEditingController();
  final _newTaskDescController = TextEditingController();
  String _newTaskTheme = 'tech'; // Default theme
  String _newTaskColorHex = "FF64FFDA"; // Default color (AppTheme.fhAccentTeal)

  // For editing
  final _editTaskNameController = TextEditingController();
  final _editTaskDescController = TextEditingController();
  String _editTaskTheme = 'tech';
  String _editTaskColorHex = "FF64FFDA";


  @override
  void dispose() {
    _newTaskNameController.dispose();
    _newTaskDescController.dispose();
    _editTaskNameController.dispose();
    _editTaskDescController.dispose();
    super.dispose();
  }

  IconData _getThemeIcon(String? theme) {
    switch (theme) {
      case 'tech': return MdiIcons.memory;
      case 'knowledge': return MdiIcons.bookOpenPageVariantOutline;
      case 'learning': return MdiIcons.schoolOutline; 
      case 'discipline': return MdiIcons.karate;
      case 'order': return MdiIcons.playlistCheck;
      default: return MdiIcons.targetAccount; 
    }
  }

  void _showAddTaskDialog(BuildContext context, GameProvider gameProvider) {
    _newTaskNameController.clear();
    _newTaskDescController.clear();
    _newTaskTheme = 'tech'; // Reset to default
    _newTaskColorHex = "FF64FFDA"; // Reset to default

    showDialog(
      context: context,
      builder: (BuildContext dialogContext) {
        // Use a StatefulWidget for the dialog content to manage local state for color picker
        return StatefulBuilder(
          builder: (BuildContext context, StateSetter setStateDialog) {
            return AlertDialog(
              backgroundColor: AppTheme.fhBgMedium,
              title: Text('Add New Mission', style: TextStyle(color: AppTheme.fhAccentRed)),
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: <Widget>[
                    TextField(controller: _newTaskNameController, decoration: InputDecoration(labelText: 'Mission Name')),
                    const SizedBox(height: 8),
                    TextField(controller: _newTaskDescController, decoration: InputDecoration(labelText: 'Description'), maxLines: 2),
                    const SizedBox(height: 8),
                    DropdownButtonFormField<String>(
                      decoration: InputDecoration(labelText: 'Theme'),
                      dropdownColor: AppTheme.fhBgLight,
                      value: _newTaskTheme,
                      items: ['tech', 'knowledge', 'learning', 'discipline', 'order', 'general']
                          .map((String value) => DropdownMenuItem<String>(value: value, child: Text(value)))
                          .toList(),
                      onChanged: (String? newValue) {
                         if (newValue != null) {
                            setStateDialog(() => _newTaskTheme = newValue);
                         }
                      },
                    ),
                    const SizedBox(height: 16),
                    Text("Select Theme Color:", style: Theme.of(context).textTheme.labelMedium),
                    const SizedBox(height: 8),
                    // Simplified Color Picker (Grid of predefined colors)
                    Wrap(
                      spacing: 8.0,
                      runSpacing: 8.0,
                      children: [
                        AppTheme.fhAccentRed, AppTheme.fhAccentTeal, AppTheme.fhAccentGold,
                        AppTheme.fhAccentPurple, AppTheme.fhAccentGreen, AppTheme.fhAccentOrange,
                        Color(0xFF0077B6), Color(0xFFFCA311) // Blue, Another Orange
                      ].map((color) {
                        String colorHex = color.value.toRadixString(16).toUpperCase();
                        return GestureDetector(
                          onTap: () => setStateDialog(() => _newTaskColorHex = colorHex),
                          child: Container(
                            width: 30, height: 30,
                            decoration: BoxDecoration(
                              color: color,
                              borderRadius: BorderRadius.circular(4),
                              border: _newTaskColorHex == colorHex
                                  ? Border.all(color: Colors.white, width: 2)
                                  : null,
                            ),
                          ),
                        );
                      }).toList(),
                    ),
                    // For a full color picker, you would use:
                    // ColorPicker(
                    //   pickerColor: Color(int.parse("0x$_newTaskColorHex")),
                    //   onColorChanged: (color) => setStateDialog(() => _newTaskColorHex = color.value.toRadixString(16).toUpperCase()),
                    // ),
                  ],
                ),
              ),
              actions: <Widget>[
                TextButton(child: Text('Cancel'), onPressed: () => Navigator.of(dialogContext).pop()),
                ElevatedButton(
                  child: Text('Add Mission'),
                  onPressed: () {
                    if (_newTaskNameController.text.isNotEmpty) {
                      gameProvider.addMainTask(
                        name: _newTaskNameController.text,
                        description: _newTaskDescController.text,
                        theme: _newTaskTheme,
                        colorHex: _newTaskColorHex,
                      );
                      Navigator.of(dialogContext).pop();
                    }
                  },
                ),
              ],
            );
          }
        );
      },
    );
  }
  
  void _showEditTaskDialog(BuildContext context, GameProvider gameProvider, MainTask taskToEdit) {
    _editTaskNameController.text = taskToEdit.name;
    _editTaskDescController.text = taskToEdit.description;
    _editTaskTheme = taskToEdit.theme;
    _editTaskColorHex = taskToEdit.colorHex;

    showDialog(
      context: context,
      builder: (BuildContext dialogContext) {
        return StatefulBuilder( // For managing dialog's local state (color picker)
          builder: (BuildContext context, StateSetter setStateDialog) {
            return AlertDialog(
              backgroundColor: AppTheme.fhBgMedium,
              title: Text('Edit Mission', style: TextStyle(color: AppTheme.fhAccentRed)),
              content: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: <Widget>[
                    TextField(controller: _editTaskNameController, decoration: InputDecoration(labelText: 'Mission Name')),
                    const SizedBox(height: 8),
                    TextField(controller: _editTaskDescController, decoration: InputDecoration(labelText: 'Description'), maxLines: 2),
                    const SizedBox(height: 8),
                    DropdownButtonFormField<String>(
                       decoration: InputDecoration(labelText: 'Theme'),
                       dropdownColor: AppTheme.fhBgLight,
                       value: _editTaskTheme,
                       items: ['tech', 'knowledge', 'learning', 'discipline', 'order', 'general']
                          .map((String value) => DropdownMenuItem<String>(value: value, child: Text(value)))
                          .toList(),
                       onChanged: (String? newValue) {
                          if (newValue != null) {
                            setStateDialog(() => _editTaskTheme = newValue);
                          }
                       }
                    ),
                     const SizedBox(height: 16),
                     Text("Select Theme Color:", style: Theme.of(context).textTheme.labelMedium),
                     const SizedBox(height: 8),
                     Wrap( // Simplified Color Picker
                       spacing: 8.0, runSpacing: 8.0,
                       children: [AppTheme.fhAccentRed, AppTheme.fhAccentTeal, AppTheme.fhAccentGold, AppTheme.fhAccentPurple, AppTheme.fhAccentGreen, AppTheme.fhAccentOrange, Color(0xFF0077B6), Color(0xFFFCA311)]
                           .map((color) {
                         String colorHex = color.value.toRadixString(16).toUpperCase();
                         return GestureDetector(
                           onTap: () => setStateDialog(() => _editTaskColorHex = colorHex),
                           child: Container(
                             width: 30, height: 30,
                             decoration: BoxDecoration(
                               color: color,
                               borderRadius: BorderRadius.circular(4),
                               border: _editTaskColorHex == colorHex ? Border.all(color: Colors.white, width: 2) : null,
                             ),
                           ),
                         );
                       }).toList(),
                     ),
                  ],
                ),
              ),
              actions: <Widget>[
                TextButton(child: Text('Cancel'), onPressed: () => Navigator.of(dialogContext).pop()),
                ElevatedButton(
                  child: Text('Save Changes'),
                  onPressed: () {
                    if (_editTaskNameController.text.isNotEmpty) {
                      gameProvider.editMainTask(
                        taskToEdit.id,
                        name: _editTaskNameController.text,
                        description: _editTaskDescController.text,
                        theme: _editTaskTheme,
                        colorHex: _editTaskColorHex,
                      );
                      Navigator.of(dialogContext).pop();
                    }
                  },
                ),
              ],
            );
          }
        );
      },
    );
  }


  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);

    return Drawer( // Or Container if used as a fixed panel
      backgroundColor: AppTheme.fhBgDark, // Match Valorant panel style
      child: Column(
        children: [
          AppBar( // Styled header for the panel
            title: Text('MISSIONS', style: theme.textTheme.headlineSmall?.copyWith(color: AppTheme.fhTextPrimary, letterSpacing: 1)),
            automaticallyImplyLeading: false, 
            backgroundColor: AppTheme.fhBgMedium,
            elevation: 0,
            actions: [
              IconButton(
                icon: Icon(MdiIcons.plusCircleOutline, color: AppTheme.fhAccentTeal),
                onPressed: () => _showAddTaskDialog(context, gameProvider),
                tooltip: 'Add New Mission',
              ),
            ],
          ),
          Expanded(
            child: gameProvider.mainTasks.isEmpty
                ? Center(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Text(
                        'No missions available. Add a new one to begin.',
                        style: theme.textTheme.bodyMedium?.copyWith(color: AppTheme.fhTextSecondary, fontStyle: FontStyle.italic),
                        textAlign: TextAlign.center,
                      ),
                    ),
                  )
                : ListView.builder(
                    padding: EdgeInsets.zero,
                    itemCount: gameProvider.mainTasks.length,
                    itemBuilder: (context, index) {
                      final task = gameProvider.mainTasks[index];
                      final isSelected = gameProvider.selectedTaskId == task.id;
                      final taskColor = Color(int.parse("0x${task.colorHex}"));

                      return Material( // For InkWell splash
                        color: isSelected ? taskColor.withOpacity(0.25) : Colors.transparent,
                        child: ListTile(
                          leading: Icon(
                            _getThemeIcon(task.theme),
                            color: isSelected ? taskColor : AppTheme.fhTextSecondary,
                            size: 22,
                          ),
                          title: Text(
                            task.name,
                            style: theme.textTheme.titleMedium?.copyWith(
                              color: isSelected ? taskColor : AppTheme.fhTextPrimary,
                              fontWeight: isSelected ? FontWeight.bold : FontWeight.w500, // Bolder selection
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                          trailing: Wrap(
                            spacing: 0, // No space between edit and streak
                            children: [
                              if (task.streak > 0)
                                Chip(
                                  avatar: Icon(MdiIcons.fire, color: AppTheme.fhAccentOrange, size: 14),
                                  label: Text('${task.streak}', style: TextStyle(color: AppTheme.fhAccentOrange, fontSize: 11, fontWeight: FontWeight.bold)),
                                  backgroundColor: AppTheme.fhBgMedium, // Darker chip
                                  padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 0),
                                  visualDensity: VisualDensity.compact,
                                ),
                              IconButton(
                                icon: Icon(MdiIcons.pencilOutline, size: 18, color: AppTheme.fhTextSecondary.withOpacity(0.7)),
                                onPressed: () => _showEditTaskDialog(context, gameProvider, task),
                                tooltip: 'Edit Mission',
                                padding: EdgeInsets.zero,
                                constraints: BoxConstraints(),
                              ),
                            ]
                          ),
                          selected: isSelected,
                          onTap: () {
                            gameProvider.setSelectedTaskId(task.id);
                            if (gameProvider.currentView != 'task-details') {
                                gameProvider.setCurrentView('task-details');
                            }
                            // Close drawer on small screens
                            if (MediaQuery.of(context).size.width < 900) { // Match HomeScreen breakpoint
                              Navigator.pop(context);
                            }
                          },
                          selectedTileColor: taskColor.withOpacity(0.15), // Use task color for selection
                          contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8), // Increased vertical padding
                        ),
                      );
                    },
                  ),
          ),
        ],
      ),
    );
  }
}
--- END OF FILE lib/src/widgets/task_navigation_drawer.dart ---

--- START OF FILE lib/src/widgets/middle_panel_widget.dart ---
// lib/src/widgets/middle_panel_widget.dart
import 'package:flutter/material.dart';

class MiddlePanelWidget extends StatelessWidget {
  final int selectedIndex;
  final List<Widget> views;

  const MiddlePanelWidget({
    super.key,
    required this.selectedIndex,
    required this.views,
  });

  @override
  Widget build(BuildContext context) {
    print("[MiddlePanelWidget] Building. SelectedIndex: $selectedIndex");

    // Define a maximum width for the content
    const double maxWidth = 600.0; // Slightly wider for better viewability

    return Padding(
      padding: const EdgeInsets.fromLTRB(0, 8, 0, 0),
      child: Center( // Center the content horizontally
        child: ConstrainedBox( // Apply maxWidth
          constraints: const BoxConstraints(maxWidth: maxWidth),
          child: IndexedStack(
            index: selectedIndex,
            children: views.map((view) {
              // Wrap each view in a SingleChildScrollView and KeepAliveWrapper
              return KeepAliveWrapper(
                child: SingleChildScrollView(
                  padding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 8.0),
                  child: view,
                ),
              );
            }).toList(),
          ),
        ),
      ),
    );
  }
}

// Helper widget to keep state in IndexedStack (similar to TabBarView's needs)
class KeepAliveWrapper extends StatefulWidget {
  final Widget child;
  const KeepAliveWrapper({super.key, required this.child});

  @override
  State<KeepAliveWrapper> createState() => _KeepAliveWrapperState();
}

class _KeepAliveWrapperState extends State<KeepAliveWrapper> with AutomaticKeepAliveClientMixin {
  @override
  Widget build(BuildContext context) {
    super.build(context); // Important to call super.build
    return widget.child;
  }

  @override
  bool get wantKeepAlive => true;
}
--- END OF FILE lib/src/widgets/middle_panel_widget.dart ---

--- START OF FILE lib/src/widgets/left_panel_widget.dart ---
// lib/src/widgets/left_panel_widget.dart
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart'; // For theme icons

class LeftPanelWidget extends StatelessWidget {
  const LeftPanelWidget({super.key});

  IconData _getThemeIcon(String? theme) {
    switch (theme) {
      case 'tech': return MdiIcons.memory;
      case 'knowledge': return MdiIcons.bookOpenPageVariantOutline;
      case 'learning': return MdiIcons.lightbulbOutline;
      case 'discipline': return MdiIcons.karate; 
      case 'order': return MdiIcons.playlistCheck;
      default: return MdiIcons.briefcaseOutline;
    }
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    final isMobile = MediaQuery.of(context).size.width < 768; // Adjusted to match HomeScreen's desktop breakpoint logic

    // print("[LeftPanelWidget] Building LeftPanelWidget. Mobile: $isMobile"); // DEBUG

    // Mobile view now primarily driven by HomeScreen's SingleChildScrollView
    // Desktop View is also effectively mobile now due to HomeScreen changes.
    // So, we can unify the logic more or keep the structure for potential future re-differentiation.
    // For now, we'll keep the isMobile check but ensure it works within a scrollable context.

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(
          mainAxisSize: MainAxisSize.min, 
          children: [
            Row(
              children: [
                Icon(MdiIcons.swordCross, color: AppTheme.fhAccentTeal, size: isMobile ? 24 : 28),
                const SizedBox(width: 8),
                Text('Quests', style: isMobile ? theme.textTheme.titleLarge : theme.textTheme.headlineSmall?.copyWith(fontFamily: AppTheme.fontDisplay)),
              ],
            ),
            const Divider(height: 16),
            if (gameProvider.mainTasks.isEmpty)
              const Padding( 
                padding: EdgeInsets.symmetric(vertical: 20.0),
                child: Center(child: Text('No quests available.', style: TextStyle(color: AppTheme.fhTextSecondary, fontStyle: FontStyle.italic))),
              )
            else if (isMobile) // Horizontal scroll for icons on mobile
              SizedBox( 
                height: 60, 
                child: ListView.builder(
                  scrollDirection: Axis.horizontal,
                  itemCount: gameProvider.mainTasks.length,
                  itemBuilder: (ctx, index) {
                    final task = gameProvider.mainTasks[index];
                    final isSelected = gameProvider.selectedTaskId == task.id;
                    return Tooltip(
                      message: task.name,
                      child: Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 4.0),
                        child: InkWell(
                          onTap: () {
                            gameProvider.setSelectedTaskId(task.id);
                            gameProvider.setCurrentView('task-details');
                          },
                          borderRadius: BorderRadius.circular(8),
                          child: Container(
                            width: 48,
                            height: 48,
                            decoration: BoxDecoration(
                              color: isSelected ? AppTheme.fhAccentTeal : AppTheme.fhBgLight,
                              border: Border.all(
                                color: isSelected ? AppTheme.fhAccentTeal : AppTheme.fhBorderColor,
                                width: 2,
                              ),
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Icon(
                              _getThemeIcon(task.theme),
                              color: isSelected ? Colors.white : AppTheme.fhTextSecondary,
                              size: 24,
                            ),
                          ),
                        ),
                      ),
                    );
                  },
                ),
              )
            else // Vertical list for larger screens (now also part of SingleChildScrollView)
              ListView.builder(
                shrinkWrap: true, // Important for ListView in Column
                physics: const NeverScrollableScrollPhysics(), // Parent scrolls
                itemCount: gameProvider.mainTasks.length,
                itemBuilder: (context, index) {
                  final task = gameProvider.mainTasks[index];
                  final isSelected = gameProvider.selectedTaskId == task.id;
                  return Card( 
                    elevation: isSelected ? 2 : 0,
                    margin: const EdgeInsets.only(bottom: 8.0),
                    color: isSelected ? AppTheme.fhAccentTeal.withOpacity(0.2) : AppTheme.fhBgLight,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(6.0),
                      side: BorderSide(
                        color: isSelected ? AppTheme.fhAccentTeal : Colors.transparent,
                        width: 2,
                      ),
                    ),
                    child: ListTile(
                      leading: Icon(_getThemeIcon(task.theme), color: isSelected ? AppTheme.fhAccentTeal : AppTheme.fhTextSecondary, size: 22,),
                      title: Text(
                        task.name,
                        style: theme.textTheme.titleMedium?.copyWith(
                          color: isSelected ? AppTheme.fhTextPrimary : AppTheme.fhTextPrimary,
                          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
                          fontSize: 15,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                      trailing: Chip(
                        label: Text('🔥${task.streak}'),
                        backgroundColor: Colors.transparent,
                        labelStyle: TextStyle(
                          color: isSelected ? AppTheme.fhTextPrimary : AppTheme.fhAccentOrange,
                          fontWeight: FontWeight.bold,
                          fontSize: 13,
                        ),
                        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                        visualDensity: VisualDensity.compact,
                      ),
                      selected: isSelected,
                      onTap: () {
                        gameProvider.setSelectedTaskId(task.id);
                        gameProvider.setCurrentView('task-details');
                      },
                      selectedTileColor: AppTheme.fhAccentTeal.withOpacity(0.15),
                      contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
                    ),
                  );
                },
              ),
            if (isMobile && gameProvider.selectedTaskId != null && gameProvider.mainTasks.isNotEmpty) ...[ 
              const Divider(height: 16),
              Text(
                gameProvider.getSelectedTask()?.name ?? 'Select a Quest',
                style: theme.textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.bold, color: AppTheme.fhTextPrimary),
                textAlign: TextAlign.center,
                overflow: TextOverflow.ellipsis,
              ),
              Text(
                '🔥 Streak: ${gameProvider.getSelectedTask()?.streak ?? 0}',
                style: theme.textTheme.bodyMedium?.copyWith(color: AppTheme.fhAccentOrange, fontWeight: FontWeight.bold),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/left_panel_widget.dart ---

--- START OF FILE lib/src/widgets/right_panel_widget.dart ---
// lib/src/widgets/right_panel_widget.dart
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
// import 'package:myapp_flutter/src/utils/constants.dart'; // Removed unused import
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:myapp_flutter/src/models/game_models.dart'; // Ensured models are imported for OwnedArtifact, ArtifactTemplate


class RightPanelWidget extends StatelessWidget {
  const RightPanelWidget({super.key});

  Widget _buildStatDisplay(BuildContext context, String iconEmoji, String name, String value, {String? buffValue, Color? buffColor, String? description, double? progressPercent}) {
    final theme = Theme.of(context);
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Text(iconEmoji, style: TextStyle(fontSize: 18, color: AppTheme.fhTextSecondary.withAlpha((0.8 * 255).round()))), // Fixed withOpacity
              const SizedBox(width: 10),
              Expanded(
                child: Text(
                  name.toUpperCase(),
                  style: theme.textTheme.titleSmall?.copyWith(fontFamily: AppTheme.fontDisplay, color: AppTheme.fhTextPrimary, fontSize: 13, letterSpacing: 0.5),
                ),
              ),
              if (buffValue != null)
                Text(
                  buffValue,
                  style: theme.textTheme.labelSmall?.copyWith(color: buffColor, fontWeight: FontWeight.bold),
                ),
              const SizedBox(width: 4),
              Text(
                value,
                style: theme.textTheme.titleSmall?.copyWith(color: AppTheme.fhTextPrimary, fontWeight: FontWeight.bold, fontSize: 14),
              ),
            ],
          ),
          if (progressPercent != null && name.toUpperCase() != 'VITALITY' && name.toUpperCase() != 'XP BONUS') 
            Padding(
              padding: const EdgeInsets.only(top: 4.0, left: 30), 
              child: SizedBox(
                height: 8,
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(4),
                  child: LinearProgressIndicator(
                  value: progressPercent.clamp(0.0, 1.0),
                  backgroundColor: AppTheme.fhBgLight.withAlpha((0.5 * 255).round()), // Fixed withOpacity
                  valueColor: const AlwaysStoppedAnimation<Color>(AppTheme.fhAccentOrange),
                  ),
                )
              ),
            ),
          if (gameProvider.settings.descriptionsVisible && description != null && description.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(top: 4.0, left: 30),
              child: Text(
                description,
                style: theme.textTheme.bodySmall?.copyWith(fontSize: 11, color: AppTheme.fhTextSecondary.withAlpha((0.8 * 255).round()), fontStyle: FontStyle.italic), // Fixed withOpacity
              ),
            ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    // print("[RightPanelWidget] Building RightPanelWidget"); // DEBUG

    final playerMaxHp = gameProvider.playerGameStats['vitality']!.value;
    final playerCurrentHp = gameProvider.currentGame.playerCurrentHp;
    final hpPercent = playerMaxHp > 0 ? (playerCurrentHp / playerMaxHp) : 0.0;
    Color hpBarColor;
    if (hpPercent * 100 > 60) {
      hpBarColor = AppTheme.fhAccentGreen;
    } else if (hpPercent * 100 > 30) {
      hpBarColor = AppTheme.fhAccentOrange;
    } else {
      hpBarColor = AppTheme.fhAccentRed;
    }


    final Map<String, dynamic> equippedItemsDetails = {};
    gameProvider.equippedItems.forEach((slot, uniqueId) {
        if (uniqueId != null) {
            final owned = gameProvider.artifacts.firstWhere((art) => art.uniqueId == uniqueId, orElse: () => OwnedArtifact(uniqueId: '', templateId: '', currentLevel: 0)); 
            if (owned.uniqueId.isNotEmpty) {
              final template = gameProvider.artifactTemplatesList.firstWhere((tmpl) => tmpl.id == owned.templateId, orElse: () => ArtifactTemplate(id:'', name:'', type:'', description: '', cost:0, icon:'')); 
              if (template.id.isNotEmpty) {
                equippedItemsDetails[slot] = {
                  'name': template.name,
                  'icon': template.icon,
                  'level': owned.currentLevel,
                  'uniqueId': owned.uniqueId,
                };
              } else {
                 equippedItemsDetails[slot] = {'name': 'Unknown Item', 'icon': '❓', 'level': 0, 'uniqueId': uniqueId};
              }
            } else {
                equippedItemsDetails[slot] = {'name': 'Error Loading', 'icon': '⚠️', 'level': 0, 'uniqueId': uniqueId};
            }
        } else {
            equippedItemsDetails[slot] = {'name': 'None', 'icon': '➖', 'level': null, 'uniqueId': null};
        }
    });

    final unequippedArtifacts = gameProvider.artifacts.where((ownedArt) =>
        !gameProvider.equippedItems.values.contains(ownedArt.uniqueId) &&
        (gameProvider.artifactTemplatesList.firstWhere((t) => t.id == ownedArt.templateId, orElse: () => ArtifactTemplate(id:'', name:'', type:'', description: '', cost:0, icon:'')).type != 'powerup')
    ).toList();


    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisSize: MainAxisSize.min, 
          children: <Widget>[
            Row(
              children: <Widget>[
                Text(
                  'VIT',
                  style: theme.textTheme.titleMedium?.copyWith(fontFamily: AppTheme.fontDisplay, fontWeight: FontWeight.bold),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: SizedBox(
                    height: 10, 
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(5), 
                      child: LinearProgressIndicator(
                        value: hpPercent,
                        backgroundColor: AppTheme.fhBgLight.withAlpha((0.5 * 255).round()), // Fixed withOpacity
                        valueColor: AlwaysStoppedAnimation<Color>(hpBarColor),
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Text(
                  '${playerCurrentHp.toStringAsFixed(0)} / ${playerMaxHp.toStringAsFixed(0)}',
                  style: theme.textTheme.bodySmall?.copyWith(color: AppTheme.fhTextPrimary),
                ),
                const SizedBox(width: 12),
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: AppTheme.fhAccentTeal,
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Text(
                    gameProvider.romanize(gameProvider.playerLevel),
                    style: theme.textTheme.labelSmall?.copyWith(color: AppTheme.fhBgDark, fontWeight: FontWeight.bold),
                  ),
                ),
              ],
            ),
            const Divider(height: 24),

            _buildSectionTitle(theme, MdiIcons.hanger, 'Equipped Gear'),
            _buildEquippedItemRow(theme, 'Weapon', equippedItemsDetails['weapon'], () => gameProvider.unequipArtifact('weapon')),
            _buildEquippedItemRow(theme, 'Armor', equippedItemsDetails['armor'], () => gameProvider.unequipArtifact('armor')),
            _buildEquippedItemRow(theme, 'Talisman', equippedItemsDetails['talisman'], () => gameProvider.unequipArtifact('talisman')),
            const Divider(height: 24),

            _buildSectionTitle(theme, MdiIcons.bagPersonalOutline, 'Backpack (Gear)'),
             unequippedArtifacts.isEmpty
                ? Padding( 
                    padding: const EdgeInsets.symmetric(vertical: 20.0),
                    child: Center(child: Text('Backpack is empty of gear.', style: theme.textTheme.bodySmall?.copyWith(fontStyle: FontStyle.italic, color: AppTheme.fhTextSecondary))),
                  )
                : ListView.builder(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(), 
                    itemCount: unequippedArtifacts.length,
                    itemBuilder: (context, index) {
                      final ownedArt = unequippedArtifacts[index];
                      final template = gameProvider.artifactTemplatesList.firstWhere((t) => t.id == ownedArt.templateId, orElse: () => ArtifactTemplate(id:'', name:'', type:'', description: '', cost:0, icon:''));
                      if (template.id == '') return const SizedBox.shrink();

                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 2.0),
                        child: Material( 
                          color: AppTheme.fhBgLight.withAlpha((0.5 * 255).round()), // Fixed withOpacity
                          borderRadius: BorderRadius.circular(4),
                          child: InkWell(
                            onTap: () => gameProvider.equipArtifact(ownedArt.uniqueId),
                            borderRadius: BorderRadius.circular(4),
                            child: Padding(
                              padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 6.0),
                              child: Row(
                                children: [
                                  Text(template.icon, style: const TextStyle(fontSize: 16)),
                                  const SizedBox(width: 8),
                                  Expanded(
                                    child: Text(
                                      '${template.name} (Lvl ${ownedArt.currentLevel})',
                                      style: theme.textTheme.bodySmall?.copyWith(color: AppTheme.fhTextPrimary),
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                  ),
                                  OutlinedButton(
                                    onPressed: () => gameProvider.equipArtifact(ownedArt.uniqueId),
                                    style: OutlinedButton.styleFrom(
                                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                                      textStyle: const TextStyle(fontSize: 10, fontFamily: AppTheme.fontBody),
                                      side: BorderSide(color: AppTheme.fhAccentOrange.withAlpha((0.5 * 255).round()), width: 0.5), // Fixed withOpacity
                                      foregroundColor: AppTheme.fhAccentTeal,
                                      minimumSize: const Size(0, 24), 
                                    ),
                                    child: const Text('EQUIP'),
                                  ),
                                ],
                              ),
                            ),
                          ),
                        ),
                      );
                    },
                  ),
            const Divider(height: 24),

             _buildSectionTitle(theme, MdiIcons.accountStarOutline, 'Player Stats'),
            ListView(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(), 
              children: gameProvider.playerGameStats.entries.map((entry) {
                final stat = entry.value;
                final buffValue = stat.value - stat.base;
                String statValDisplay = stat.value.toStringAsFixed(stat.name == 'XP Bonus' ? 2 : 0);
                if (stat.name == 'LUCK' || stat.name == 'COOLDOWN' || stat.name == 'XP Bonus') {
                  statValDisplay = '${(stat.value * (stat.name == 'XP Bonus' ? 100 : 1)).toStringAsFixed(0)}%';
                }
                
                String? buffDisplay;
                Color? buffColorVal;
                if (buffValue != 0 && stat.name != 'XP Bonus') {
                    buffDisplay = '${buffValue > 0 ? '+' : ''}${ (stat.name == 'LUCK' || stat.name == 'COOLDOWN') ? '${buffValue.toStringAsFixed(0)}%' : buffValue.toStringAsFixed(0) }';
                    buffColorVal = buffValue > 0 ? AppTheme.fhAccentGreen : AppTheme.fhAccentRed;
                }

                double progress = 0.0;
                if (stat.name != 'VITALITY' && stat.name != 'XP Bonus') {
                  double typicalMax = 50; 
                  if (stat.name == 'LUCK' || stat.name == 'COOLDOWN') typicalMax = 50; 
                  progress = (stat.value / typicalMax);
                }


                return _buildStatDisplay(
                  context,
                  stat.icon,
                  stat.name,
                  statValDisplay,
                  buffValue: buffDisplay,
                  buffColor: buffColorVal,
                  description: stat.description,
                  progressPercent: (stat.name != 'VITALITY' && stat.name != 'XP Bonus') ? progress : null,
                );
              }).toList(),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionTitle(ThemeData theme, IconData icon, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0),
      child: Row(
        children: [
          Icon(icon, color: AppTheme.fhAccentTeal, size: 18),
          const SizedBox(width: 8),
          Text(
            title,
            style: theme.textTheme.titleSmall?.copyWith(fontFamily: AppTheme.fontDisplay, color: AppTheme.fhTextSecondary, fontSize: 14, letterSpacing: 0.5),
          ),
        ],
      ),
    );
  }

  Widget _buildEquippedItemRow(ThemeData theme, String label, Map<String, dynamic>? itemDetails, VoidCallback onUnequip) {
    final String name = itemDetails?['name'] ?? 'None';
    final String icon = itemDetails?['icon'] ?? '➖';
    final int? level = itemDetails?['level'];
    final String? uniqueId = itemDetails?['uniqueId'];

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        children: [
          SizedBox(
            width: 65, 
            child: Text('$label:', style: theme.textTheme.bodySmall?.copyWith(color: AppTheme.fhTextSecondary)),
          ),
          Text(icon, style: const TextStyle(fontSize: 16)),
          const SizedBox(width: 6),
          Expanded(
            child: Text(
              level != null ? '$name (Lvl $level)' : name,
              style: theme.textTheme.bodySmall?.copyWith(
                color: name == 'None' ? AppTheme.fhTextSecondary.withAlpha((0.7 * 255).round()) : AppTheme.fhAccentTeal, // Fixed withOpacity & fhAccentLightCyan
                fontStyle: name == 'None' ? FontStyle.italic : FontStyle.normal,
                fontWeight: name == 'None' ? FontWeight.normal : FontWeight.bold,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          if (uniqueId != null)
            TextButton(
              onPressed: onUnequip,
              style: TextButton.styleFrom(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                textStyle: const TextStyle(fontSize: 10, fontFamily: AppTheme.fontBody),
                foregroundColor: AppTheme.fhAccentRed,
                minimumSize: const Size(0, 24),
                side: BorderSide(color: AppTheme.fhAccentRed.withAlpha((0.5 * 255).round()), width: 0.5), // Fixed withOpacity
              ),
              child: const Text('UNEQUIP'),
            ),
        ],
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/right_panel_widget.dart ---

--- START OF FILE lib/src/widgets/header_widget.dart ---
// lib/src/widgets/header_widget.dart
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/screens/logbook_screen.dart';
import 'package:myapp_flutter/src/screens/settings_screen.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class HeaderWidget extends StatelessWidget {
  final String currentViewLabel;
  const HeaderWidget({super.key, required this.currentViewLabel});

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    final screenWidth = MediaQuery.of(context).size.width;
    final bool isSmallScreen = screenWidth < 900; // Match HomeScreen breakpoint
    final Color currentAccentColor = gameProvider.getSelectedTask()?.taskColor ?? theme.colorScheme.secondary;


    return Container( 
      color: Colors.transparent, 
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            height: kToolbarHeight,
            padding: const EdgeInsets.symmetric(horizontal: 8.0),
            child: Row(
              children: <Widget>[
                if (isSmallScreen) 
                  IconButton(
                    icon: Icon(MdiIcons.formatListChecks, color: AppTheme.fhTextSecondary),
                    onPressed: () => Scaffold.of(context).openDrawer(), 
                    tooltip: 'Missions',
                  ),
                if (!isSmallScreen) 
                   Icon(MdiIcons.shieldCrownOutline, color: currentAccentColor, size: 32),
                const SizedBox(width: 12),
                
                Expanded(
                  child: Text(
                    currentViewLabel.toUpperCase(), 
                    style: theme.textTheme.headlineSmall?.copyWith(
                      color: AppTheme.fhTextPrimary,
                      letterSpacing: 1.0,
                    ),
                    textAlign: isSmallScreen ? TextAlign.start : TextAlign.center,
                  ),
                ),
                IconButton(
                  icon: Icon(MdiIcons.bookOpenVariant, color: AppTheme.fhTextSecondary),
                  onPressed: () {
                    Navigator.push(context, MaterialPageRoute(builder: (context) => const LogbookScreen()));
                  },
                  tooltip: 'Logbook',
                ),
                IconButton(
                  icon: Icon(MdiIcons.cogOutline, color: AppTheme.fhTextSecondary),
                  onPressed: () {
                    Navigator.push(context, MaterialPageRoute(builder: (context) => const SettingsScreen()));
                  },
                  tooltip: 'Settings',
                ),
                if (isSmallScreen) 
                  IconButton(
                    icon: Icon(MdiIcons.accountCircleOutline, color: AppTheme.fhTextSecondary),
                    onPressed: () => Scaffold.of(context).openEndDrawer(), 
                    tooltip: 'Profile & Stats',
                  ),
              ],
            ),
          ),
          // Stats Row
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 6.0),
            decoration: BoxDecoration(
              color: AppTheme.fhBgDark.withOpacity(0.5),
              border: Border(bottom: BorderSide(color: AppTheme.fhBorderColor.withOpacity(0.3), width:1))
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                _buildStatChip(
                  theme,
                  icon: MdiIcons.circleMultipleOutline, // Coins
                  value: gameProvider.coins.toStringAsFixed(0),
                  color: AppTheme.fhAccentGold,
                ),
                const SizedBox(width: 20),
                _buildStatChip(
                  theme,
                  icon: MdiIcons.flashOutline, // Energy
                  value: '${gameProvider.playerEnergy.toStringAsFixed(0)}/${gameProvider.calculatedMaxEnergy.toStringAsFixed(0)}',
                  color: AppTheme.fhAccentTealFixed, // Retain teal for energy as it's distinct
                ),
                const SizedBox(width: 20),
                _buildStatChip(
                  theme,
                  icon: MdiIcons.starShootingOutline, // XP Level
                  value: 'Lvl ${gameProvider.romanize(gameProvider.playerLevel)}',
                  color: currentAccentColor, // Use dynamic accent
                ),
                const SizedBox(width: 4),
                Expanded(
                  child: SizedBox(
                    height: 6,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(3),
                      child: LinearProgressIndicator(
                        value: (gameProvider.xpProgressPercent / 100).clamp(0.0, 1.0),
                        backgroundColor: AppTheme.fhBorderColor.withOpacity(0.2),
                        valueColor: AlwaysStoppedAnimation<Color>(currentAccentColor.withOpacity(0.7)),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatChip(ThemeData theme, {required IconData icon, required String value, required Color color}) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(icon, color: color, size: 16),
        const SizedBox(width: 6),
        Text(
          value,
          style: theme.textTheme.labelMedium?.copyWith(color: AppTheme.fhTextPrimary, fontWeight: FontWeight.w600, fontSize: 13),
        ),
      ],
    );
  }
}
--- END OF FILE lib/src/widgets/header_widget.dart ---

--- START OF FILE lib/src/widgets/player_stats_drawer.dart ---
// lib/src/widgets/player_stats_drawer.dart
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
// import 'package:myapp_flutter/src/utils/constants.dart'; // No longer needed for basePlayerGameStats

class PlayerStatsDrawer extends StatelessWidget {
  const PlayerStatsDrawer({super.key});

  Widget _buildStatDisplay(
      BuildContext context, String icon, String name, String value, // Changed iconEmoji to icon (MDI name or emoji string)
      {String? buffValue,
      Color? buffColor,
      String? description,
      double? progressPercent}) {
    final theme = Theme.of(context);
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    Widget iconWidget;
    if (icon.length == 1 || icon.length == 2) { // Assume emoji if 1 or 2 chars
        iconWidget = Text(icon, style: TextStyle(fontSize: 20, color: AppTheme.fhAccentTeal.withOpacity(0.9)));
    } else { // Assume MDI icon name if longer
        final iconData = MdiIcons.fromString(icon.replaceAll('mdi-', '')) ?? MdiIcons.helpCircleOutline;
        iconWidget = Icon(iconData, size: 20, color: AppTheme.fhAccentTeal.withOpacity(0.9));
    }


    // Valorant style stat display
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 6.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              iconWidget, // Use the determined icon widget
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  name.toUpperCase(),
                  style: theme.textTheme.labelMedium?.copyWith(
                      color: AppTheme.fhTextSecondary,
                      fontWeight: FontWeight.w600, // Bolder label
                      letterSpacing: 1),
                ),
              ),
              if (buffValue != null)
                Text(
                  buffValue,
                  style: theme.textTheme.labelSmall?.copyWith(
                      color: buffColor,
                      fontWeight: FontWeight.bold,
                      fontSize: 12), // Larger buff text
                ),
              const SizedBox(width: 6),
              Text(
                value,
                style: theme.textTheme.bodyLarge?.copyWith( // Use bodyLarge for stat value
                    color: AppTheme.fhTextPrimary,
                    fontWeight: FontWeight.bold),
              ),
            ],
          ),
          if (progressPercent != null && name.toUpperCase() != 'VITALITY' && name.toUpperCase() != 'XP BONUS')
            Padding(
              padding: const EdgeInsets.only(top: 5.0, left: 32 + 12), // Align with text after icon
              child: SizedBox(
                  height: 6, // Thicker progress bar
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(3),
                    child: LinearProgressIndicator(
                      value: progressPercent.clamp(0.0, 1.0),
                      backgroundColor: AppTheme.fhBorderColor.withOpacity(0.2),
                      valueColor: AlwaysStoppedAnimation<Color>(
                          AppTheme.fhAccentTeal.withOpacity(0.7)),
                    ),
                  )),
            ),
          if (gameProvider.settings.descriptionsVisible &&
              description != null &&
              description.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(top: 4.0, left: 32 + 12),
              child: Text(
                description,
                style: theme.textTheme.bodySmall?.copyWith(
                    fontSize: 10,
                    color: AppTheme.fhTextSecondary.withOpacity(0.7),
                    fontStyle: FontStyle.italic),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(ThemeData theme, IconData icon, String title) {
    return Padding(
      padding: const EdgeInsets.only(
          bottom: 8.0, top: 20.0, left: 16.0, right: 16.0), // Increased top padding
      child: Row(
        children: [
          Icon(icon, color: AppTheme.fhAccentRed, size: 20), // Use primary accent
          const SizedBox(width: 10),
          Text(
            title.toUpperCase(), // Uppercase titles
            style: theme.textTheme.headlineSmall?.copyWith( // Use headlineSmall
                color: AppTheme.fhTextPrimary, // Brighter title
                letterSpacing: 0.8,
                fontWeight: FontWeight.bold),
          ),
        ],
      ),
    );
  }

  Widget _buildEquippedItemRow(BuildContext context, ThemeData theme,
      String label, Map<String, dynamic>? itemDetails, VoidCallback onUnequip) {
    final String name = itemDetails?['name'] ?? 'Empty Slot';
    final String iconStr = itemDetails?['icon'] ?? '➖'; // MDI name or emoji
    final bool isEquipped = itemDetails?['uniqueId'] != null;

    Widget iconWidget;
    if (iconStr.length == 1 || iconStr.length == 2) {
        iconWidget = Text(iconStr, style: const TextStyle(fontSize: 18));
    } else {
        final iconData = MdiIcons.fromString(iconStr.replaceAll('mdi-', '')) ?? MdiIcons.minusCircleOutline;
        iconWidget = Icon(iconData, size: 18);
    }


    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 3.0),
      child: Row(
        children: [
          SizedBox(
            width: 70, // Consistent width for label
            child: Text('$label:',
                style: theme.textTheme.bodyMedium
                    ?.copyWith(color: AppTheme.fhTextSecondary.withOpacity(0.8), fontSize: 13)),
          ),
          iconWidget, // Use the determined icon widget
          const SizedBox(width: 10),
          Expanded(
            child: Text(
               name,
              style: theme.textTheme.bodyMedium?.copyWith(
                fontSize: 13,
                color: isEquipped
                    ? AppTheme.fhAccentTeal // Brighter for equipped items
                    : AppTheme.fhTextSecondary.withOpacity(0.6),
                fontStyle: isEquipped ? FontStyle.normal : FontStyle.italic,
                fontWeight: isEquipped ? FontWeight.w600 : FontWeight.normal,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          if (isEquipped)
            OutlinedButton(
              onPressed: onUnequip,
              style: OutlinedButton.styleFrom(
                padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                textStyle: TextStyle(
                    fontSize: 10, // Smaller text for button
                    fontFamily: AppTheme.fontBody, // Use body font
                    fontWeight: FontWeight.bold),
                foregroundColor: AppTheme.fhAccentOrange, // Orange for unequip
                side: BorderSide(
                    color: AppTheme.fhAccentOrange.withOpacity(0.7), width: 1),
                minimumSize: const Size(0, 26), // Slightly taller button
              ),
              child: const Text('UNEQUIP'),
            ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    print("[PlayerStatsDrawer] Building drawer. Player HP: ${gameProvider.currentGame.playerCurrentHp}");

    final playerMaxHp = gameProvider.playerGameStats['vitality']!.value;
    final playerCurrentHp = gameProvider.currentGame.playerCurrentHp;
    final hpPercent =
        playerMaxHp > 0 ? (playerCurrentHp / playerMaxHp).clamp(0.0, 1.0) : 0.0;
    Color hpBarColor;
    if (hpPercent * 100 > 60) {
      hpBarColor = AppTheme.fhAccentGreen;
    } else if (hpPercent * 100 > 30) {
      hpBarColor = AppTheme.fhAccentOrange;
    } else {
      hpBarColor = AppTheme.fhAccentRed;
    }

    final Map<String, dynamic> equippedItemsDetails = {};
    gameProvider.equippedItems.forEach((slot, uniqueId) {
      if (uniqueId != null) {
        final owned = gameProvider.getArtifactByUniqueId(uniqueId);
        if (owned != null) {
          final template = gameProvider.getArtifactTemplateById(owned.templateId);
          if (template != null) {
            equippedItemsDetails[slot] = {
              'name': '${template.name} Lvl ${owned.currentLevel}', // Include level
              'icon': template.icon,
              'uniqueId': owned.uniqueId,
            };
          } else {
            equippedItemsDetails[slot] = {'name': 'Unknown Item', 'icon': MdiIcons.helpRhombusOutline.codePoint.toString(), 'uniqueId': uniqueId}; // Default icon
          }
        } else {
           equippedItemsDetails[slot] = {'name': 'Error Loading', 'icon': MdiIcons.alertCircleOutline.codePoint.toString(), 'uniqueId': uniqueId}; // Default icon
        }
      } else {
        equippedItemsDetails[slot] = {'name': 'Empty Slot', 'icon': '➖', 'uniqueId': null};
      }
    });

    final unequippedGear = gameProvider.artifacts.where((ownedArt) {
        final template = gameProvider.getArtifactTemplateById(ownedArt.templateId);
        return template != null && template.type != 'powerup' && !gameProvider.equippedItems.values.contains(ownedArt.uniqueId);
    }).toList();


    return Drawer(
      backgroundColor: AppTheme.fhBgDark, // Darker drawer background
      child: ListView(
        padding: EdgeInsets.zero,
        children: <Widget>[
          Container( // Header Section
            padding: EdgeInsets.fromLTRB(
                16, MediaQuery.of(context).padding.top + 16, 16, 16),
            decoration: BoxDecoration(
                color: AppTheme.fhBgMedium, // Slightly lighter header
                border: Border(bottom: BorderSide(color: AppTheme.fhBorderColor.withOpacity(0.5), width: 1))
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  gameProvider.currentUser?.displayName ?? "Adventurer", // Display Name
                  style: theme.textTheme.displaySmall?.copyWith(color: AppTheme.fhAccentRed)
                ),
                const SizedBox(height: 4),
                Text(
                    'LEVEL ${gameProvider.romanize(gameProvider.playerLevel)}',
                    style: theme.textTheme.headlineSmall
                        ?.copyWith(color: AppTheme.fhTextSecondary, letterSpacing: 1)),
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 12.0),
                  child: Row(
                    children: [
                      Icon(MdiIcons.starShootingOutline, color: AppTheme.fhAccentGold, size: 16),
                      const SizedBox(width: 6),
                      Text(
                        '${gameProvider.currentLevelXPProgress.toStringAsFixed(0)} / ${gameProvider.xpNeededForNextLevel.toStringAsFixed(0)} XP',
                        style: theme.textTheme.bodyMedium?.copyWith(color: AppTheme.fhTextSecondary),
                      ),
                    ],
                  ),
                ),
                SizedBox( // XP Bar
                  height: 8, // Thicker XP Bar
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(4),
                    child: LinearProgressIndicator(
                      value: (gameProvider.xpProgressPercent / 100).clamp(0.0, 1.0),
                      backgroundColor: AppTheme.fhBorderColor.withOpacity(0.3),
                      valueColor: const AlwaysStoppedAnimation<Color>(AppTheme.fhAccentGold),
                    ),
                  ),
                ),
                const SizedBox(height: 12),
                Row( // HP Bar
                  children: <Widget>[
                    Icon(MdiIcons.heartPulse, size: 18, color: hpBarColor),
                    const SizedBox(width: 8),
                    Expanded(
                      child: SizedBox(
                        height: 8,
                        child: ClipRRect(
                          borderRadius: BorderRadius.circular(4),
                          child: LinearProgressIndicator(
                            value: hpPercent,
                            backgroundColor: AppTheme.fhBorderColor.withOpacity(0.3),
                            valueColor: AlwaysStoppedAnimation<Color>(hpBarColor),
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 10),
                    Text(
                      '${playerCurrentHp.toStringAsFixed(0)} / ${playerMaxHp.toStringAsFixed(0)} HP',
                      style: theme.textTheme.bodyMedium?.copyWith(color: AppTheme.fhTextPrimary, fontWeight: FontWeight.w600),
                    ),
                  ],
                ),
              ],
            ),
          ),
          _buildSectionTitle(theme, MdiIcons.swordCross, 'Equipped Gear'),
          _buildEquippedItemRow(context, theme, 'Weapon', equippedItemsDetails['weapon'], () => gameProvider.unequipArtifact('weapon')),
          _buildEquippedItemRow(context, theme, 'Armor', equippedItemsDetails['armor'], () => gameProvider.unequipArtifact('armor')),
          _buildEquippedItemRow(context, theme, 'Talisman', equippedItemsDetails['talisman'], () => gameProvider.unequipArtifact('talisman')),

          _buildSectionTitle(theme, MdiIcons.treasureChestOutline, 'Inventory (Gear)'),
          if (unequippedGear.isEmpty)
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 15.0, horizontal: 16.0),
              child: Center(
                  child: Text('No gear in inventory.',
                      style: theme.textTheme.bodyMedium?.copyWith(
                          fontStyle: FontStyle.italic,
                          color: AppTheme.fhTextSecondary.withOpacity(0.7)))),
            )
          else
            ListView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: unequippedGear.length,
              itemBuilder: (context, index) {
                final ownedArt = unequippedGear[index];
                final template = gameProvider.getArtifactTemplateById(ownedArt.templateId);
                if (template == null) return const SizedBox.shrink();

                Widget itemIconWidget;
                if (template.icon.length == 1 || template.icon.length == 2) {
                    itemIconWidget = Text(template.icon, style: const TextStyle(fontSize: 18));
                } else {
                    final iconData = MdiIcons.fromString(template.icon.replaceAll('mdi-', '')) ?? MdiIcons.treasureChest;
                    itemIconWidget = Icon(iconData, size: 18);
                }

                return Padding(
                  padding: const EdgeInsets.symmetric(vertical: 2.0, horizontal: 16.0),
                  child: Material(
                    color: AppTheme.fhBgMedium.withOpacity(0.7), // Item background
                    borderRadius: BorderRadius.circular(4),
                    child: InkWell(
                      onTap: () => gameProvider.equipArtifact(ownedArt.uniqueId),
                      borderRadius: BorderRadius.circular(4),
                      hoverColor: AppTheme.fhAccentTeal.withOpacity(0.1),
                      child: Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 8.0),
                        child: Row(
                          children: [
                            itemIconWidget,
                            const SizedBox(width: 10),
                            Expanded(
                              child: Text(
                                '${template.name} (Lvl ${ownedArt.currentLevel})',
                                style: theme.textTheme.bodyMedium?.copyWith(color: AppTheme.fhTextPrimary, fontSize: 13),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            ElevatedButton(
                              onPressed: () => gameProvider.equipArtifact(ownedArt.uniqueId),
                              style: ElevatedButton.styleFrom(
                                backgroundColor: AppTheme.fhAccentTeal, // Accent for equip
                                foregroundColor: AppTheme.fhBgDark,
                                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                                textStyle: TextStyle(fontSize: 10, fontFamily: AppTheme.fontBody, fontWeight: FontWeight.bold),
                                minimumSize: const Size(0, 28), // Slightly taller button
                                elevation: 1,
                              ),
                              child: const Text('EQUIP'),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                );
              },
            ),

          _buildSectionTitle(theme, MdiIcons.starFourPointsOutline, 'Runes'),
          const Padding(
             padding: EdgeInsets.symmetric(vertical: 15.0, horizontal: 16.0),
             child: Center(child: Text("Rune system not yet active.", style: TextStyle(fontStyle: FontStyle.italic, color: AppTheme.fhTextDisabled))),
          ),


          _buildSectionTitle(theme, MdiIcons.chartLineVariant, 'Player Stats'),
          ListView(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            children: gameProvider.playerGameStats.entries.map((entry) {
              final stat = entry.value;
              if (stat.name == 'XP BONUS' && !gameProvider.playerGameStats.containsKey('bonusXPMod')) return const SizedBox.shrink();


              final buffValue = stat.value - stat.base;
              String statValDisplay = stat.value.toStringAsFixed(0); // Default display

              if (stat.name == 'LUCK' || stat.name == 'COOLDOWN' || stat.name == 'XP CALC MOD') { // Percentage stats
                statValDisplay = '${(stat.value * (stat.name == 'XP CALC MOD' ? 100 : 1)).toStringAsFixed(0)}%';
              }


              String? buffDisplay;
              Color? buffColorVal;
              if (buffValue != 0) {
                buffDisplay = '${buffValue > 0 ? '+' : ''}${(stat.name == 'LUCK' || stat.name == 'COOLDOWN' || stat.name == 'XP CALC MOD') ? '${(buffValue * (stat.name == 'XP CALC MOD' ? 100: 1)).toStringAsFixed(0)}%' : buffValue.toStringAsFixed(0)}';
                buffColorVal = buffValue > 0 ? AppTheme.fhAccentGreen : AppTheme.fhAccentRed;
              }

              double progress = 0.0;
              if (stat.name != 'VITALITY' && stat.name != 'XP CALC MOD') {
                double typicalMax = 50;
                if (stat.name == 'LUCK' || stat.name == 'COOLDOWN') typicalMax = 50;
                progress = (stat.value / typicalMax);
              }

              return _buildStatDisplay(
                context,
                stat.icon, // Pass the MDI name or emoji string
                stat.name,
                statValDisplay,
                buffValue: buffDisplay,
                buffColor: buffColorVal,
                description: stat.description,
                progressPercent: (stat.name != 'VITALITY' && stat.name != 'XP CALC MOD') ? progress : null,
              );
            }).toList(),
          ),
          const SizedBox(height: 20),
        ],
      ),
    );
  }
}
--- END OF FILE lib/src/widgets/player_stats_drawer.dart ---

--- START OF FILE lib/src/widgets/views/settings_view.dart ---
// lib/src/widgets/views/settings_view.dart
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:firebase_auth/firebase_auth.dart'; 
import 'package:intl/intl.dart'; 

class SettingsView extends StatefulWidget {
  const SettingsView({super.key});

  @override
  State<SettingsView> createState() => _SettingsViewState();
}

class _SettingsViewState extends State<SettingsView> {
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  final _newUsernameController = TextEditingController(); // For username change
  bool _passwordChangeLoading = false;
  String _passwordChangeError = '';
  String _passwordChangeSuccess = '';
  bool _usernameChangeLoading = false; // For username change
  String _usernameChangeError = ''; // For username change
  String _usernameChangeSuccess = ''; // For username change
  bool _logoutLoading = false;


  @override
  void initState() {
    super.initState();
    // Initialize username controller if user is available
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    _newUsernameController.text = gameProvider.currentUser?.displayName ?? '';
  }


  @override
  void dispose() {
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    _newUsernameController.dispose();
    super.dispose();
  }

  Future<void> _handleChangePassword(GameProvider gameProvider) async {
    if (_newPasswordController.text != _confirmPasswordController.text) {
      setState(() => _passwordChangeError = "Passwords do not match.");
      return;
    }
    if (_newPasswordController.text.length < 6) {
      setState(() => _passwordChangeError = "Password should be at least 6 characters long.");
      return;
    }
    setState(() {
      _passwordChangeLoading = true;
      _passwordChangeError = '';
      _passwordChangeSuccess = '';
    });
    try {
      await gameProvider.changePasswordHandler(_newPasswordController.text);
      setState(() {
        _passwordChangeSuccess = "Password changed successfully!";
        _newPasswordController.clear();
        _confirmPasswordController.clear();
      });
    } catch (e) {
      if (e is FirebaseAuthException) {
        setState(() => _passwordChangeError = e.message ?? "Failed to change password.");
      } else {
        setState(() => _passwordChangeError = "An unexpected error occurred while changing password.");
      }
    } finally {
      if (mounted) {
        setState(() => _passwordChangeLoading = false);
      }
    }
  }

  Future<void> _handleChangeUsername(GameProvider gameProvider) async {
    if (_newUsernameController.text.trim().isEmpty) {
      setState(() => _usernameChangeError = "Username cannot be empty.");
      return;
    }
    if (_newUsernameController.text.trim().length < 3) {
      setState(() => _usernameChangeError = "Username must be at least 3 characters.");
      return;
    }
    setState(() {
      _usernameChangeLoading = true;
      _usernameChangeError = '';
      _usernameChangeSuccess = '';
    });
    try {
      await gameProvider.updateUserDisplayName(_newUsernameController.text.trim());
      setState(() {
        _usernameChangeSuccess = "Username updated successfully!";
      });
    } catch (e) {
      if (e is FirebaseAuthException) {
        setState(() => _usernameChangeError = e.message ?? "Failed to update username.");
      } else {
        setState(() => _usernameChangeError = "An unexpected error occurred while updating username.");
      }
    } finally {
      if (mounted) {
        setState(() => _usernameChangeLoading = false);
      }
    }
  }


  Future<void> _handleLogout(GameProvider gameProvider, BuildContext pageContext) async {
    setState(() {
      _logoutLoading = true;
    });
    try {
        await gameProvider.logoutUser();
    } catch (e) {
        if (!mounted) return;
        ScaffoldMessenger.of(pageContext).showSnackBar(
            SnackBar(content: Text('Logout failed: ${e.toString()}'), backgroundColor: AppTheme.fhAccentRed)
        );
    } finally {
       if (mounted) {
          setState(() {
            _logoutLoading = false;
          });
       }
    }
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);

    String lastSavedString = "Not synced yet.";
    if (gameProvider.lastSuccessfulSaveTimestamp != null) {
        lastSavedString = "Last synced: ${DateFormat('MMM d, yyyy, hh:mm:ss a').format(gameProvider.lastSuccessfulSaveTimestamp!.toLocal())}";
    }


    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(bottom: 24.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(MdiIcons.cogOutline, color: AppTheme.fhAccentTeal, size: 36),
                const SizedBox(width: 12),
                Text("System Configuration", style: theme.textTheme.displaySmall?.copyWith(color: AppTheme.fhAccentTeal)),
              ],
            ),
          ),

          _buildSettingsSection(
            theme,
            icon: MdiIcons.cloudSyncOutline,
            title: 'Cloud Synchronization',
            children: [
                ElevatedButton.icon(
                    icon: gameProvider.isManuallySaving ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2, color: AppTheme.fhTextPrimary)) : Icon(MdiIcons.cloudUploadOutline, size: 18),
                    label: const Text('SAVE TO CLOUD NOW'),
                    onPressed: gameProvider.isManuallySaving || gameProvider.isManuallyLoading ? null : () async {
                        try {
                            await gameProvider.manuallySaveToCloud();
                            if(mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Data saved to cloud.'), backgroundColor: AppTheme.fhAccentGreen));
                        } catch (e) {
                            if(mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Cloud save failed: ${e.toString()}'), backgroundColor: AppTheme.fhAccentRed));
                        }
                    },
                     style: ElevatedButton.styleFrom(minimumSize: const Size(double.infinity, 44), backgroundColor: AppTheme.fhAccentTeal, foregroundColor: AppTheme.fhBgDark),
                ),
                const SizedBox(height: 12),
                ElevatedButton.icon(
                    icon: gameProvider.isManuallyLoading ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2, color: AppTheme.fhTextPrimary)) : Icon(MdiIcons.cloudDownloadOutline, size: 18),
                    label: const Text('LOAD FROM CLOUD NOW'),
                    onPressed: gameProvider.isManuallySaving || gameProvider.isManuallyLoading ? null : () async {
                        final confirm = await showDialog<bool>(
                            context: context,
                            builder: (ctx) => AlertDialog(
                                title: Row(children: [Icon(MdiIcons.cloudQuestionOutline, color: AppTheme.fhAccentOrange), const SizedBox(width:10),const Text('Confirm Load')]),
                                content: const Text('This will overwrite any local unsaved changes with data from the cloud. Are you sure?'),
                                actionsAlignment: MainAxisAlignment.spaceBetween,
                                actions: [
                                    TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('CANCEL')),
                                    ElevatedButton(onPressed: () => Navigator.of(ctx).pop(true), style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fhAccentOrange), child: const Text('CONFIRM LOAD')),
                                ],
                            ),
                        );
                        if (confirm == true) {
                            try {
                                await gameProvider.manuallyLoadFromCloud();
                                if(mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Data loaded from cloud.'), backgroundColor: AppTheme.fhAccentGreen));
                            } catch (e) {
                                if(mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Cloud load failed: ${e.toString()}'), backgroundColor: AppTheme.fhAccentRed));
                            }
                        }
                    },
                    style: ElevatedButton.styleFrom(minimumSize: const Size(double.infinity, 44), backgroundColor: AppTheme.fhAccentTeal, foregroundColor: AppTheme.fhBgDark),
                ),
                const SizedBox(height: 12),
                Center(
                  child: Text(
                      lastSavedString,
                      style: theme.textTheme.labelSmall?.copyWith(color: AppTheme.fhTextSecondary.withOpacity(0.8), fontSize: 11, fontStyle: FontStyle.italic),
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                    "Note: Game progress is auto-saved to the cloud periodically (approx. every minute if changes are detected). Use these options for immediate synchronization or recovery.",
                    style: theme.textTheme.bodySmall?.copyWith(color: AppTheme.fhTextSecondary.withOpacity(0.8), fontSize: 10),
                ),
            ]
          ),
          
          _buildSettingsSection(
            theme,
            icon: MdiIcons.accountEditOutline,
            title: 'User Profile',
            children: [
              TextFormField(
                controller: _newUsernameController,
                decoration: InputDecoration(labelText: 'Display Name', prefixIcon: Icon(MdiIcons.accountBadgeOutline, size:20)),
                validator: (value) {
                  if (value == null || value.trim().isEmpty) return 'Display name cannot be empty.';
                  if (value.trim().length < 3) return 'Must be at least 3 characters.';
                  return null;
                },
              ),
              if (_usernameChangeError.isNotEmpty)
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Text(_usernameChangeError, style: const TextStyle(color: AppTheme.fhAccentRed, fontSize: 12)),
                ),
              if (_usernameChangeSuccess.isNotEmpty)
                Padding(
                  padding: const EdgeInsets.only(top: 8.0),
                  child: Text(_usernameChangeSuccess, style: const TextStyle(color: AppTheme.fhAccentGreen, fontSize: 12)),
                ),
              const SizedBox(height: 16),
              ElevatedButton.icon(
                icon: _usernameChangeLoading
                    ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2, color: AppTheme.fhTextPrimary))
                    : Icon(MdiIcons.contentSaveOutline, size: 18),
                label: const Text('UPDATE DISPLAY NAME'),
                onPressed: _usernameChangeLoading ? null : () => _handleChangeUsername(gameProvider),
                style: ElevatedButton.styleFrom(minimumSize: const Size(double.infinity, 44)),
              ),
            ]
          ),


          _buildSettingsSection(
            theme,
            icon: MdiIcons.brain,
            title: 'Cognitive Matrix (AI)',
            children: [
              SwitchListTile.adaptive(
                title: const Text('Dynamic Content Adaptation (Level Up)'),
                subtitle: const Text('Automatically generate new challenges and items upon leveling up.'),
                value: gameProvider.settings.autoGenerateContent,
                onChanged: (value) => gameProvider.setSettings(gameProvider.settings..autoGenerateContent = value),
                activeColor: AppTheme.fhAccentTeal,
                contentPadding: EdgeInsets.zero,
              ),
              const SizedBox(height: 12),
              Text(
                'Manually initiate content generation protocol for current operational level (${gameProvider.playerLevel}). This may consume significant resources.',
                style: theme.textTheme.bodySmall?.copyWith(color: AppTheme.fhTextSecondary),
              ),
              const SizedBox(height: 12),
              ElevatedButton.icon(
                icon: gameProvider.isGeneratingContent
                    ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2.5, color: AppTheme.fhTextPrimary))
                    : Icon(MdiIcons.creationOutline, size: 18),
                label: Text(gameProvider.isGeneratingContent ? 'PROTOCOL ACTIVE...' : 'INITIATE GENERATION'),
                onPressed: gameProvider.isGeneratingContent ? null : () => gameProvider.generateGameContent(gameProvider.playerLevel, isManual: true),
                style: ElevatedButton.styleFrom(minimumSize: const Size(double.infinity, 44)),
              ),
              if (gameProvider.isGeneratingContent)
                Padding(
                  padding: const EdgeInsets.only(top: 10.0),
                  child: Text(
                    'Cognitive matrix recalculating... please standby.',
                    style: theme.textTheme.bodySmall?.copyWith(fontStyle: FontStyle.italic, color: AppTheme.fhAccentTeal.withOpacity(0.8)),
                  ),
                ),
            ],
          ),

          _buildSettingsSection(
            theme,
            icon: MdiIcons.layersTripleOutline,
            title: 'Content Matrix Control',
            children: [
              Text(
                'Manage generated game content. These actions are specific and do not affect player progress directly, but may alter game balance or availability of items/enemies.',
                 style: theme.textTheme.bodySmall?.copyWith(color: AppTheme.fhTextSecondary, height: 1.4),
              ),
              const SizedBox(height: 16),
               ElevatedButton.icon(
                icon: Icon(MdiIcons.archiveRemoveOutline, size: 18, color: AppTheme.fhTextPrimary),
                label: const Text('CLEAR OWNED ARTIFACTS'),
                onPressed: () async {
                  final confirm = await showDialog<bool>(
                    context: context,
                    builder: (ctx) => AlertDialog(
                      title: Row(children: [Icon(MdiIcons.alertOutline, color: AppTheme.fhAccentOrange), const SizedBox(width:10),const Text('Confirm Clear Inventory')]),
                      content: const Text('This will remove ALL artifacts from your inventory (equipped items will be unequipped). Templates will remain. This action cannot be undone. Are you sure?'),
                      actionsAlignment: MainAxisAlignment.spaceBetween,
                      actions: [
                        TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('CANCEL')),
                        ElevatedButton(onPressed: () => Navigator.of(ctx).pop(true), style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fhAccentOrange), child: const Text('CONFIRM CLEAR')),
                      ],
                    ),
                  );
                  if (confirm == true) {
                    gameProvider.clearAllOwnedArtifacts();
                    if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('All owned artifacts cleared from inventory.'), backgroundColor: AppTheme.fhAccentGreen));
                  }
                },
                style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fhAccentOrange, foregroundColor: AppTheme.fhTextPrimary, minimumSize: const Size(double.infinity, 44)),
              ),
              const SizedBox(height: 12),
              ElevatedButton.icon(
                icon: Icon(MdiIcons.flaskEmptyRemoveOutline, size: 18, color: AppTheme.fhTextPrimary),
                label: const Text('PURGE POWER-UPS'),
                onPressed: () async {
                  final confirm = await showDialog<bool>(
                    context: context,
                    builder: (ctx) => AlertDialog(
                      title: Row(children: [Icon(MdiIcons.alertOutline, color: AppTheme.fhAccentOrange), const SizedBox(width:10),const Text('Confirm Purge Schematics')]),
                      content: const Text('This will remove all power-up templates that you do not currently own. This action cannot be undone. Are you sure?'),
                      actionsAlignment: MainAxisAlignment.spaceBetween,
                      actions: [
                        TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('CANCEL')),
                        ElevatedButton(
                          onPressed: () => Navigator.of(ctx).pop(true),
                          style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fhAccentOrange, foregroundColor: AppTheme.fhTextPrimary),
                          child: const Text('CONFIRM PURGE')
                        ),
                      ],
                    ),
                  );
                  if (confirm == true) {
                    gameProvider.clearDiscoverablePowerUps();
                     if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Discoverable power-up schematics purged.'), backgroundColor: AppTheme.fhAccentGreen));
                  }
                },
                style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fhAccentOrange, foregroundColor: AppTheme.fhTextPrimary, minimumSize: const Size(double.infinity, 44)),
              ),
              const SizedBox(height: 12),
              ElevatedButton.icon(
                icon: Icon(MdiIcons.skullCrossbonesOutline, size: 18, color: AppTheme.fhTextPrimary),
                label: const Text('DECOMMISSION ENEMIES'),
                onPressed: () async {
                  final confirm = await showDialog<bool>(
                    context: context,
                    builder: (ctx) => AlertDialog(
                       title: Row(children: [Icon(MdiIcons.alertOutline, color: AppTheme.fhAccentOrange), const SizedBox(width:10),const Text('Confirm Decommission')]),
                      content: const Text('This removes all enemy templates. The Arena might be empty until new content is generated. This action cannot be undone. Are you sure?'),
                      actionsAlignment: MainAxisAlignment.spaceBetween,
                       actions: [
                        TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('CANCEL')),
                        ElevatedButton(
                          onPressed: () => Navigator.of(ctx).pop(true),
                          style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fhAccentOrange, foregroundColor: AppTheme.fhTextPrimary),
                          child: const Text('CONFIRM DECOMMISSION')
                        ),
                      ],
                    ),
                  );
                  if (confirm == true) {
                    gameProvider.removeAllEnemyTemplates();
                    if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('All enemy signatures decommissioned.'), backgroundColor: AppTheme.fhAccentGreen));
                  }
                },
                 style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fhAccentOrange, foregroundColor: AppTheme.fhTextPrimary, minimumSize: const Size(double.infinity, 44)),
              ),
            ]
          ),


          _buildSettingsSection(
            theme,
            icon: MdiIcons.eyeSettingsOutline,
            title: 'User Interface Config',
            children: [
               SwitchListTile.adaptive(
                title: const Text('Verbose Data Display'),
                subtitle: const Text('Show detailed descriptions for stats and items throughout the interface.'),
                value: gameProvider.settings.descriptionsVisible,
                onChanged: (value) => gameProvider.setSettings(gameProvider.settings..descriptionsVisible = value),
                activeColor: AppTheme.fhAccentTeal,
                contentPadding: EdgeInsets.zero,
              ),
            ]
          ),

          if (gameProvider.currentUser != null)
            _buildSettingsSection(
              theme,
              icon: MdiIcons.shieldAccountOutline,
              title: 'Access Credentials',
              children: [
                TextFormField(
                  controller: _newPasswordController,
                  decoration: InputDecoration(labelText: 'New Passcode Sequence', prefixIcon: Icon(MdiIcons.formTextboxPassword, size: 20)),
                  obscureText: true,
                ),
                const SizedBox(height: 12),
                TextFormField(
                  controller: _confirmPasswordController,
                  decoration: InputDecoration(labelText: 'Confirm Passcode Sequence', prefixIcon: Icon(MdiIcons.formTextboxPassword, size: 20)),
                  obscureText: true,
                ),
                if (_passwordChangeError.isNotEmpty)
                  Padding(
                    padding: const EdgeInsets.only(top: 10.0),
                    child: Text(_passwordChangeError, style: const TextStyle(color: AppTheme.fhAccentRed, fontSize: 12)),
                  ),
                if (_passwordChangeSuccess.isNotEmpty)
                   Padding(
                    padding: const EdgeInsets.only(top: 10.0),
                    child: Text(_passwordChangeSuccess, style: const TextStyle(color: AppTheme.fhAccentGreen, fontSize: 12)),
                  ),
                const SizedBox(height: 16),
                ElevatedButton.icon(
                  icon: _passwordChangeLoading
                      ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2.5, color: AppTheme.fhTextPrimary))
                      : Icon(MdiIcons.keyChange, size: 18),
                  label: const Text('UPDATE PASSCODE'),
                  onPressed: _passwordChangeLoading ? null : () => _handleChangePassword(gameProvider),
                  style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fhAccentTeal, foregroundColor: AppTheme.fhBgDark, minimumSize: const Size(double.infinity, 44)),
                ),
                const SizedBox(height: 20),
                OutlinedButton.icon(
                    icon: _logoutLoading
                        ? const SizedBox(width: 18, height: 18, child: CircularProgressIndicator(strokeWidth: 2.5, color: AppTheme.fhAccentOrange))
                        : Icon(MdiIcons.logoutVariant, size: 18),
                    label: const Text('TERMINATE SESSION'),
                    onPressed: _logoutLoading ? null : () => _handleLogout(gameProvider, context),
                    style: OutlinedButton.styleFrom(foregroundColor: AppTheme.fhAccentOrange, side: const BorderSide(color: AppTheme.fhAccentOrange, width: 1.5), minimumSize: const Size(double.infinity, 44)),
                ),
              ]
            ),

          _buildSettingsSection(
            theme,
            icon: MdiIcons.databaseRemoveOutline,
            title: 'Data & System Reset',
            children: [
                ElevatedButton.icon(
                    icon: Icon(MdiIcons.undoVariant, size: 18),
                    label: const Text('RESET PLAYER LEVEL'),
                    onPressed: () async {
                        final confirm = await showDialog<bool>(
                            context: context,
                            builder: (ctx) => AlertDialog(
                                title: Row(children: [Icon(MdiIcons.alertOutline, color: AppTheme.fhAccentOrange), const SizedBox(width:10), const Text('Confirm Level Reset')]),
                                content: const Text('This will reset your player level to 1, XP to 0, and clear defeated enemies for the current level. Your tasks, items, and coins will remain. Are you sure?'),
                                actionsAlignment: MainAxisAlignment.spaceBetween,
                                actions: [
                                    TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('CANCEL')),
                                    ElevatedButton(onPressed: () => Navigator.of(ctx).pop(true), style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fhAccentOrange), child: const Text('CONFIRM RESET')),
                                ],
                            ),
                        );
                        if (confirm == true) {
                            gameProvider.resetPlayerLevelAndProgress();
                            if(mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Player level and progress reset.'), backgroundColor: AppTheme.fhAccentGreen));
                        }
                    },
                    style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fhAccentOrange, foregroundColor: AppTheme.fhTextPrimary, minimumSize: const Size(double.infinity, 44)),
              ),
              const SizedBox(height: 16),
              Text(
                'WARNING: The "Purge All Data" protocol will erase all operational data, including quest logs, experience, currency, and acquired assets. This action is irreversible and will reset the system to factory defaults.',
                 style: theme.textTheme.bodySmall?.copyWith(color: AppTheme.fhTextSecondary, height: 1.5),
              ),
              const SizedBox(height: 16),
              ElevatedButton.icon(
                icon: Icon(MdiIcons.alertOctagonOutline, size: 18),
                label: const Text('PURGE ALL DATA'),
                onPressed: () async {
                  final confirm = await showDialog<bool>(
                    context: context,
                    builder: (ctx) => AlertDialog(
                      title: Row(children: [Icon(MdiIcons.alertOutline, color: AppTheme.fhAccentRed), const SizedBox(width:10),const Text('Confirm System Purge', style: TextStyle(color: AppTheme.fhAccentRed))]),
                      content: const Text('Are you absolutely certain you wish to erase all data? This operation cannot be undone and will result in total loss of progress.'),
                      actionsAlignment: MainAxisAlignment.spaceBetween,
                      actions: [
                        TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('CANCEL')),
                        ElevatedButton(
                          onPressed: () => Navigator.of(ctx).pop(true),
                          style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fhAccentRed, foregroundColor: AppTheme.fhTextPrimary),
                          child: const Text('CONFIRM PURGE')
                        ),
                      ],
                    ),
                  );
                  if (confirm == true) {
                    gameProvider.clearAllGameData();
                    if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('All game data has been purged.'), backgroundColor: AppTheme.fhAccentGreen));
                  }
                },
                style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fhAccentRed, foregroundColor: AppTheme.fhTextPrimary, minimumSize: const Size(double.infinity, 44)),
              ),
            ]
          ),
        ],
      ),
    );
  }

  Widget _buildSettingsSection(ThemeData theme, {required IconData icon, required String title, required List<Widget> children}) {
    return Card( // Using the globally themed Card
      margin: const EdgeInsets.only(bottom: 24),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(icon, color: AppTheme.fhAccentTeal, size: 22),
                const SizedBox(width: 10),
                Text(title, style: theme.textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.w600)),
              ],
            ),
            Divider(height: 24, thickness: 0.5, color: AppTheme.fhBorderColor.withOpacity(0.5)),
            ...children,
          ],
        ),
      ),
    );
  }
}
--- END OF FILE lib/src/widgets/views/settings_view.dart ---

--- START OF FILE lib/src/widgets/views/blacksmith_view.dart ---
// lib/src/widgets/views/blacksmith_view.dart
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:myapp_flutter/src/models/game_models.dart';
import 'package:myapp_flutter/src/utils/constants.dart';
import 'package:myapp_flutter/src/utils/helpers.dart' as helper;
import 'package:myapp_flutter/src/widgets/ui/artifact_card.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class BlacksmithView extends StatelessWidget {
  const BlacksmithView({super.key});

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    final Color dynamicAccent = gameProvider.getSelectedTask()?.taskColor ?? theme.colorScheme.secondary;
    final Color buttonTextColor = ThemeData.estimateBrightnessForColor(dynamicAccent) == Brightness.dark ? AppTheme.fhTextPrimary : AppTheme.fhBgDark;


    final upgradableArtifacts = gameProvider.artifacts.where((art) {
      final template = gameProvider.artifactTemplatesList.firstWhere(
          (t) => t.id == art.templateId,
          orElse: () => ArtifactTemplate(
              id: '', name: '', type: '', description: '', cost: 0, icon: ''));
      return template.id.isNotEmpty; 
    }).toList();

    if (upgradableArtifacts.isEmpty) {
      return Center(
          child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(MdiIcons.hammerSickle, size: 48, color: dynamicAccent),
            const SizedBox(height: 16),
            Text("Hephaestus' Forge",
                style: theme.textTheme.headlineSmall?.copyWith(
                    fontFamily: AppTheme.fontDisplay, 
                    color: AppTheme.fhTextPrimary)), // Use primary text color for title
            const SizedBox(height: 8),
            Text(
              "Your satchel is empty, warrior. Acquire some artifacts to enhance or sell!",
              textAlign: TextAlign.center,
              style: theme.textTheme.bodyMedium
                  ?.copyWith(color: AppTheme.fhTextSecondary),
            ),
          ],
        ),
      ));
    }

    int getUpgradeCost(ArtifactTemplate template, int currentLevel) {
      if (template.type == 'powerup' ||
          template.maxLevel == null ||
          currentLevel >= template.maxLevel!) {
        return 9999999; // effectively infinity
      }
      return (template.cost *
              blacksmithUpgradeCostMultiplier *
              helper.xpLevelMultiplierPow(1.2, currentLevel - 1)) // Keep 1.2 for blacksmith logic
          .floor();
    }

    int getSellPrice(ArtifactTemplate template, OwnedArtifact ownedArtifact) {
      double sellMultiplier = 1.0;
      if (template.type == 'powerup' &&
          template.uses != null &&
          template.uses! > 0 &&
          ownedArtifact.uses != null) {
        sellMultiplier = (ownedArtifact.uses! / template.uses!);
      }
      return (template.cost * artifactSellPercentage * sellMultiplier).floor();
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.only(bottom: 16, right: 4, left: 4), // Added left padding
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 16.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(MdiIcons.hammerWrench,
                    color: dynamicAccent, size: 32),
                const SizedBox(width: 12),
                Text(
                  "Hephaestus' Forge",
                  style: theme.textTheme.headlineSmall?.copyWith(
                      fontFamily: AppTheme.fontDisplay, 
                      color: AppTheme.fhTextPrimary), // Use primary text color for title
                ),
              ],
            ),
          ),
          LayoutBuilder(builder: (context, constraints) {
            int crossAxisCount = 2;
            if (constraints.maxWidth > 900) {
              crossAxisCount = 4; // Adjusted breakpoints
            } else if (constraints.maxWidth > 600) crossAxisCount = 3;
            else if (constraints.maxWidth < 400) crossAxisCount = 1;

            double itemWidth = (constraints.maxWidth - (crossAxisCount +1) * 10) / crossAxisCount; // 10 for padding
            double childAspectRatio = itemWidth / 280; // Adjusted for potentially taller cards with more actions

            return GridView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              padding: const EdgeInsets.all(10.0),
              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: crossAxisCount,
                crossAxisSpacing: 10.0,
                mainAxisSpacing: 10.0,
                childAspectRatio: childAspectRatio.clamp(0.6, 0.85), // Adjusted clamp
              ),
              itemCount: upgradableArtifacts.length,
              itemBuilder: (context, index) {
                final ownedArt = upgradableArtifacts[index];
                final template = gameProvider.artifactTemplatesList.firstWhere(
                    (t) => t.id == ownedArt.templateId,
                    orElse: () => ArtifactTemplate(
                        id: '', name: '', type: '', description: '', cost: 0, icon: ''));
                if (template.id == '') return const SizedBox.shrink();

                final upgradeCost = getUpgradeCost(template, ownedArt.currentLevel);
                final sellPrice = getSellPrice(template, ownedArt);
                final bool canUpgrade = template.type != 'powerup' &&
                    template.maxLevel != null &&
                    ownedArt.currentLevel < template.maxLevel!;
                final bool canAffordUpgrade = gameProvider.coins >= upgradeCost;

                return ArtifactCardWidget(
                  template: template,
                  ownedArtifact: ownedArt,
                  actionSection: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      if (template.type != 'powerup')
                         Padding(
                           padding: const EdgeInsets.only(bottom: 6.0, top: 4.0),
                           child: Center( // Center the sell price
                             child: Text(
                               'Sell Value: $sellPrice Ø',
                               style: theme.textTheme.labelSmall?.copyWith(color: AppTheme.fhTextSecondary.withOpacity(0.8), fontSize: 10),
                             ),
                           ),
                         ),
                      Row(
                        children: [
                          if (template.type != 'powerup' && template.maxLevel != null) Expanded(
                            child: ElevatedButton.icon(
                              icon: Icon(canUpgrade ? MdiIcons.arrowUpBoldCircleOutline : MdiIcons.checkCircleOutline, size: 14),
                              label: Text(canUpgrade
                                    ? (canAffordUpgrade
                                        ? 'UPGRADE ($upgradeCost Ø)'
                                        : '$upgradeCost Ø')
                                    : 'MAX LEVEL', style: TextStyle(fontSize: 10)),
                              onPressed: (canUpgrade && canAffordUpgrade)
                                  ? () => gameProvider.upgradeArtifact(ownedArt.uniqueId)
                                  : null,
                              style: ElevatedButton.styleFrom(
                                backgroundColor: dynamicAccent,
                                foregroundColor: buttonTextColor,
                                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 6), // Adjusted padding
                                textStyle: const TextStyle(
                                    fontFamily: AppTheme.fontBody, 
                                    fontWeight: FontWeight.bold),
                                disabledBackgroundColor: AppTheme.fhBgDark.withOpacity(0.5),
                                disabledForegroundColor: AppTheme.fhTextSecondary.withOpacity(0.5),
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4))
                              ),
                            ),
                          ),
                          if (template.type != 'powerup' && template.maxLevel != null) const SizedBox(width: 6.0), // Gap
                          if (template.type != 'powerup') Expanded(
                            child: OutlinedButton.icon(
                              icon: Icon(MdiIcons.cashMinus, size: 14),
                              label: const Text('SELL', style: TextStyle(fontSize: 10)),
                              onPressed: () => gameProvider.sellArtifact(ownedArt.uniqueId),
                              style: OutlinedButton.styleFrom(
                                foregroundColor: AppTheme.fhAccentOrange,
                                side: const BorderSide(color: AppTheme.fhAccentOrange, width: 1), // Thicker border
                                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 6), // Adjusted padding
                                textStyle: const TextStyle(
                                    fontFamily: AppTheme.fontBody, 
                                    fontWeight: FontWeight.bold),
                                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4))
                              ),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                );
              },
            );
          }),
        ],
      ),
    );
  }
}
--- END OF FILE lib/src/widgets/views/blacksmith_view.dart ---

--- START OF FILE lib/src/widgets/views/artifact_shop_view.dart ---
// lib/src/widgets/views/artifact_shop_view.dart
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:myapp_flutter/src/widgets/ui/artifact_card.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class ArtifactShopView extends StatelessWidget {
  const ArtifactShopView({super.key});

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    final currentTask = gameProvider.getSelectedTask();
    final String? currentTaskTheme = currentTask?.theme;
    final Color dynamicAccent = currentTask?.taskColor ?? theme.colorScheme.secondary;
    final Color buttonTextColor = ThemeData.estimateBrightnessForColor(dynamicAccent) == Brightness.dark ? AppTheme.fhTextPrimary : AppTheme.fhBgDark;


    final itemsToShow = gameProvider.artifactTemplatesList.where((template) {
      final bool themeMatch = currentTaskTheme == null ||
          template.theme == null ||
          template.theme == currentTaskTheme ||
          template.theme == 'general'; // Added general theme
      return !template.type.contains("powerup_dev") && themeMatch;
    }).toList()
      ..sort((a, b) {
        if (currentTaskTheme != null) {
          final bool aIsThemed = a.theme == currentTaskTheme;
          final bool bIsThemed = b.theme == currentTaskTheme;
          if (aIsThemed && !bIsThemed) return -1;
          if (!aIsThemed && bIsThemed) return 1;
        }
        if (a.cost != b.cost) return a.cost.compareTo(b.cost);
        return a.name.compareTo(b.name);
      });

    return SingleChildScrollView(
      padding: const EdgeInsets.only(bottom: 16, right: 4, left: 4), // Added left padding
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 16.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(MdiIcons.storefrontOutline,
                    color: dynamicAccent, size: 32),
                const SizedBox(width: 12),
                Text(
                  "Brok & Sindri's Wares",
                  style: theme.textTheme.headlineSmall?.copyWith(
                      fontFamily: AppTheme.fontDisplay, 
                      color: AppTheme.fhTextPrimary), // Primary text color for title
                ),
              ],
            ),
          ),
          if (itemsToShow.isEmpty)
            Padding(
              padding: const EdgeInsets.all(24.0),
              child: Text(
                "No wares currently matching your quest's focus. Perhaps try a different quest or generate more content via Settings?",
                textAlign: TextAlign.center,
                style: theme.textTheme.bodyMedium
                    ?.copyWith(color: AppTheme.fhTextSecondary),
              ),
            )
          else
            LayoutBuilder(builder: (context, constraints) {
              int crossAxisCount = 2;
              if (constraints.maxWidth > 900) {
                crossAxisCount = 4; // Adjusted breakpoints
              } else if (constraints.maxWidth > 600) crossAxisCount = 3;
              else if (constraints.maxWidth < 400) crossAxisCount = 1;


              double itemWidth = (constraints.maxWidth - (crossAxisCount +1) * 10) / crossAxisCount; // 10 for padding
              double childAspectRatio = itemWidth / 270; // Adjusted height for better card display

              return GridView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                padding: const EdgeInsets.all(10.0), 
                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: crossAxisCount,
                  crossAxisSpacing: 10.0,
                  mainAxisSpacing: 10.0,
                  childAspectRatio: childAspectRatio.clamp(0.65, 0.9), // Adjusted clamp
                ),
                itemCount: itemsToShow.length,
                itemBuilder: (context, index) {
                  final template = itemsToShow[index];
                  final bool canAfford = gameProvider.coins >= template.cost;
                  final bool isOwned = template.type != 'powerup' &&
                      gameProvider.artifacts
                          .any((art) => art.templateId == template.id);
                  
                  return ArtifactCardWidget(
                    template: template,
                    cost: template.cost,
                    actionSection: SizedBox(
                      width: double.infinity, 
                      child: ElevatedButton.icon(
                        icon: Icon(isOwned ? MdiIcons.checkCircleOutline : (canAfford ? MdiIcons.cartPlus : MdiIcons.cartOff), size:16),
                        label: Text(isOwned
                            ? 'ACQUIRED'
                            : (canAfford
                                ? '${template.cost} Ø'
                                : 'Cost: ${template.cost} Ø')),
                        onPressed: (!canAfford || isOwned)
                            ? null
                            : () => gameProvider.buyArtifact(template.id),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: isOwned ? AppTheme.fhBgDark.withOpacity(0.6) : (canAfford ? dynamicAccent : AppTheme.fhAccentRed.withOpacity(0.7)),
                          foregroundColor: isOwned ? AppTheme.fhTextSecondary.withOpacity(0.7) : (canAfford ? buttonTextColor : AppTheme.fhTextPrimary),
                          padding: const EdgeInsets.symmetric(
                              horizontal: 12, vertical: 8), // Adjusted padding
                          textStyle: const TextStyle(
                              fontSize: 11,
                              fontFamily: AppTheme.fontBody, 
                              fontWeight: FontWeight.bold),
                          disabledBackgroundColor:
                              AppTheme.fhBgDark.withOpacity(0.5),
                          disabledForegroundColor:
                              AppTheme.fhTextSecondary.withOpacity(0.5),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4))
                        ),
                      ),
                    ), 
                  );
                },
              );
            }),
        ],
      ),
    );
  }
}
--- END OF FILE lib/src/widgets/views/artifact_shop_view.dart ---

--- START OF FILE lib/src/widgets/views/daily_summary_view.dart ---
// lib/src/widgets/views/daily_summary_view.dart
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:myapp_flutter/src/models/game_models.dart';
import 'package:provider/provider.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:intl/intl.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class DailySummaryView extends StatefulWidget {
  const DailySummaryView({super.key});

  @override
  State<DailySummaryView> createState() => _DailySummaryViewState();
}

class _DailySummaryViewState extends State<DailySummaryView> {
  String? _selectedDate;
  int _touchedPieIndex = -1;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    final availableDates = gameProvider.completedByDay.keys.toList();
    availableDates.sort((a, b) => b.compareTo(a)); 
    if (_selectedDate == null && availableDates.isNotEmpty) {
      _selectedDate = availableDates.first;
    }
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);

    final availableDates = gameProvider.completedByDay.keys.toList();
    availableDates.sort((a, b) => b.compareTo(a)); 

    if (_selectedDate == null && availableDates.isNotEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) setState(() => _selectedDate = availableDates.first);
      });
    } else if (_selectedDate != null && !availableDates.contains(_selectedDate) && availableDates.isNotEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) setState(() => _selectedDate = availableDates.first);
      });
    } else if (availableDates.isEmpty && _selectedDate != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) setState(() => _selectedDate = null);
      });
    }

    final summaryData = _selectedDate != null ? gameProvider.completedByDay[_selectedDate!] : null;
    final taskTimes = summaryData?['taskTimes'] as Map<String, dynamic>? ?? {};
    final subtasksCompleted = summaryData?['subtasksCompleted'] as List<dynamic>? ?? [];
    final checkpointsCompleted = summaryData?['checkpointsCompleted'] as List<dynamic>? ?? [];

    final double totalMinutesToday = taskTimes.values.fold(0.0, (sum, time) => sum + (time as num).toDouble());

    final List<PieChartSectionData> pieChartSections = [];
    final List<Widget> legendItems = [];
    if (taskTimes.isNotEmpty) {
      // int colorIndex = 0; // Removed unused variable
      taskTimes.forEach((taskId, time) {
        final task = gameProvider.mainTasks.firstWhere((t) => t.id == taskId, orElse: () => MainTask(id:'', name:'Unknown Quest', description:'', theme:'', colorHex: AppTheme.fhTextDisabled.value.toRadixString(16).substring(2)));
        final taskColor = task.taskColor; // Uses getter from MainTask model

        if (task.id != '') {
          final isTouched = pieChartSections.length == _touchedPieIndex;
          final fontSize = isTouched ? 13.0 : 11.0;
          final radius = isTouched ? 65.0 : 55.0; // Slightly larger pie
          final titlePercentage = totalMinutesToday > 0 ? ((time as num).toDouble() / totalMinutesToday * 100) : 0.0;

          pieChartSections.add(PieChartSectionData(
            color: taskColor, // Use task's theme color
            value: (time).toDouble(),
            title: '${titlePercentage.toStringAsFixed(0)}%',
            radius: radius,
            titleStyle: TextStyle(fontSize: fontSize, fontWeight: FontWeight.bold, color: AppTheme.fhBgDark, fontFamily: AppTheme.fontDisplay, shadows: const [Shadow(color: Colors.black38, blurRadius: 2)]),
            titlePositionPercentageOffset: 0.6,
          ));
          legendItems.add(
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 3.0),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(width: 12, height: 12,
                   decoration: BoxDecoration(
                       color: taskColor,
                       border: Border.all(color: AppTheme.fhBorderColor.withOpacity(0.5), width: 0.5)
                   )),
                  const SizedBox(width: 8),
                  Text(task.name.split(' ')[0], style: TextStyle(fontSize: 12, color: AppTheme.fhTextSecondary, fontFamily: AppTheme.fontBody)),
                ],
              ),
            )
          );
          // colorIndex++; // Removed unused increment
        }
      });
    }

    final List<BarChartGroupData> weeklyBarGroups = [];
    final today = DateTime.now();
    final List<String> last7DaysFormatted = [];
    for (int i = 6; i >= 0; i--) {
        final d = today.subtract(Duration(days: i));
        final dateStr = DateFormat('yyyy-MM-dd').format(d);
        final dayData = gameProvider.completedByDay[dateStr];
        final Map<String, dynamic> dailyTaskTimes = dayData != null && dayData['taskTimes'] != null
            ? dayData['taskTimes'] as Map<String, dynamic>
            : {};
        
        double dailyTotalMins = 0;
        String? dominantTaskId;
        int maxTime = 0;

        dailyTaskTimes.forEach((taskId, time) {
            final int currentTime = (time as num).toInt();
            dailyTotalMins += currentTime;
            if (currentTime > maxTime) {
                maxTime = currentTime;
                dominantTaskId = taskId;
            }
        });
        
        Color barColor = AppTheme.fhAccentTeal; // Default bar color
        if (dominantTaskId != null) {
            final dominantTask = gameProvider.mainTasks.firstWhere((t) => t.id == dominantTaskId, orElse: () => MainTask(id:'', name:'', description:'', theme:'', colorHex: AppTheme.fhAccentTeal.value.toRadixString(16).substring(2)));
            barColor = dominantTask.taskColor;
        }

        weeklyBarGroups.add(
            BarChartGroupData(
                x: 6 - i, 
                barRods: [
                    BarChartRodData(
                        toY: dailyTotalMins,
                        color: barColor.withOpacity(0.85),
                        width: 18, // Wider bars
                        borderRadius: const BorderRadius.only(topLeft: Radius.circular(3), topRight: Radius.circular(3))
                    )
                ],
            )
        );
        last7DaysFormatted.add(DateFormat('EEE, MMM d').format(d));
    }


    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(bottom: 24.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(MdiIcons.bookOpenVariant, color: AppTheme.fhAccentRed, size: 36), // Use primary accent
                const SizedBox(width: 12),
                Text("Mission Logbook", style: theme.textTheme.displaySmall?.copyWith(color: AppTheme.fhTextPrimary)),
              ],
            ),
          ),

          if (availableDates.isEmpty)
            Center(child: Padding(
              padding: const EdgeInsets.symmetric(vertical: 32.0),
              child: Text("No mission logs recorded yet.", style: theme.textTheme.bodyLarge?.copyWith(color: AppTheme.fhTextSecondary, fontStyle: FontStyle.italic)),
            ))
          else ...[
            DropdownButtonFormField<String>(
              value: _selectedDate,
              decoration: const InputDecoration(labelText: 'Select Date'),
              dropdownColor: AppTheme.fhBgMedium, // Darker dropdown
              items: availableDates.map((date) {
                return DropdownMenuItem(
                  value: date,
                  child: Text(DateFormat('MMMM d, yyyy (EEEE)').format(DateTime.parse(date))),
                );
              }).toList(),
              onChanged: (value) => setState(() => _selectedDate = value),
            ),
            const SizedBox(height: 24),
            if (_selectedDate != null)
              Card(
                color: AppTheme.fhBgMedium,
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Text(
                    'Total Time Logged on ${DateFormat('MMMM d, yyyy').format(DateTime.parse(_selectedDate!))}: ${totalMinutesToday.toStringAsFixed(0)}m',
                    style: theme.textTheme.titleLarge?.copyWith(color: AppTheme.fhAccentGreen, fontWeight: FontWeight.bold),
                  ),
                ),
              ),
            const SizedBox(height: 24),

            if (pieChartSections.isNotEmpty) ...[
              Text("Time Distribution by Mission:", style: theme.textTheme.headlineSmall),
              const SizedBox(height: 16),
              Row(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  Expanded(
                    flex: 3, // Give more space to pie chart
                    child: SizedBox(
                      height: 220, // Larger pie chart
                      child: PieChart(
                        PieChartData(
                          pieTouchData: PieTouchData(
                            touchCallback: (FlTouchEvent event, pieTouchResponse) {
                              setState(() {
                                if (!event.isInterestedForInteractions || pieTouchResponse == null || pieTouchResponse.touchedSection == null) {
                                  _touchedPieIndex = -1; return;
                                }
                                _touchedPieIndex = pieTouchResponse.touchedSection!.touchedSectionIndex;
                              });
                            },
                          ),
                          borderData: FlBorderData(show: false),
                          sectionsSpace: 2, // Space between sections
                          centerSpaceRadius: 50, // Larger center space
                          sections: pieChartSections,
                        ),
                      ),
                    ),
                  ),
                  if (legendItems.isNotEmpty)
                    Expanded(
                      flex: 2, // More space for legend
                      child: Padding(
                        padding: const EdgeInsets.only(left: 20.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: legendItems,
                        ),
                      )
                    )
                ],
              ),
              const SizedBox(height: 30),
            ],

            Text("Last 7 Days Activity (Total Minutes):", style: theme.textTheme.headlineSmall),
            const SizedBox(height: 20),
            SizedBox(
                height: 280, // Taller bar chart
                child: BarChart(
                    BarChartData(
                        alignment: BarChartAlignment.spaceAround,
                        maxY: weeklyBarGroups.map((g) => g.barRods.first.toY).reduce((a,b) => a > b ? a : b) * 1.2 + 15, 
                        barTouchData: BarTouchData(
                            touchTooltipData: BarTouchTooltipData(
                                getTooltipColor: (BarChartGroupData group) => AppTheme.fhBgMedium,
                                getTooltipItem: (group, groupIndex, rod, rodIndex) {
                                    return BarTooltipItem(
                                        '${last7DaysFormatted[group.x]}\n',
                                        TextStyle(color: AppTheme.fhTextPrimary, fontWeight: FontWeight.bold, fontFamily: AppTheme.fontDisplay),
                                        children: <TextSpan>[
                                            TextSpan(
                                                text: '${rod.toY.toStringAsFixed(0)} min',
                                                style: TextStyle(color: rod.color ?? AppTheme.fhAccentTeal, fontWeight: FontWeight.w500, fontFamily: AppTheme.fontBody),
                                            ),
                                        ],
                                    );
                                },
                            ),
                        ),
                        titlesData: FlTitlesData(
                            show: true,
                            rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                            topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
                            bottomTitles: AxisTitles(
                                sideTitles: SideTitles(
                                    showTitles: true,
                                    getTitlesWidget: (double value, TitleMeta meta) {
                                        return SideTitleWidget(
                                            meta: meta,
                                            space: 10.0, // More space for titles
                                            child: Text(last7DaysFormatted[value.toInt()].substring(0,3).toUpperCase(), style: TextStyle(color: AppTheme.fhTextSecondary, fontWeight: FontWeight.bold, fontSize: 11, fontFamily: AppTheme.fontDisplay)),
                                        );
                                    },
                                    reservedSize: 38, // Increased reserved size
                                ),
                            ),
                            leftTitles: AxisTitles(
                                sideTitles: SideTitles(
                                    showTitles: true,
                                    reservedSize: 45, // Increased reserved size
                                    getTitlesWidget: (double value, TitleMeta meta) {
                                        if (value == meta.max || (value == 0 && meta.max > 20)) {
                                          return SideTitleWidget(meta: meta, child: Container());
                                        }
                                        return SideTitleWidget(meta: meta, child: Text('${value.toInt()}', style: TextStyle(color: AppTheme.fhTextSecondary, fontSize: 11, fontFamily: AppTheme.fontBody)));
                                    }
                                ),
                            ),
                        ),
                        borderData: FlBorderData(show: true, border: Border.all(color: AppTheme.fhBorderColor.withOpacity(0.2), width:1)),
                        barGroups: weeklyBarGroups,
                        gridData: FlGridData(
                            show: true,
                            drawVerticalLine: true, // Show vertical grid lines
                            verticalInterval: 1,
                            horizontalInterval: (weeklyBarGroups.map((g) => g.barRods.first.toY).reduce((a,b) => a > b ? a : b) / 5).clamp(10, 1000), // Dynamic horizontal interval
                            getDrawingHorizontalLine: (value) => FlLine(color: AppTheme.fhBorderColor.withOpacity(0.1), strokeWidth: 0.8),
                            getDrawingVerticalLine: (value) => FlLine(color: AppTheme.fhBorderColor.withOpacity(0.1), strokeWidth: 0.8),
                        ),
                    ),
                ),
            ),
            const SizedBox(height: 30),

            if (_selectedDate != null) ... [
              Text('Activity Details for ${DateFormat('MMMM d').format(DateTime.parse(_selectedDate!))}:', style: theme.textTheme.headlineSmall),
              const SizedBox(height: 12),
              Card(
                color: AppTheme.fhBgMedium,
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      if (taskTimes.isEmpty && subtasksCompleted.isEmpty && checkpointsCompleted.isEmpty)
                        Text("No specific activity recorded for this day.", style: theme.textTheme.bodyMedium?.copyWith(color: AppTheme.fhTextSecondary, fontStyle: FontStyle.italic))
                      else ...[
                        ...taskTimes.entries.map((entry) {
                          final task = gameProvider.mainTasks.firstWhere((t) => t.id == entry.key, orElse: () => MainTask(id:'', name:'Unknown Task', description:'', theme:'', colorHex: AppTheme.fhTextDisabled.value.toRadixString(16).substring(2)));
                          return Padding(
                            padding: const EdgeInsets.symmetric(vertical: 3.0),
                            child: Text('${task.name}: ${entry.value}m', style: theme.textTheme.bodyMedium?.copyWith(color: task.taskColor)),
                          );
                        }),
                        if (subtasksCompleted.isNotEmpty) ...[
                          const SizedBox(height: 10),
                          Text('Sub-Missions Completed:', style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
                          ...subtasksCompleted.map((subEntryMap) {
                              final subEntry = subEntryMap as Map<String, dynamic>;
                              final parentTask = gameProvider.mainTasks.firstWhere((t) => t.id == subEntry['parentTaskId'], orElse: () => MainTask(id:'', name:'Unknown Task', description:'', theme:''));
                              return Padding(
                               padding: const EdgeInsets.only(left: 16.0, top: 3.0),
                               child: Text(
                                 '- ${subEntry['name']} (for ${parentTask.name}) - Logged: ${subEntry['timeLogged']}m, Count: ${subEntry['currentCount']}/${subEntry['targetCount']}',
                                 style: theme.textTheme.bodySmall?.copyWith(color: AppTheme.fhTextSecondary),
                               ),
                             );
                          }),
                        ],
                        if (checkpointsCompleted.isNotEmpty) ...[
                          const SizedBox(height: 10),
                           Text('Checkpoints Completed:', style: theme.textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold)),
                          ...checkpointsCompleted.map((cpEntryMap) {
                              final cpEntry = cpEntryMap as Map<String, dynamic>;
                              final String mainTaskName = cpEntry['mainTaskName'] as String? ?? 'N/A';
                              final String parentSubtaskName = cpEntry['parentSubtaskName'] as String? ?? 'N/A';
                              final String countableInfo = (cpEntry['isCountable'] as bool? ?? false)
                                ? " (${cpEntry['currentCount']}/${cpEntry['targetCount']})"
                                : "";
                              return Padding(
                               padding: const EdgeInsets.only(left: 16.0, top: 3.0),
                               child: Text(
                                 '- ${cpEntry['name']}$countableInfo (Sub-Mission: "$parentSubtaskName" in "$mainTaskName")',
                                 style: theme.textTheme.bodySmall?.copyWith(color: AppTheme.fhAccentTeal.withOpacity(0.85)),
                               ),
                             );
                          }),
                        ]
                      ],
                    ],
                  ),
                ),
              ),
            ],
          ],
        ],
      ),
    );
  }
}
--- END OF FILE lib/src/widgets/views/daily_summary_view.dart ---

--- START OF FILE lib/src/widgets/views/game_view.dart ---
// lib/src/widgets/views/game_view.dart
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:myapp_flutter/src/models/game_models.dart';
import 'package:myapp_flutter/src/utils/constants.dart';
import 'package:myapp_flutter/src/widgets/ui/enemy_info_card.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:collection/collection.dart';


class GameView extends StatefulWidget {
  const GameView({super.key});

  @override
  State<GameView> createState() => _GameViewState();
}

class _GameViewState extends State<GameView> {
  String? _selectedLocationId; 

  @override
  void initState() {
    super.initState();
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    print("[GameView] initState called.");

    final availableLocations = gameProvider.gameLocationsList.where((loc) => gameProvider.isLocationUnlocked(loc.id)).toList();
    print("[GameView] Available unlocked locations: ${availableLocations.map((l) => l.name).join(', ')}");


    _selectedLocationId = gameProvider.currentGame.currentPlaceKey;

    if (_selectedLocationId == null || !gameProvider.isLocationUnlocked(_selectedLocationId!)) {
        if (availableLocations.isNotEmpty) {
            _selectedLocationId = availableLocations.first.id;
            print("[GameView] Defaulting selectedLocationId to first available: $_selectedLocationId");
        } else if (gameProvider.gameLocationsList.isNotEmpty) {
            _selectedLocationId = gameProvider.gameLocationsList.first.id;
             print("[GameView] No unlocked locations, defaulting selectedLocationId to absolute first: $_selectedLocationId");
        } else {
            _selectedLocationId = null; 
            print("[GameView] No locations available at all.");
        }
    }


    if(_selectedLocationId != null && gameProvider.currentGame.currentPlaceKey != _selectedLocationId) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          print("[GameView] Updating provider with selectedLocationId: $_selectedLocationId");
          gameProvider.setProviderState(
            currentGame: CurrentGame(
              enemy: gameProvider.currentGame.enemy, 
              playerCurrentHp: gameProvider.currentGame.playerCurrentHp,
              log: gameProvider.currentGame.log,
              currentPlaceKey: _selectedLocationId,
            ),
            doPersist: false 
          );
        }
      });
    }
     print("[GameView] Final _selectedLocationId in initState: $_selectedLocationId");
  }


  Widget _renderCharacterStats(BuildContext context, dynamic character, bool isPlayer, GameProvider gameProvider) {
    final theme = Theme.of(context);
    final Color dynamicAccent = gameProvider.getSelectedTask()?.taskColor ?? theme.colorScheme.secondary;
    final double maxHp = isPlayer ? gameProvider.playerGameStats['vitality']!.value : (character as EnemyTemplate).health.toDouble();
    double currentHp;

    String characterName = "Your Stats";
    String? description;
    int attackStat = 0;
    int defenseStat = 0;
    List<Widget> runeEffectsDisplay = []; 

    if (isPlayer) {
        currentHp = gameProvider.currentGame.playerCurrentHp;
        characterName = gameProvider.currentUser?.displayName ?? "Adventurer";
        attackStat = gameProvider.playerGameStats['strength']!.value.toInt();
        defenseStat = gameProvider.playerGameStats['defense']!.value.toInt();
    } else if (character is EnemyTemplate) {
        characterName = character.name;
        description = character.description;
        attackStat = character.attack;
        defenseStat = character.defense;
        if (gameProvider.currentGame.enemy != null && gameProvider.currentGame.enemy!.id == character.id) {
             currentHp = gameProvider.currentGame.enemy!.hp.toDouble();
        } else {
            currentHp = character.hp.toDouble();
        }
    } else {
        currentHp = 0;
    }


    final double hpPercent = maxHp > 0 ? (currentHp / maxHp) : 0.0;
     Color hpBarColor;
    if (hpPercent * 100 > 60) { hpBarColor = AppTheme.fhAccentGreen; }
    else if (hpPercent * 100 > 30) { hpBarColor = AppTheme.fhAccentOrange; }
    else { hpBarColor = AppTheme.fhAccentRed; }

    return Card(
      elevation: 1,
      color: AppTheme.fhBgMedium.withOpacity(0.7), 
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              characterName,
              style: theme.textTheme.titleLarge?.copyWith(color: isPlayer ? dynamicAccent : AppTheme.fhAccentRed, fontWeight: FontWeight.bold, fontSize: 17),
              overflow: TextOverflow.ellipsis,
            ),
            const SizedBox(height: 8),
             SizedBox(
                height: 12, 
                child: ClipRRect(
                    borderRadius: BorderRadius.circular(3), 
                    child: LinearProgressIndicator(
                    value: hpPercent,
                    backgroundColor: AppTheme.fhBgDark,
                    valueColor: AlwaysStoppedAnimation<Color>(hpBarColor),
                    ),
                )
            ),
            const SizedBox(height: 6),
            Text('HP: ${currentHp.toStringAsFixed(0)} / ${maxHp.toStringAsFixed(0)}', style: theme.textTheme.bodyMedium?.copyWith(color: AppTheme.fhTextSecondary, fontSize: 13)),
            const SizedBox(height: 4),
            Row(
              children: [
                Icon(MdiIcons.sword, size: 14, color: AppTheme.fhAccentOrange.withOpacity(0.8)),
                Text(' ATK: $attackStat  ', style: theme.textTheme.bodyMedium?.copyWith(fontSize: 13)),
                Icon(MdiIcons.shield, size: 14, color: AppTheme.fhAccentTealFixed.withOpacity(0.8)), // Use fixed teal for clarity
                Text(' DEF: $defenseStat', style: theme.textTheme.bodyMedium?.copyWith(fontSize: 13)),
              ],
            ),
             if (isPlayer && runeEffectsDisplay.isNotEmpty) ...[
                const SizedBox(height: 6),
                Wrap(spacing: 4, runSpacing: 4, children: runeEffectsDisplay),
             ],
             if (!isPlayer && description != null && description.isNotEmpty) ...[
                const SizedBox(height: 6),
                Tooltip(
                    message: description,
                    preferBelow: false,
                    child: Text(
                        description,
                        style: theme.textTheme.bodySmall?.copyWith(fontStyle: FontStyle.italic, color: AppTheme.fhTextSecondary.withOpacity(0.7), fontSize: 11),
                        maxLines: 2, 
                        overflow: TextOverflow.ellipsis,
                    ),
                )
            ]
          ],
        ),
      ),
    );
  }


  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    final Color dynamicAccent = gameProvider.getSelectedTask()?.taskColor ?? theme.colorScheme.secondary;
    final Color buttonTextColor = ThemeData.estimateBrightnessForColor(dynamicAccent) == Brightness.dark ? AppTheme.fhTextPrimary : AppTheme.fhBgDark;

    print("[GameView] build called. SelectedLocationId: $_selectedLocationId, currentPlaceKey from provider: ${gameProvider.currentGame.currentPlaceKey}");
    
    final List<GameLocation> unlockedLocations = gameProvider.gameLocationsList.where((loc) => gameProvider.isLocationUnlocked(loc.id)).toList();
    print("[GameView] Unlocked locations for dropdown: ${unlockedLocations.map((l) => l.name).join(', ')}");

    if (_selectedLocationId != null && !unlockedLocations.any((loc) => loc.id == _selectedLocationId)) {
        print("[GameView] _selectedLocationId '$_selectedLocationId' is no longer valid/unlocked.");
        WidgetsBinding.instance.addPostFrameCallback((_) {
            if (mounted) {
                setState(() {
                    _selectedLocationId = unlockedLocations.isNotEmpty ? unlockedLocations.first.id : (gameProvider.gameLocationsList.isNotEmpty ? gameProvider.gameLocationsList.first.id : null);
                    print("[GameView] Reset _selectedLocationId to '$_selectedLocationId'");
                    if (_selectedLocationId != null) {
                        gameProvider.setProviderState(
                            currentGame: CurrentGame(
                                playerCurrentHp: gameProvider.currentGame.playerCurrentHp,
                                log: gameProvider.currentGame.log,
                                currentPlaceKey: _selectedLocationId,
                            ),
                            doPersist: false
                        );
                    }
                });
            }
        });
    }


    final availableEnemies = gameProvider.enemyTemplatesList.where((enemyTmpl) =>
        enemyTmpl.locationKey == _selectedLocationId && 
        gameProvider.playerLevel >= enemyTmpl.minPlayerLevel &&
        !gameProvider.defeatedEnemyIds.contains(enemyTmpl.id)
    ).toList()..sort((a,b) {
        int lvlCompare = a.minPlayerLevel.compareTo(b.minPlayerLevel);
        if (lvlCompare != 0) return lvlCompare;
        return a.name.compareTo(b.name);
    });

    final ownedPowerUps = gameProvider.artifacts.map((ownedArt) {
        final template = gameProvider.getArtifactTemplateById(ownedArt.templateId);
        return (template != null && template.type == 'powerup' && (ownedArt.uses ?? 0) > 0) ? {'owned': ownedArt, 'template': template} : null;
    }).where((item) => item != null).cast<Map<String, dynamic>>().toList();

    GameLocation? displayedLocation = _selectedLocationId != null
      ? gameProvider.gameLocationsList.firstWhereOrNull((loc) => loc.id == _selectedLocationId)
      : null;
    if (displayedLocation == null && gameProvider.gameLocationsList.isNotEmpty) {
        displayedLocation = gameProvider.gameLocationsList.first;
        _selectedLocationId = displayedLocation.id; 
         print("[GameView] Fallback: displayedLocation set to ${displayedLocation.name}");
    }


    return SingleChildScrollView(
      padding: const EdgeInsets.only(bottom: 16, right: 4, left: 4),
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 16.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text(displayedLocation?.iconEmoji ?? '🗺️', style: const TextStyle(fontSize: 28)),
                const SizedBox(width: 12),
                Text(
                  displayedLocation?.name ?? "No Zone Selected",
                  style: theme.textTheme.displaySmall?.copyWith(color: AppTheme.fhTextPrimary, fontSize: 24), // Slightly smaller title
                ),
              ],
            ),
          ),

           if (gameProvider.currentGame.enemy == null)
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical:8.0),
              child: DropdownButtonFormField<String>(
                decoration: const InputDecoration(labelText: 'Select Combat Zone'),
                dropdownColor: AppTheme.fhBgMedium,
                value: _selectedLocationId,
                items: gameProvider.gameLocationsList.map((location) {
                  final bool isUnlocked = gameProvider.isLocationUnlocked(location.id);
                  return DropdownMenuItem<String>(
                    value: location.id,
                    enabled: isUnlocked,
                    child: Row(
                      children: [
                        Text(location.iconEmoji, style: const TextStyle(fontSize: 16)),
                        const SizedBox(width: 8),
                        Text(
                          location.name,
                          style: TextStyle(color: isUnlocked ? AppTheme.fhTextPrimary : AppTheme.fhTextDisabled),
                        ),
                        if (!isUnlocked) ...[
                          const SizedBox(width: 8),
                          Icon(MdiIcons.lockOutline, size: 14, color: AppTheme.fhTextDisabled.withOpacity(0.7)),
                          Text(" (Lvl ${location.minPlayerLevelToUnlock})", style: TextStyle(fontSize: 10, color: AppTheme.fhTextDisabled.withOpacity(0.7)))
                        ]
                      ],
                    ),
                  );
                }).toList(),
                onChanged: (String? newValue) {
                  if (newValue != null && gameProvider.isLocationUnlocked(newValue)) {
                    print("[GameView] Location changed to: $newValue");
                    setState(() {
                      _selectedLocationId = newValue;
                    });
                     gameProvider.setProviderState(
                        currentGame: CurrentGame(
                          playerCurrentHp: gameProvider.currentGame.playerCurrentHp,
                          log: gameProvider.currentGame.log,
                          currentPlaceKey: newValue,
                        ),
                        doPersist: false
                     );
                  } else if (newValue != null) {
                    print("[GameView] Attempted to select locked location: $newValue");
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(content: Text("Location ${gameProvider.gameLocationsList.firstWhereOrNull((l)=>l.id == newValue)?.name ?? ''} is locked!"), backgroundColor: AppTheme.fhAccentOrange),
                    );
                  }
                },
              ),
            ),


          if (gameProvider.currentGame.enemy == null) ...[
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 16.0),
              child: Text('Choose Your Opponent:', style: theme.textTheme.headlineSmall?.copyWith(color: AppTheme.fhTextPrimary, fontSize: 20)),
            ),
            if (availableEnemies.isEmpty)
              Padding(
                padding: const EdgeInsets.all(24.0),
                child: Text(
                  _selectedLocationId == null ? "Please select a combat zone." :
                  "No suitable opponents found in ${displayedLocation?.name ?? 'this zone'} for your current level (${gameProvider.playerLevel}). Try another zone or await new threats.",
                  textAlign: TextAlign.center,
                  style: theme.textTheme.bodyMedium?.copyWith(color: AppTheme.fhTextSecondary),
                ),
              )
            else
             LayoutBuilder(
                builder: (context, constraints) {
                  int crossAxisCount = constraints.maxWidth > 900 ? 3 : (constraints.maxWidth > 600 ? 2 : 1); // Adjusted counts
                   double itemWidth = (constraints.maxWidth - (crossAxisCount +1) * 10) / crossAxisCount;
                   double childAspectRatio = itemWidth / 260; // Adjusted for new card height

                  return GridView.builder(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    padding: const EdgeInsets.all(10),
                    gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                      crossAxisCount: crossAxisCount,
                      crossAxisSpacing: 10.0,
                      mainAxisSpacing: 10.0,
                      childAspectRatio: childAspectRatio.clamp(0.8, 1.1), // Adjusted clamp
                    ),
                    itemCount: availableEnemies.length,
                    itemBuilder: (context, index) {
                      final enemyTmpl = availableEnemies[index];
                      return EnemyInfoCardWidget(
                        enemy: enemyTmpl,
                        playerLevel: gameProvider.playerLevel,
                        onStartGame: () => gameProvider.startGame(enemyTmpl.id),
                      );
                    },
                  );
                }
              )
          ] else ...[
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 16.0, horizontal: 8.0),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(child: _renderCharacterStats(context, gameProvider.playerGameStats, true, gameProvider)),
                  const SizedBox(width: 12),
                  Expanded(child: _renderCharacterStats(context, gameProvider.currentGame.enemy!, false, gameProvider)),
                ],
              ),
            ),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
              child: ElevatedButton.icon(
                icon: Icon(MdiIcons.sword, size: 20),
                label: Text('ATTACK! (${energyPerAttack.toInt()}⚡)'),
                onPressed: gameProvider.playerEnergy < energyPerAttack ? null : gameProvider.handleFight,
                style: ElevatedButton.styleFrom(
                  backgroundColor: dynamicAccent,
                  foregroundColor: buttonTextColor,
                  minimumSize: const Size(double.infinity, 52), 
                  textStyle: theme.textTheme.labelLarge?.copyWith(color: buttonTextColor),
                ),
              ),
            ),
            if (gameProvider.playerEnergy < energyPerAttack)
                Text('Not enough energy! Complete sub-quests.', style: theme.textTheme.bodySmall?.copyWith(color: AppTheme.fhAccentOrange)),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 4.0),
              child: OutlinedButton(
                onPressed: gameProvider.forfeitMatch,
                 style: OutlinedButton.styleFrom(
                    foregroundColor: AppTheme.fhAccentOrange,
                    side: const BorderSide(color: AppTheme.fhAccentOrange, width: 1),
                    minimumSize: const Size(double.infinity, 44),
                    textStyle: theme.textTheme.labelMedium?.copyWith(color: AppTheme.fhAccentOrange),
                  ),
                child: const Text('Forfeit Match (-10% Ø, 0⚡)'),
              ),
            ),
             if (ownedPowerUps.isNotEmpty) ...[
              const SizedBox(height: 16),
              const Divider(),
              Padding(
                padding: const EdgeInsets.only(top: 12.0, bottom: 8.0),
                child: Text('Power-ups:', style: theme.textTheme.titleSmall?.copyWith(color: AppTheme.fhTextSecondary)),
              ),
              Wrap(
                spacing: 8.0,
                runSpacing: 8.0,
                alignment: WrapAlignment.center,
                children: ownedPowerUps.map((powerUpData) {
                  final OwnedArtifact owned = powerUpData['owned'] as OwnedArtifact;
                  final ArtifactTemplate template = powerUpData['template'] as ArtifactTemplate;
                  
                  Widget powerUpIcon;
                  if (template.icon.length == 1 || template.icon.length == 2) { 
                      powerUpIcon = Text(template.icon, style: const TextStyle(fontSize: 22));
                  } else { 
                      powerUpIcon = Icon(MdiIcons.fromString(template.icon.replaceAll('mdi-','')) ?? MdiIcons.flashAlert, size: 22);
                  }

                  return Tooltip(
                    message: '${template.name}: ${template.description} (Uses: ${owned.uses})',
                    child: OutlinedButton(
                      onPressed: () => gameProvider.usePowerUp(owned.uniqueId),
                      style: OutlinedButton.styleFrom(
                        foregroundColor: AppTheme.fhAccentPurple,
                        side: const BorderSide(color: AppTheme.fhAccentPurple, width: 1),
                        padding: const EdgeInsets.all(10),
                        minimumSize: const Size(48,48),
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
                      ),
                      child: powerUpIcon,
                    ),
                  );
                }).toList(),
              ),
            ],
          ],
          const SizedBox(height: 24),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Text('Combat Log:', style: theme.textTheme.titleSmall?.copyWith(color: AppTheme.fhTextSecondary)),
          ),
          const SizedBox(height: 8),
          Container(
            height: 180, 
            margin: const EdgeInsets.symmetric(horizontal: 16.0),
            padding: const EdgeInsets.all(12.0),
            decoration: BoxDecoration(
              color: AppTheme.fhBgMedium.withOpacity(0.6), 
              border: Border.all(color: AppTheme.fhBorderColor.withOpacity(0.5)),
              borderRadius: BorderRadius.circular(4),
            ),
            child: gameProvider.currentGame.log.isEmpty
              ? Text('No actions yet...', style: theme.textTheme.bodySmall?.copyWith(fontStyle: FontStyle.italic, color: AppTheme.fhTextSecondary.withOpacity(0.7)))
              : ListView.builder(
                  reverse: true,
                  itemCount: gameProvider.currentGame.log.length,
                  itemBuilder: (context, index) {
                    final entry = gameProvider.currentGame.log.reversed.toList()[index];
                    Color entryColor = AppTheme.fhTextSecondary;
                    String cleanEntry = entry.replaceAll(RegExp(r'<span[^>]*>|<\/span>'), "");

                    final colorMatch = RegExp(r'color:#([0-9a-fA-F]{6})').firstMatch(entry);
                    if (colorMatch != null) {
                        try {
                           entryColor = Color(int.parse('FF${colorMatch.group(1)}', radix: 16));
                        } catch (e) { /* fallback */ }
                    } else if (entry.contains('var(--fh-accent-green)')) { entryColor = AppTheme.fhAccentGreen; }
                    else if (entry.contains('var(--fh-accent-red)')) { entryColor = AppTheme.fhAccentRed; }
                    else if (entry.contains('var(--fh-accent-orange)')) { entryColor = AppTheme.fhAccentOrange; }
                    else if (entry.contains('var(--fh-accent-purple)')) { entryColor = AppTheme.fhAccentPurple; }
                    else if (entry.contains('font-weight:bold')) { entryColor = AppTheme.fhTextPrimary; }

                    return Padding(
                      padding: const EdgeInsets.only(bottom: 6.0),
                      child: Text(
                        cleanEntry,
                        style: theme.textTheme.bodySmall?.copyWith(color: entryColor, height: 1.4),
                      ),
                    );
                  },
                ),
          ),
        ],
      ),
    );
  }
}
--- END OF FILE lib/src/widgets/views/game_view.dart ---

--- START OF FILE lib/src/widgets/views/task_details_view.dart ---
// lib/src/widgets/views/task_details_view.dart
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:myapp_flutter/src/models/game_models.dart';
import 'package:myapp_flutter/src/utils/constants.dart';
import 'package:myapp_flutter/src/utils/helpers.dart' as helper;
import 'package:myapp_flutter/src/widgets/ui/rhombus_checkbox.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class TaskDetailsView extends StatefulWidget {
  const TaskDetailsView({super.key});

  @override
  State<TaskDetailsView> createState() => _TaskDetailsViewState();
}

class _TaskDetailsViewState extends State<TaskDetailsView> {
  // State for new subtask form
  final _newSubtaskNameController = TextEditingController();
  bool _newSubtaskIsCountable = false;
  final _newSubtaskTargetCountController = TextEditingController(text: '10');

  // State for AI subquest generation form
  String _aiGenerationMode = 'text_list'; // default mode
  final _aiUserInputController = TextEditingController();
  final _aiNumSubquestsController = TextEditingController(text: '3');

  // State for new sub-subtask forms (keyed by parent subtask ID)
  final Map<String, TextEditingController> _newSubSubtaskNameControllers = {};
  final Map<String, bool> _newSubSubtaskIsCountableMap = {};
  final Map<String, TextEditingController>
      _newSubSubtaskTargetCountControllers = {};

  // Local state for editing current time/count (keyed by subtask/sub-subtask ID)
  final Map<String, TextEditingController> _localTimeControllers = {};
  final Map<String, TextEditingController> _localCountControllers =
      {}; // For subtasks
  final Map<String, TextEditingController> _localSubSubtaskCountControllers =
      {}; // For sub-subtasks

  late GameProvider gameProvider;
  MainTask? _currentTaskForInit;

  @override
  void initState() {
    super.initState();
    gameProvider = Provider.of<GameProvider>(context, listen: false);
    _initializeControllersForTask(gameProvider.getSelectedTask());
    // Add listener to re-initialize controllers if selected task changes
    gameProvider.addListener(_handleProviderChange);
  }

  @override
  void dispose() {
    _newSubtaskNameController.dispose();
    _newSubtaskTargetCountController.dispose();
    _aiUserInputController.dispose();
    _aiNumSubquestsController.dispose();
    _clearDynamicControllers();
    gameProvider.removeListener(_handleProviderChange);
    super.dispose();
  }

  void _clearDynamicControllers() {
    for (var controller in _newSubSubtaskNameControllers.values) {
      controller.dispose();
    }
    _newSubSubtaskNameControllers.clear();
    for (var controller in _newSubSubtaskTargetCountControllers.values) {
      controller.dispose();
    }
    _newSubSubtaskTargetCountControllers.clear();
    for (var controller in _localTimeControllers.values) {
      controller.dispose();
    }
    _localTimeControllers.clear();
    for (var controller in _localCountControllers.values) {
      controller.dispose();
    }
    _localCountControllers.clear();
    for (var controller in _localSubSubtaskCountControllers.values) {
      controller.dispose();
    }
    _localSubSubtaskCountControllers.clear();
    _newSubSubtaskIsCountableMap.clear();
  }

  void _handleProviderChange() {
    final selectedTask = gameProvider.getSelectedTask();
    if (_currentTaskForInit?.id != selectedTask?.id) {
      if (mounted) {
        setState(() {
          // Ensure UI rebuilds if task changes leading to different controllers
          _initializeControllersForTask(selectedTask);
        });
      } else {
        _initializeControllersForTask(selectedTask);
      }
    }
  }

  void _initializeControllersForTask(MainTask? task) {
    _clearDynamicControllers(); // Clear previous task's controllers
    _currentTaskForInit = task;

    if (task != null) {
      for (var st in task.subTasks) {
        _newSubSubtaskNameControllers[st.id] = TextEditingController();
        _newSubSubtaskIsCountableMap[st.id] = false;
        _newSubSubtaskTargetCountControllers[st.id] =
            TextEditingController(text: '5');
        _localTimeControllers[st.id] =
            TextEditingController(text: st.currentTimeSpent.toString());
        if (st.isCountable) {
          _localCountControllers[st.id] =
              TextEditingController(text: st.currentCount.toString());
        }
        for (var sss in st.subSubTasks) {
          if (sss.isCountable) {
            _localSubSubtaskCountControllers[sss.id] =
                TextEditingController(text: sss.currentCount.toString());
          }
        }
      }
    }
  }

  void _handleAddSubtask(GameProvider gameProvider, MainTask task) {
    if (_newSubtaskNameController.text.trim().isNotEmpty) {
      final subtaskData = {
        'name': _newSubtaskNameController.text.trim(),
        'isCountable': _newSubtaskIsCountable,
        'targetCount': _newSubtaskIsCountable
            ? (int.tryParse(_newSubtaskTargetCountController.text) ?? 1)
            : 0,
      };
      final newSubtaskId = gameProvider.addSubtask(task.id, subtaskData);

      // Initialize controllers for the new subtask
      _newSubSubtaskNameControllers[newSubtaskId] = TextEditingController();
      _newSubSubtaskIsCountableMap[newSubtaskId] = false;
      _newSubSubtaskTargetCountControllers[newSubtaskId] =
          TextEditingController(text: '5');
      _localTimeControllers[newSubtaskId] = TextEditingController(text: '0');
      if (subtaskData['isCountable'] as bool) {
        _localCountControllers[newSubtaskId] = TextEditingController(text: '0');
      }

      _newSubtaskNameController.clear();
      // No need to call setState if GameProvider handles UI updates via notifyListeners
      _newSubtaskIsCountable = false; // Reset local state for form
      _newSubtaskTargetCountController.text =
          '10'; // Reset local state for form
      // State for form field values for isCountable needs separate handling if not directly bound to provider
      // For instance, by calling setState if these are local state variables in _TaskDetailsViewState
      if (mounted) {
        setState(() {}); // To update the form fields for _newSubtaskIsCountable
      }
    }
  }

  void _handleAddSubSubtask(
      GameProvider gameProvider, String mainTaskId, String parentSubtaskId) {
    final name = _newSubSubtaskNameControllers[parentSubtaskId]?.text.trim();
    if (name != null && name.isNotEmpty) {
      final subSubData = {
        'name': name,
        'isCountable': _newSubSubtaskIsCountableMap[parentSubtaskId] ?? false,
        'targetCount': (_newSubSubtaskIsCountableMap[parentSubtaskId] ?? false)
            ? (int.tryParse(
                    _newSubSubtaskTargetCountControllers[parentSubtaskId]
                            ?.text ??
                        '1') ??
                1)
            : 0,
      };
      gameProvider.addSubSubtask(mainTaskId, parentSubtaskId, subSubData);
      _newSubSubtaskNameControllers[parentSubtaskId]?.clear();
      // Reset local form state
      _newSubSubtaskIsCountableMap[parentSubtaskId] = false;
      _newSubSubtaskTargetCountControllers[parentSubtaskId]?.text = '5';
      if (mounted) {
        setState(
            () {}); // To update the form fields for the specific sub-subtask add section
      }
    }
  }

  void _handleTimeOrCountBlur(
      GameProvider gp, MainTask task, SubTask subTask, String fieldType) {
    if (fieldType == 'time') {
      final newTime =
          int.tryParse(_localTimeControllers[subTask.id]?.text ?? '0') ??
              subTask.currentTimeSpent;
      if (newTime != subTask.currentTimeSpent) {
        gp.updateSubtask(task.id, subTask.id, {'currentTimeSpent': newTime});
      }
    } else if (fieldType == 'count' && subTask.isCountable) {
      final newCount =
          int.tryParse(_localCountControllers[subTask.id]?.text ?? '0') ??
              subTask.currentCount;
      if (newCount != subTask.currentCount) {
        gp.updateSubtask(task.id, subTask.id,
            {'currentCount': newCount.clamp(0, subTask.targetCount)});
      }
    }
  }

  void _handleSubSubtaskCountBlur(GameProvider gp, MainTask task,
      SubTask parentSubTask, SubSubTask subSubTask) {
    if (subSubTask.isCountable) {
      final newCount = int.tryParse(
              _localSubSubtaskCountControllers[subSubTask.id]?.text ?? '0') ??
          subSubTask.currentCount;
      if (newCount != subSubTask.currentCount) {
        gp.updateSubSubtask(task.id, parentSubTask.id, subSubTask.id,
            {'currentCount': newCount.clamp(0, subSubTask.targetCount)});
      }
    }
  }

  void _handleCheckboxChange(GameProvider gp, MainTask task, SubTask subTask) {
    if (subTask.isCountable) {
      final currentCount =
          int.tryParse(_localCountControllers[subTask.id]?.text ?? '0') ??
              subTask.currentCount;
      if (currentCount < subTask.targetCount) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text(
                  'Please complete the target count (${subTask.targetCount}) before marking as done.'),
              backgroundColor: AppTheme.fhAccentRed),
        );
        return;
      }
    }
    gp.completeSubtask(task.id, subTask.id);
  }

  void _handleSubSubtaskCheckboxChange(GameProvider gp, MainTask task,
      SubTask parentSubTask, SubSubTask subSubTask) {
    if (subSubTask.isCountable) {
      final currentCount = int.tryParse(
              _localSubSubtaskCountControllers[subSubTask.id]?.text ?? '0') ??
          subSubTask.currentCount;
      if (currentCount < subSubTask.targetCount) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text(
                  'Please complete the target count (${subSubTask.targetCount}) for this step before marking as done.'),
              backgroundColor: AppTheme.fhAccentRed),
        );
        return;
      }
    }
    gp.completeSubSubtask(task.id, parentSubTask.id, subSubTask.id);
  }

  void _handleAiGenerateSubquests(GameProvider gameProvider, MainTask task) {
    if (_aiUserInputController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content:
                Text("Please provide input for the AI to generate sub-quests."),
            backgroundColor: AppTheme.fhAccentOrange),
      );
      return;
    }
    gameProvider.triggerAISubquestGeneration(
        task,
        _aiGenerationMode,
        _aiUserInputController.text.trim(),
        int.tryParse(_aiNumSubquestsController.text) ?? 3);
    _aiUserInputController.clear(); // Clear after submission
  }

  @override
  Widget build(BuildContext context) {
    // Consumer is fine here for reacting to GameProvider changes if _initializeControllersForTask
    // is also called from a listener pattern as implemented.
    return Consumer<GameProvider>(
      builder: (context, gameProviderConsumer, child) {
        final task = gameProviderConsumer.getSelectedTask();
        final theme = Theme.of(context);

        if (task == null) {
          return Center(
              child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(MdiIcons.textBoxSearchOutline,
                    size: 56,
                    color: AppTheme.fhAccentTeal), // Updated icon and color
                const SizedBox(height: 16),
                Text('Select a Quest',
                    style: theme.textTheme.displaySmall?.copyWith(
                        color: AppTheme.fhAccentTeal)), // Updated style
                const SizedBox(height: 8),
                Text(
                  'Details of the selected quest will appear here.',
                  style: theme.textTheme.titleMedium
                      ?.copyWith(color: AppTheme.fhTextSecondary),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ));
        }

        // This ensures controllers are initialized if the task object itself changes.
        // Useful if the task list is reloaded or the task object gets replaced.
        if (_currentTaskForInit?.id != task.id) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (mounted) {
              setState(() {
                _initializeControllersForTask(task);
              });
            }
          });
        }

        final timeProgressPercent = (task.dailyTimeSpent /
                dailyTaskGoalMinutes.toDouble() *
                100) // Ensure double division
            .clamp(0.0, 100.0);
        Color timeProgressColor =
            AppTheme.fhAccentTeal; // Default progress color, Changed from fhAccentLightCyan
        if (task.dailyTimeSpent >= dailyTaskGoalMinutes * 3) {
          timeProgressColor = AppTheme.fhAccentPurple;
        } else if (task.dailyTimeSpent >= dailyTaskGoalMinutes * 2) {
          timeProgressColor = AppTheme.fhAccentTeal; // Changed from fhAccentBrightBlue
        } else if (task.dailyTimeSpent >= dailyTaskGoalMinutes) {
          timeProgressColor = AppTheme.fhAccentGreen;
        }

        final completedSubtasksCount =
            task.subTasks.where((st) => st.completed).length;
        final totalSubtasksCount = task.subTasks.length;
        final subtaskCompletionPercent = totalSubtasksCount > 0
            ? (completedSubtasksCount / totalSubtasksCount * 100)
            : 0.0;

        // Check if controllers for subtasks exist, if not, initialize them
        // This handles cases where subtasks are added and widget rebuilds before initState for new subtask controllers
        for (var st in task.subTasks) {
          _localTimeControllers.putIfAbsent(
              st.id,
              () =>
                  TextEditingController(text: st.currentTimeSpent.toString()));
          if (st.isCountable) {
            _localCountControllers.putIfAbsent(st.id,
                () => TextEditingController(text: st.currentCount.toString()));
          }
          _newSubSubtaskNameControllers.putIfAbsent(
              st.id, () => TextEditingController());
          _newSubSubtaskIsCountableMap.putIfAbsent(st.id, () => false);
          _newSubSubtaskTargetCountControllers.putIfAbsent(
              st.id, () => TextEditingController(text: '5'));
          for (var sss in st.subSubTasks) {
            if (sss.isCountable) {
              _localSubSubtaskCountControllers.putIfAbsent(
                  sss.id,
                  () =>
                      TextEditingController(text: sss.currentCount.toString()));
            }
          }
        }

        return Padding(
          // Removed SingleChildScrollView as parent handles it
          padding:
              const EdgeInsets.only(top: 0, bottom: 16, left: 10, right: 10),
          child: Column(
            mainAxisSize:
                MainAxisSize.min, // Allow column to shrink wrap its content
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Card(
                color: AppTheme
                    .fhBgMedium, // Use medium background for prominent card
                margin: const EdgeInsets.only(bottom: 16, left: 0, right: 0),
                elevation: 0,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(6.0),
                  side: BorderSide(
                      color: AppTheme.fhBorderColor.withOpacity(0.5), width: 1),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(12.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            '${task.theme.toUpperCase()} QUEST PROTOCOL', // Themed title
                            style: theme.textTheme.labelMedium?.copyWith(
                                color: AppTheme.fhAccentTeal,
                                fontWeight: FontWeight.bold,
                                letterSpacing: 0.8),
                          ),
                          Container(
                            // Status chip
                            padding: const EdgeInsets.symmetric(
                                horizontal: 8, vertical: 3),
                            decoration: BoxDecoration(
                                color: task.dailyTimeSpent >=
                                        dailyTaskGoalMinutes
                                    ? AppTheme.fhAccentGreen.withOpacity(0.2)
                                    : AppTheme.fhAccentOrange.withOpacity(0.2),
                                borderRadius: BorderRadius.circular(4),
                                border: Border.all(
                                    color: task.dailyTimeSpent >=
                                            dailyTaskGoalMinutes
                                        ? AppTheme.fhAccentGreen
                                        : AppTheme.fhAccentOrange,
                                    width: 0.5)),
                            child: Text(
                              task.dailyTimeSpent >= dailyTaskGoalMinutes
                                  ? "OBJECTIVE MET"
                                  : (task.dailyTimeSpent > 0
                                      ? "ACTIVE"
                                      : "PENDING"),
                              style: theme.textTheme.labelSmall?.copyWith(
                                color:
                                    task.dailyTimeSpent >= dailyTaskGoalMinutes
                                        ? AppTheme.fhAccentGreen
                                        : AppTheme.fhAccentOrange,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 6),
                      Text(task.name,
                          style: theme
                              .textTheme.headlineSmall // More prominent title
                              ?.copyWith(
                                  color: AppTheme.fhTextPrimary,
                                  fontWeight: FontWeight.w600)),
                      const SizedBox(height: 8),
                      Text(task.description,
                          style: theme.textTheme.bodyMedium?.copyWith(
                              color: AppTheme.fhTextSecondary,
                              fontSize: 13,
                              height: 1.5)),
                      const SizedBox(height: 16),
                      // Progress Stats Card (Inner Card)
                      Card(
                        color: AppTheme.fhBgDark
                            .withOpacity(0.7), // Darker inner card
                        elevation: 0,
                        child: Padding(
                          padding: const EdgeInsets.all(12.0),
                          child: Column(
                            children: [
                              Row(
                                children: [
                                  Container(
                                    padding: const EdgeInsets.all(8),
                                    decoration: BoxDecoration(
                                      border: Border.all(
                                          color: AppTheme.fhAccentTeal // Changed from fhAccentLightCyan
                                              .withOpacity(0.7),
                                          width: 1.5),
                                      borderRadius: BorderRadius.circular(4),
                                    ),
                                    child: Text(
                                      gameProviderConsumer.romanize(
                                          task.streak > 0 ? task.streak : 1),
                                      style: theme.textTheme.titleLarge
                                          ?.copyWith(
                                              color: AppTheme.fhAccentTeal, // Changed from fhAccentLightCyan
                                              fontWeight: FontWeight.bold),
                                    ),
                                  ),
                                  const SizedBox(width: 16),
                                  Expanded(
                                    child: Column(
                                      crossAxisAlignment:
                                          CrossAxisAlignment.start,
                                      children: [
                                        Text('CURRENT STREAK: ${task.streak}',
                                            style: theme.textTheme.labelMedium
                                                ?.copyWith(
                                                    color:
                                                        AppTheme.fhAccentGreen,
                                                    fontWeight:
                                                        FontWeight.bold)),
                                        const SizedBox(height: 2),
                                        Text(
                                            'TIME LOGGED (TODAY): ${task.dailyTimeSpent}m / ${dailyTaskGoalMinutes}m Goal',
                                            style: theme.textTheme.bodySmall
                                                ?.copyWith(
                                                    fontSize: 11,
                                                    color: AppTheme
                                                        .fhTextSecondary)),
                                        const SizedBox(height: 6),
                                        SizedBox(
                                            height: 8, // Thicker progress bar
                                            child: ClipRRect(
                                                borderRadius:
                                                    BorderRadius.circular(4),
                                                child: LinearProgressIndicator(
                                                    value: timeProgressPercent /
                                                        100,
                                                    backgroundColor: AppTheme
                                                        .fhBorderColor
                                                        .withOpacity(0.3),
                                                    valueColor:
                                                        AlwaysStoppedAnimation<
                                                                Color>(
                                                            timeProgressColor)))),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                              if (totalSubtasksCount > 0) ...[
                                const SizedBox(height: 12),
                                Divider(
                                    color:
                                        AppTheme.fhBorderColor.withOpacity(0.3),
                                    height: 1),
                                const SizedBox(height: 10),
                                Text('SUB-QUESTS TRACKING:',
                                    style: theme.textTheme.labelMedium
                                        ?.copyWith(
                                            color: AppTheme.fhTextSecondary,
                                            fontWeight: FontWeight.bold)),
                                const SizedBox(height: 6),
                                SizedBox(
                                    height: 8, // Thicker progress bar
                                    child: ClipRRect(
                                        borderRadius: BorderRadius.circular(4),
                                        child: LinearProgressIndicator(
                                            value:
                                                subtaskCompletionPercent / 100,
                                            backgroundColor: AppTheme
                                                .fhBorderColor
                                                .withOpacity(0.3),
                                            valueColor:
                                                const AlwaysStoppedAnimation<
                                                        Color>(
                                                    AppTheme.fhAccentPurple)))),
                                const SizedBox(height: 4),
                                Align(
                                    alignment: Alignment.centerRight,
                                    child: Text(
                                        '$completedSubtasksCount / $totalSubtasksCount modules completed',
                                        style: theme.textTheme.labelSmall
                                            ?.copyWith(
                                                fontSize: 10,
                                                color:
                                                    AppTheme.fhTextSecondary))),
                              ]
                            ],
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
              Padding(
                padding:
                    const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),
                child: Text('Sub-Quests Log',
                    style: theme.textTheme.titleLarge?.copyWith(
                        // Updated style
                        fontFamily: AppTheme.fontDisplay, // Changed from AppTheme.fontMain
                        color: AppTheme.fhTextPrimary,
                        fontWeight: FontWeight.w600)),
              ),
              if (task.subTasks.isEmpty)
                Padding(
                  padding: const EdgeInsets.all(24.0), // Increased padding
                  child: Center(
                      child: Text(
                          'No sub-quests recorded yet. Add some below or use AI generation.',
                          textAlign: TextAlign.center,
                          style: theme.textTheme.bodyLarge?.copyWith(
                              // Use bodyLarge for better readability
                              color: AppTheme.fhTextSecondary.withOpacity(0.8),
                              fontStyle: FontStyle.italic))),
                )
              else
                ListView.builder(
                  // This ListView should not be primary scrollable
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  itemCount: task.subTasks.length,
                  itemBuilder: (ctx, index) {
                    final st = task.subTasks[index];
                    // Ensure controllers are available
                    _newSubSubtaskNameControllers.putIfAbsent(
                        st.id, () => TextEditingController());
                    _newSubSubtaskIsCountableMap.putIfAbsent(
                        st.id, () => false);
                    _newSubSubtaskTargetCountControllers.putIfAbsent(
                        st.id, () => TextEditingController(text: '5'));
                    _localTimeControllers.putIfAbsent(
                        st.id,
                        () => TextEditingController(
                            text: st.currentTimeSpent.toString()));
                    if (st.isCountable) {
                      _localCountControllers.putIfAbsent(
                          st.id,
                          () => TextEditingController(
                              text: st.currentCount.toString()));
                    }
                    for (var sss in st.subSubTasks) {
                      if (sss.isCountable) {
                        _localSubSubtaskCountControllers.putIfAbsent(
                            sss.id,
                            () => TextEditingController(
                                text: sss.currentCount.toString()));
                      }
                    }

                    final timerState = gameProviderConsumer.activeTimers[st.id];
                    final displayTimeSeconds = timerState != null
                        ? (timerState.isRunning
                            ? timerState.accumulatedDisplayTime +
                                (DateTime.now()
                                        .difference(timerState.startTime)
                                        .inMilliseconds /
                                    1000)
                            : timerState.accumulatedDisplayTime)
                        : st.currentTimeSpent * 60.0;

                    final completedSubSubTasks =
                        st.subSubTasks.where((sss) => sss.completed).length;
                    final totalSubSubTasks = st.subSubTasks.length;
                    final subSubTaskProgress = totalSubSubTasks > 0
                        ? (completedSubSubTasks / totalSubSubTasks * 100)
                        : 0.0;

                    return Card(
                      // Subtask card
                      key: ValueKey(st.id),
                      margin:
                          const EdgeInsets.only(bottom: 12, left: 0, right: 0),
                      color: AppTheme
                          .fhBgLight, // Use light background for subtask cards
                      elevation: 0,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(4.0),
                        side: BorderSide(
                            color: AppTheme.fhBorderColor.withOpacity(0.5),
                            width: 0.5),
                      ),
                      child: Padding(
                        padding: const EdgeInsets.all(12.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              children: [
                                RhombusCheckbox(
                                  // Themed checkbox
                                  checked: st.completed,
                                  onChanged: st.completed
                                      ? null
                                      : (bool? value) => _handleCheckboxChange(
                                          gameProviderConsumer, task, st),
                                  disabled: st.completed,
                                ),
                                const SizedBox(width: 10),
                                Expanded(
                                    child: Text(st.name,
                                        style: theme.textTheme
                                            .titleMedium // Prominent name for subtask
                                            ?.copyWith(
                                                decoration: st.completed
                                                    ? TextDecoration.lineThrough
                                                    : TextDecoration.none,
                                                color: st.completed
                                                    ? AppTheme.fhTextSecondary
                                                        .withOpacity(0.7)
                                                    : AppTheme.fhTextPrimary,
                                                fontWeight: st.completed
                                                    ? FontWeight.normal
                                                    : FontWeight.w600))),
                                if (!st.completed)
                                  IconButton(
                                    icon: Icon(
                                        MdiIcons
                                            .deleteForeverOutline, // Changed icon
                                        color: AppTheme.fhAccentRed
                                            .withOpacity(0.8),
                                        size: 20),
                                    onPressed: () => gameProviderConsumer
                                        .deleteSubtask(task.id, st.id),
                                    tooltip: 'Delete Sub-Quest',
                                    padding: EdgeInsets.zero,
                                    constraints: const BoxConstraints(),
                                    visualDensity: VisualDensity.compact,
                                  ),
                              ],
                            ),
                            if (!st.completed) ...[
                              const SizedBox(height: 10),
                              Divider(
                                  color:
                                      AppTheme.fhBorderColor.withOpacity(0.3)),
                              Padding(
                                padding: const EdgeInsets.only(
                                    left: 30.0, top: 8.0), // Indent details
                                child: Column(
                                  children: [
                                    // Countable progress
                                    if (st.isCountable)
                                      _buildProgressRow(
                                        theme,
                                        label: 'Progress:',
                                        controller:
                                            _localCountControllers[st.id]!,
                                        currentValue: st.currentCount,
                                        targetValue: st.targetCount,
                                        progressColor:
                                            AppTheme.fhAccentTeal, // Changed from fhAccentBrightBlue
                                        onBlur: () => _handleTimeOrCountBlur(
                                            gameProviderConsumer,
                                            task,
                                            st,
                                            'count'),
                                      ),
                                    const SizedBox(height: 6),
                                    // Timer row
                                    _buildTimerRow(
                                      theme,
                                      label: 'Time (m):',
                                      controller: _localTimeControllers[st.id]!,
                                      loggedTime: st.currentTimeSpent,
                                      timerState: timerState,
                                      displayTimeSeconds: displayTimeSeconds,
                                      onPlayPause: () => {
                                        timerState?.isRunning ?? false
                                            ? gameProviderConsumer
                                                .pauseTimer(st.id)
                                            : gameProviderConsumer.startTimer(
                                                st.id, 'subtask', task.id),
                                        if (timerState?.isRunning ?? false)
                                          gameProviderConsumer
                                              .logTimerAndReset(st.id)
                                      },
                                      onBlur: () => _handleTimeOrCountBlur(
                                          gameProviderConsumer,
                                          task,
                                          st,
                                          'time'),
                                    ),
                                    const SizedBox(height: 12),
                                    // Sub-subtasks
                                    if (st.subSubTasks.isNotEmpty) ...[
                                      _buildSubSubTaskList(
                                          theme,
                                          gameProviderConsumer,
                                          task,
                                          st,
                                          subSubTaskProgress),
                                    ],
                                    const SizedBox(height: 8),
                                    // Add new sub-subtask form
                                    _buildAddSubSubTaskForm(
                                        theme, gameProviderConsumer, task, st),
                                  ],
                                ),
                              ),
                            ],
                            if (st.completed) // Show completion info
                              Padding(
                                padding:
                                    const EdgeInsets.only(left: 30.0, top: 8.0),
                                child: Row(
                                  mainAxisAlignment:
                                      MainAxisAlignment.spaceBetween,
                                  children: [
                                    // Completed info
                                    Text(
                                        'Completed: ${st.completedDate} - Logged: ${st.currentTimeSpent}m',
                                        style: theme.textTheme.labelSmall
                                            ?.copyWith(
                                                color: AppTheme.fhAccentGreen
                                                    .withOpacity(0.8),
                                                fontSize: 10)),
                                    // Actions for completed subtasks
                                    Wrap(
                                      spacing: 10,
                                      children: [
                                        // Duplicate button
                                        IconButton(
                                            icon: Icon(MdiIcons.repeatVariant,
                                                size: 18,
                                                color: AppTheme
                                                    .fhAccentTeal // Changed from fhAccentBrightBlue
                                                    .withOpacity(0.8)),
                                            onPressed: () =>
                                                gameProviderConsumer
                                                    .duplicateCompletedSubtask(
                                                        task.id, st.id),
                                            visualDensity:
                                                VisualDensity.compact,
                                            padding: EdgeInsets.zero,
                                            constraints: const BoxConstraints(
                                                maxWidth: 30, maxHeight: 24)),
                                        IconButton(
                                            icon: Icon(MdiIcons.deleteOutline,
                                                size: 18,
                                                color: AppTheme.fhAccentRed),
                                            onPressed: () =>
                                                gameProviderConsumer
                                                    .deleteSubtask(
                                                        task.id, st.id),
                                            visualDensity:
                                                VisualDensity.compact,
                                            padding: EdgeInsets.zero,
                                            constraints: const BoxConstraints(
                                                maxWidth: 30, maxHeight: 24)),
                                      ],
                                    ),
                                  ],
                                ),
                              ),
                          ],
                        ),
                      ),
                    );
                  },
                ),
              // "Add New Sub-Quest" and "Generate with AI" cards - apply similar themed Card styling
              _buildAddNewSubQuestCard(theme, gameProviderConsumer, task),
              _buildAISubQuestCard(theme, gameProviderConsumer, task),
            ],
          ),
        );
      },
    );
  }

  // Helper methods for cleaner build method, with theming:
  Widget _buildProgressRow(
    ThemeData theme, {
    required String label,
    required TextEditingController controller,
    required int currentValue,
    required int targetValue,
    required Color progressColor,
    required VoidCallback onBlur,
  }) {
    return Row(
      children: [
        SizedBox(
            width: 70,
            child: Text(label,
                style: theme.textTheme.bodySmall
                    ?.copyWith(fontSize: 11, color: AppTheme.fhTextSecondary))),
        SizedBox(
          width: 40,
          height: 28,
          child: TextField(
            controller: controller,
            keyboardType: TextInputType.number,
            textAlign: TextAlign.center,
            style: theme.textTheme.bodyMedium
                ?.copyWith(fontSize: 12, color: AppTheme.fhTextPrimary),
            decoration: const InputDecoration(
                contentPadding: EdgeInsets.symmetric(vertical: 2),
                border: InputBorder.none,
                filled: false),
            onEditingComplete: onBlur,
            onTapOutside: (_) => onBlur(),
          ),
        ),
        Text(' / $targetValue',
            style: theme.textTheme.bodySmall
                ?.copyWith(fontSize: 11, color: AppTheme.fhTextSecondary)),
        const SizedBox(width: 10),
        Expanded(
          child: SizedBox(
            height: 6,
            child: ClipRRect(
              borderRadius: BorderRadius.circular(3),
              child: LinearProgressIndicator(
                value: targetValue > 0 ? (currentValue / targetValue) : 0,
                backgroundColor: AppTheme.fhBorderColor.withOpacity(0.3),
                valueColor: AlwaysStoppedAnimation<Color>(progressColor),
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildTimerRow(
    ThemeData theme, {
    required String label,
    required TextEditingController controller,
    required int loggedTime,
    required ActiveTimerInfo? timerState,
    required double displayTimeSeconds,
    required VoidCallback onPlayPause,
    required VoidCallback onBlur,
  }) {
    return Row(
      children: [
        SizedBox(
            width: 70,
            child: Text(label,
                style: theme.textTheme.bodySmall
                    ?.copyWith(fontSize: 11, color: AppTheme.fhTextSecondary))),
        SizedBox(
          width: 40,
          height: 28,
          child: TextField(
            controller: controller,
            keyboardType: TextInputType.number,
            textAlign: TextAlign.center,
            style: theme.textTheme.bodyMedium
                ?.copyWith(fontSize: 12, color: AppTheme.fhTextPrimary),
            decoration: const InputDecoration(
                contentPadding: EdgeInsets.symmetric(vertical: 2),
                border: InputBorder.none,
                filled: false),
            onEditingComplete: onBlur,
            onTapOutside: (_) => onBlur(),
          ),
        ),
        const Spacer(),
        Text('Logged: ${loggedTime}m',
            style: theme.textTheme.labelSmall?.copyWith(
                color: AppTheme.fhTextSecondary.withOpacity(0.8),
                fontSize: 10)),
        IconButton(
          icon: Icon(
            timerState?.isRunning ?? false
                ? MdiIcons.pauseCircleOutline
                : MdiIcons.playCircleOutline,
            color: timerState?.isRunning ?? false
                ? AppTheme.fhAccentOrange
                : AppTheme.fhAccentGreen,
            size: 22,
          ),
          onPressed: onPlayPause,
          padding: EdgeInsets.zero,
          visualDensity: VisualDensity.compact,
        ),
        Text(
          helper.formatTime(displayTimeSeconds),
          style: theme.textTheme.labelSmall?.copyWith(
              color: AppTheme.fhAccentTeal, // Changed from fhAccentLightCyan
              fontSize: 11,
              fontWeight: FontWeight.w600),
          textAlign: TextAlign.right,
        ),
      ],
    );
  }

  Widget _buildSubSubTaskList(
      ThemeData theme,
      GameProvider gameProviderConsumer,
      MainTask task,
      SubTask st,
      double subSubTaskProgress) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text('Checkpoints:',
                style: theme.textTheme.bodySmall?.copyWith(
                    color: AppTheme.fhTextSecondary.withOpacity(0.8),
                    fontSize: 11,
                    fontWeight: FontWeight.w600)),
            const SizedBox(width: 8),
            Expanded(
              child: SizedBox(
                height: 4,
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(2),
                  child: LinearProgressIndicator(
                    value: subSubTaskProgress / 100,
                    backgroundColor: AppTheme.fhBorderColor.withOpacity(0.3),
                    valueColor: const AlwaysStoppedAnimation<Color>(
                        AppTheme.fhAccentPurple),
                  ),
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: 6),
        ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: st.subSubTasks.length,
            itemBuilder: (sctx, sIndex) {
              final sss = st.subSubTasks[sIndex];
              return Padding(
                padding: const EdgeInsets.only(
                    bottom: 4.0, left: 8.0), // Indent sub-subtasks
                child: Row(
                  children: [
                    SizedBox(
                        width: 20,
                        height: 20,
                        child: RhombusCheckbox(
                          checked: sss.completed,
                          onChanged: sss.completed
                              ? null
                              : (bool? val) => _handleSubSubtaskCheckboxChange(
                                  gameProviderConsumer, task, st, sss),
                          disabled: sss.completed,
                          size: CheckboxSize.small,
                        )),
                    const SizedBox(width: 8),
                    Expanded(
                        child: Text(
                            '${sss.name}${sss.isCountable && !sss.completed ? ' (${_localSubSubtaskCountControllers[sss.id]?.text ?? sss.currentCount}/${sss.targetCount})' : (sss.isCountable && sss.completed ? ' (${sss.currentCount}/${sss.targetCount})' : '')}',
                            style: theme.textTheme.bodySmall?.copyWith(
                              fontSize: 11,
                              decoration: sss.completed
                                  ? TextDecoration.lineThrough
                                  : TextDecoration.none,
                              color: sss.completed
                                  ? AppTheme.fhTextSecondary.withOpacity(0.6)
                                  : AppTheme.fhTextSecondary,
                            ))),
                    if (sss.isCountable && !sss.completed)
                      SizedBox(
                        width: 35,
                        height: 22,
                        child: TextField(
                          controller: _localSubSubtaskCountControllers[sss.id],
                          keyboardType: TextInputType.number,
                          textAlign: TextAlign.center,
                          style: theme.textTheme.labelSmall?.copyWith(
                              fontSize: 10, color: AppTheme.fhTextPrimary),
                          decoration: const InputDecoration(
                              contentPadding: EdgeInsets.symmetric(vertical: 1),
                              border: InputBorder.none,
                              filled: false),
                          onEditingComplete: () => _handleSubSubtaskCountBlur(
                              gameProviderConsumer, task, st, sss),
                          onTapOutside: (_) => _handleSubSubtaskCountBlur(
                              gameProviderConsumer, task, st, sss),
                        ),
                      ),
                    if (!sss.completed)
                      IconButton(
                          icon: Icon(MdiIcons.deleteOutline,
                              color: AppTheme.fhAccentRed.withOpacity(0.7),
                              size: 16),
                          visualDensity: VisualDensity.compact,
                          padding: EdgeInsets.zero,
                          constraints: const BoxConstraints(),
                          onPressed: () => gameProviderConsumer
                              .deleteSubSubtask(task.id, st.id, sss.id)),
                  ],
                ),
              );
            }),
      ],
    );
  }

  Widget _buildAddSubSubTaskForm(ThemeData theme,
      GameProvider gameProviderConsumer, MainTask task, SubTask st) {
    return Padding(
      padding: const EdgeInsets.only(top: 4.0, left: 8.0), // Indent add form
      child: Row(
        children: [
          Expanded(
              child: SizedBox(
                  height: 36, // Consistent height
                  child: TextField(
                    controller: _newSubSubtaskNameControllers[st.id],
                    decoration: const InputDecoration(
                        hintText: 'Add a checkpoint...',
                        contentPadding: EdgeInsets.symmetric(
                            horizontal: 8, vertical: 4)),
                    style: theme.textTheme.bodySmall
                        ?.copyWith(fontSize: 11, color: AppTheme.fhTextPrimary),
                  ))),
          Transform.scale(
            // Make switch smaller
            scale: 0.7,
            child: Switch(
              value: _newSubSubtaskIsCountableMap[st.id] ?? false,
              onChanged: (val) =>
                  setState(() => _newSubSubtaskIsCountableMap[st.id] = val),
              activeColor: AppTheme.fhAccentTeal, // Changed from fhAccentBrightBlue
              materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
            ),
          ),
          if (_newSubSubtaskIsCountableMap[st.id] ?? false)
            SizedBox(
                width: 35,
                height: 36,
                child: TextField(
                  controller: _newSubSubtaskTargetCountControllers[st.id],
                  keyboardType: TextInputType.number,
                  textAlign: TextAlign.center,
                  decoration: const InputDecoration(
                      contentPadding: EdgeInsets.symmetric(vertical: 4)),
                  style: theme.textTheme.bodySmall
                      ?.copyWith(fontSize: 11, color: AppTheme.fhTextPrimary),
                )),
          IconButton(
            icon: Icon(MdiIcons.plusCircleOutline,
                color: AppTheme.fhAccentGreen, size: 22),
            onPressed: () =>
                _handleAddSubSubtask(gameProviderConsumer, task.id, st.id),
            visualDensity: VisualDensity.compact,
            padding: const EdgeInsets.only(left: 4),
            constraints: const BoxConstraints(),
          ),
        ],
      ),
    );
  }

  Widget _buildAddNewSubQuestCard(
      ThemeData theme, GameProvider gameProviderConsumer, MainTask task) {
    return Card(
      color: AppTheme.fhBgMedium, // Distinct background for form cards
      margin: const EdgeInsets.only(top: 20, left: 0, right: 0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(6),
        side: BorderSide(
            color: AppTheme.fhBorderColor.withOpacity(0.8), width: 1),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Add New Sub-Quest (Manually)',
                style: theme.textTheme.titleMedium?.copyWith(
                    fontFamily: AppTheme.fontDisplay, // Changed from AppTheme.fontMain
                    color: AppTheme.fhTextPrimary,
                    fontWeight: FontWeight.w600)),
            const SizedBox(height: 12),
            TextField(
              controller: _newSubtaskNameController,
              decoration:
                  const InputDecoration(hintText: 'Sub-quest objective...'),
              style: theme.textTheme.bodyMedium
                  ?.copyWith(fontSize: 14, color: AppTheme.fhTextPrimary),
            ),
            const SizedBox(height: 10),
            Row(
              children: [
                Checkbox(
                  value: _newSubtaskIsCountable,
                  onChanged: (val) =>
                      setState(() => _newSubtaskIsCountable = val ?? false),
                  activeColor: AppTheme.fhAccentTeal,
                  checkColor: AppTheme.fhBgDark,
                  visualDensity: VisualDensity.compact,
                  side: BorderSide(
                      color: AppTheme.fhAccentTeal.withOpacity(0.7),
                      width: 1.5),
                ),
                const Text('Is it countable?',
                    style: TextStyle(
                        color: AppTheme.fhTextSecondary,
                        fontSize: 13,
                        fontFamily: AppTheme.fontBody)),
                const SizedBox(width: 12),
                if (_newSubtaskIsCountable)
                  Expanded(
                    child: TextField(
                      controller: _newSubtaskTargetCountController,
                      decoration: const InputDecoration(
                          labelText: 'Target #',
                          contentPadding:
                              EdgeInsets.symmetric(horizontal: 8, vertical: 6)),
                      keyboardType: TextInputType.number,
                      style: const TextStyle(
                          fontSize: 13,
                          fontFamily: AppTheme.fontBody,
                          color: AppTheme.fhTextPrimary),
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 16),
            ElevatedButton.icon(
              icon: Icon(MdiIcons.plusBoxOutline, size: 18),
              label: const Text('ADD SUB-QUEST'),
              onPressed: () => _handleAddSubtask(gameProviderConsumer, task),
              style: ElevatedButton.styleFrom(
                  minimumSize: const Size(double.infinity, 40)),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAISubQuestCard(
      ThemeData theme, GameProvider gameProviderConsumer, MainTask task) {
    return Card(
      color: AppTheme.fhBgMedium,
      margin: const EdgeInsets.only(top: 16, left: 0, right: 0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(6),
        side: BorderSide(
            color: AppTheme.fhAccentPurple.withOpacity(0.5),
            width: 1), // AI card distinct border
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(MdiIcons.robotHappyOutline,
                    color: AppTheme.fhAccentPurple, size: 20),
                const SizedBox(width: 8),
                Text('Generate Sub-Quests with AI',
                    style: theme.textTheme.titleMedium?.copyWith(
                        fontFamily: AppTheme.fontDisplay, // Changed from AppTheme.fontMain
                        color: AppTheme.fhTextPrimary,
                        fontWeight: FontWeight.w600)),
              ],
            ),
            const SizedBox(height: 12),
            DropdownButtonFormField<String>(
              decoration: const InputDecoration(
                  labelText: 'Generation Mode',
                  labelStyle: TextStyle(
                      fontSize: 13, fontFamily: AppTheme.fontBody)),
              dropdownColor: AppTheme.fhBgLight,
              value: _aiGenerationMode,
              style: theme.textTheme.bodyMedium
                  ?.copyWith(fontSize: 14, color: AppTheme.fhTextPrimary),
              items: const [
                DropdownMenuItem(
                    value: 'text_list',
                    child: Text('From Text List / Outline')),
                DropdownMenuItem(
                    value: 'book_chapter',
                    child: Text('From Book Chapter/Section')),
                DropdownMenuItem(
                    value: 'general_plan',
                    child: Text('From General Plan/Goal')),
              ],
              onChanged: (value) {
                if (value != null) {
                  setState(() => _aiGenerationMode = value);
                }
              },
            ),
            const SizedBox(height: 12),
            TextField(
              controller: _aiUserInputController,
              decoration: const InputDecoration(
                labelText: 'Your Input for AI...',
                alignLabelWithHint: true,
                labelStyle: TextStyle(
                    fontSize: 13, fontFamily: AppTheme.fontBody),
              ),
              maxLines: null, // <--- Set maxLines to null for auto-expansion
              minLines: 2,
              style: theme.textTheme.bodyMedium
                  ?.copyWith(fontSize: 14, color: AppTheme.fhTextPrimary),
            ),
            const SizedBox(height: 12),
            TextField(
              controller: _aiNumSubquestsController,
              decoration: const InputDecoration(
                  labelText: 'Approx. # Sub-Quests',
                  labelStyle: TextStyle(
                      fontSize: 13, fontFamily: AppTheme.fontBody)),
              keyboardType: TextInputType.number,
              style: theme.textTheme.bodyMedium
                  ?.copyWith(fontSize: 14, color: AppTheme.fhTextPrimary),
            ),
            const SizedBox(height: 16),
            ElevatedButton.icon(
              icon: gameProviderConsumer.isGeneratingSubquests
                  ? const SizedBox(
                      width: 18,
                      height: 18,
                      child: CircularProgressIndicator(
                          strokeWidth: 2, color: AppTheme.fhBgDark))
                  : Icon(MdiIcons.creationOutline, size: 18), // Changed icon
              label: Text(gameProviderConsumer.isGeneratingSubquests
                  ? 'GENERATING...'
                  : 'INITIATE AI PROTOCOL'),
              onPressed: gameProviderConsumer.isGeneratingSubquests
                  ? null
                  : () =>
                      _handleAiGenerateSubquests(gameProviderConsumer, task),
              style: ElevatedButton.styleFrom(
                  backgroundColor: AppTheme.fhAccentPurple,
                  foregroundColor:
                      AppTheme.fhTextPrimary, // Ensure text is visible
                  disabledBackgroundColor: AppTheme.fhBgLight.withOpacity(0.5),
                  minimumSize: const Size(double.infinity, 40)),
            ),
          ],
        ),
      ),
    );
  }
}
--- END OF FILE lib/src/widgets/views/task_details_view.dart ---

--- START OF FILE lib/src/widgets/ui/artifact_card.dart ---
// lib/src/widgets/ui/artifact_card.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/models/game_models.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class ArtifactCardWidget extends StatelessWidget {
  final ArtifactTemplate template;
  final OwnedArtifact? ownedArtifact;
  final Widget? actionSection;
  final int? cost;

  const ArtifactCardWidget({
    super.key,
    required this.template,
    this.ownedArtifact,
    this.actionSection,
    this.cost,
  });

  Map<String, IconData> get _statIcons => {
    'att': MdiIcons.sword,
    'def': MdiIcons.shieldOutline,
    'health': MdiIcons.heartFlash,
    'runic': MdiIcons.fireAlert,
    'luck': MdiIcons.cloverOutline,
    'cooldown': MdiIcons.clockFast,
    'bonusXPMod': MdiIcons.schoolOutline,
    'direct_damage': MdiIcons.laserPointer,
    'heal_player': MdiIcons.bottleTonicPlusOutline,
    'uses': MdiIcons.repeatVariant,
  };

  Widget _buildStatsList(BuildContext context, ArtifactTemplate effectiveTemplate, OwnedArtifact? currentOwned) {
    final theme = Theme.of(context);
    final List<Widget> statWidgets = [];
    final Color dynamicAccent = Provider.of<GameProvider>(context, listen:false).getSelectedTask()?.taskColor ?? Theme.of(context).colorScheme.secondary;


    Widget statChip(IconData icon, String value, Color color, {bool isBright = false}) {
       final Color textColor = isBright ? AppTheme.fhBgDark : AppTheme.fhTextPrimary;
      return Container(
        padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 2),
        decoration: BoxDecoration(
          color: isBright ? color.withOpacity(0.85) : AppTheme.fhBgDark.withOpacity(0.5),
          borderRadius: BorderRadius.circular(4),
          border: Border.all(color: color.withOpacity(0.5), width: 0.5)
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, size: 12, color: isBright ? AppTheme.fhBgDark.withOpacity(0.8) : color),
            const SizedBox(width: 4),
            Text(value, style: theme.textTheme.labelSmall?.copyWith(color: textColor, fontSize: 10, fontWeight: FontWeight.w600)),
          ],
        ),
      );
    }


    if (effectiveTemplate.type == 'powerup') {
      if (effectiveTemplate.effectType == 'direct_damage' && effectiveTemplate.effectValue != null && effectiveTemplate.effectValue! > 0) {
        statWidgets.add(statChip(_statIcons['direct_damage']!, '${effectiveTemplate.effectValue}', AppTheme.fhAccentRed, isBright: true));
      }
      if (effectiveTemplate.effectType == 'heal_player' && effectiveTemplate.effectValue != null && effectiveTemplate.effectValue! > 0) {
        statWidgets.add(statChip(_statIcons['heal_player']!, '+${effectiveTemplate.effectValue} HP', AppTheme.fhAccentGreen, isBright: true));
      }
      final usesValue = currentOwned?.uses ?? template.uses;
      if (usesValue != null) {
        statWidgets.add(statChip(_statIcons['uses']!, '$usesValue Uses', AppTheme.fhTextSecondary));
      }
    } else {
      // Use dynamicAccent for primary stats if applicable, or specific colors for others
      if (effectiveTemplate.baseAtt != null && effectiveTemplate.baseAtt! > 0) statWidgets.add(statChip(_statIcons['att']!, '+${effectiveTemplate.baseAtt}', AppTheme.fhAccentOrange));
      if (effectiveTemplate.baseDef != null && effectiveTemplate.baseDef! > 0) statWidgets.add(statChip(_statIcons['def']!, '+${effectiveTemplate.baseDef}', dynamicAccent));
      if (effectiveTemplate.baseHealth != null && effectiveTemplate.baseHealth! > 0) statWidgets.add(statChip(_statIcons['health']!, '+${effectiveTemplate.baseHealth}', AppTheme.fhAccentGreen));
      if (effectiveTemplate.baseRunic != null && effectiveTemplate.baseRunic! > 0) statWidgets.add(statChip(_statIcons['runic']!, '+${effectiveTemplate.baseRunic}', AppTheme.fhAccentPurple));
      if (effectiveTemplate.baseLuck != null && effectiveTemplate.baseLuck! > 0) statWidgets.add(statChip(_statIcons['luck']!, '+${effectiveTemplate.baseLuck}%', dynamicAccent));
      if (effectiveTemplate.baseCooldown != null && effectiveTemplate.baseCooldown! > 0) statWidgets.add(statChip(_statIcons['cooldown']!, '-${effectiveTemplate.baseCooldown}% CD', AppTheme.fhTextSecondary));
      if (effectiveTemplate.bonusXPMod != null && effectiveTemplate.bonusXPMod! > 0) statWidgets.add(statChip(_statIcons['bonusXPMod']!, '+${(effectiveTemplate.bonusXPMod! * 100).toStringAsFixed(0)}% XP', AppTheme.fhAccentGreen));
    }

    if (statWidgets.isEmpty) {
      return Padding(
        padding: const EdgeInsets.symmetric(vertical: 8.0),
        child: Text(
          template.type == 'powerup' ? "Single-use tactical item." : "No direct combat bonuses.",
          style: theme.textTheme.bodySmall?.copyWith(fontStyle: FontStyle.italic, color: AppTheme.fhTextSecondary.withOpacity(0.7), fontSize: 10),
        ),
      );
    }

    return Padding(
      padding: const EdgeInsets.only(top: 6, bottom: 8),
      child: Wrap(
        spacing: 6.0, 
        runSpacing: 4.0, 
        children: statWidgets,
      ),
    );
  }


  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    final ArtifactTemplate displayTemplate = ownedArtifact != null
        ? gameProvider.getArtifactEffectiveStats(ownedArtifact!)
        : template;
    
    final Color dynamicAccent = gameProvider.getSelectedTask()?.taskColor ?? theme.colorScheme.secondary;
    final Color cardTitleColor = dynamicAccent;
    final Color cardTextColorOnAccent = ThemeData.estimateBrightnessForColor(dynamicAccent) == Brightness.dark ? AppTheme.fhTextPrimary : AppTheme.fhBgDark;


    Color borderColor = AppTheme.fhBorderColor.withOpacity(0.5);
    if (ownedArtifact != null) {
      borderColor = dynamicAccent.withOpacity(0.7); 
    } else if (cost != null && gameProvider.coins >= cost!) {
      borderColor = dynamicAccent.withOpacity(0.5); 
    }

    Widget itemIcon;
    if (displayTemplate.icon.length == 1 || displayTemplate.icon.length == 2) { 
        itemIcon = Text(displayTemplate.icon, style: const TextStyle(fontSize: 32)); // Larger icon
    } else { 
        final iconData = MdiIcons.fromString(displayTemplate.icon.replaceAll('mdi-', '')) ?? MdiIcons.treasureChest; 
        itemIcon = Icon(iconData, size: 32, color: AppTheme.fhTextSecondary);
    }


    return Card(
      elevation: 0, 
      color: AppTheme.fhBgLight.withOpacity(0.8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(6.0),
        side: BorderSide(color: borderColor, width: 1), 
      ),
      child: Padding(
        padding: const EdgeInsets.all(10.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisAlignment: MainAxisAlignment.spaceBetween, // Ensure action button is at bottom
          children: [
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Container( 
                      width: 50, // Fixed size for icon container
                      height: 50,
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                        color: AppTheme.fhBgDark.withOpacity(0.6),
                        borderRadius: BorderRadius.circular(4)
                      ),
                      child: Center(child: itemIcon),
                    ),
                    const SizedBox(width: 10),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            displayTemplate.name,
                            style: theme.textTheme.titleMedium?.copyWith(
                                fontFamily: AppTheme.fontDisplay, 
                                color: cardTitleColor, // Dynamic color
                                fontWeight: FontWeight.bold, 
                                fontSize: 15), // Slightly larger title
                            maxLines: 2, // Allow two lines for name
                            overflow: TextOverflow.ellipsis,
                          ),
                           if (ownedArtifact != null && displayTemplate.type != 'powerup' && displayTemplate.maxLevel != null)
                            Container(
                              margin: const EdgeInsets.only(top:2),
                              padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 1.5),
                              decoration: BoxDecoration(
                                color: cardTitleColor.withOpacity(0.85),
                                borderRadius: BorderRadius.circular(3)
                              ),
                              child: Text(
                                'LEVEL ${ownedArtifact!.currentLevel} / ${displayTemplate.maxLevel}', 
                                style: theme.textTheme.labelSmall?.copyWith(color: cardTextColorOnAccent, fontWeight: FontWeight.bold, letterSpacing: 0.5, fontSize: 9),
                              ),
                            )
                           else 
                             Text(
                              displayTemplate.type.toUpperCase(),
                              style: theme.textTheme.labelSmall?.copyWith(color: AppTheme.fhTextSecondary.withOpacity(0.8), letterSpacing: 0.5, fontWeight: FontWeight.w500, fontSize: 10),
                            ),
                        ],
                      ),
                    ),

                  ],
                ),
                const SizedBox(height: 8),
                 if (displayTemplate.theme != null) ...[
                    Row(
                      children: [
                        Icon(MdiIcons.paletteSwatchOutline, size: 12, color: AppTheme.fhTextSecondary.withOpacity(0.7)),
                        const SizedBox(width: 4),
                        Text("System Alignment: ${displayTemplate.theme!}", style: theme.textTheme.labelSmall?.copyWith(color: AppTheme.fhTextSecondary.withOpacity(0.7), fontSize: 10, fontStyle: FontStyle.italic)),
                      ],
                    ),
                    const SizedBox(height: 6),
                 ],
                Text(
                  displayTemplate.description,
                  style: theme.textTheme.bodySmall?.copyWith(color: AppTheme.fhTextSecondary.withOpacity(0.9), fontStyle: FontStyle.italic, fontSize: 11, height: 1.3),
                  maxLines: 3, // Allow more lines for description
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 4), 
                _buildStatsList(context, displayTemplate, ownedArtifact),
              ],
            ),
            if (actionSection != null) ...[
              const Spacer(), // Push action to bottom if there's space
              Padding(
                padding: const EdgeInsets.only(top: 4.0), 
                child: Divider(color: AppTheme.fhBorderColor.withOpacity(0.3), height: 1, thickness: 0.5),
              ),
              Padding(
                padding: const EdgeInsets.only(top: 6.0), // Add padding above action
                child: actionSection!, 
              ),
            ]
          ],
        ),
      ),
    );
  }
}
--- END OF FILE lib/src/widgets/ui/artifact_card.dart ---

--- START OF FILE lib/src/widgets/ui/enemy_info_card.dart ---
// lib/src/widgets/ui/enemy_info_card.dart
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/models/game_models.dart'; // For EnemyTemplate
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:provider/provider.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';


class EnemyInfoCardWidget extends StatelessWidget {
  final EnemyTemplate enemy;
  final int playerLevel;
  final VoidCallback onStartGame;

  const EnemyInfoCardWidget({
    super.key,
    required this.enemy,
    required this.playerLevel,
    required this.onStartGame,
  });

  Map<String, dynamic> _getEnemyDifficulty(int enemyMinLevel, int pLevel) {
    final levelDiff = enemyMinLevel - pLevel;
    if (levelDiff <= -3) return {'text': "Trivial", 'color': AppTheme.fhAccentGreen.withOpacity(0.7)};
    if (levelDiff <= -1) return {'text': "Easy", 'color': AppTheme.fhAccentGreen};
    if (levelDiff == 0) return {'text': "Moderate", 'color': AppTheme.fhAccentTeal}; 
    if (levelDiff == 1) return {'text': "Challenging", 'color': AppTheme.fhAccentOrange};
    return {'text': "Deadly", 'color': AppTheme.fhAccentRed, 'isBold': true};
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final difficulty = _getEnemyDifficulty(enemy.minPlayerLevel, playerLevel);
    final Color dynamicAccent = Provider.of<GameProvider>(context, listen:false).getSelectedTask()?.taskColor ?? theme.colorScheme.secondary;
    final Color cardTextColorOnAccent = ThemeData.estimateBrightnessForColor(dynamicAccent) == Brightness.dark ? AppTheme.fhTextPrimary : AppTheme.fhBgDark;


    // Placeholder for enemy icon/image. Using MDI icon for now.
    IconData enemyVisualIcon = MdiIcons.skullCrossbonesOutline; 
    if (enemy.theme == 'nature') enemyVisualIcon = MdiIcons.treeOutline;
    if (enemy.theme == 'ancient') enemyVisualIcon = MdiIcons.templeHinduOutline;
    if (enemy.theme == 'tech') enemyVisualIcon = MdiIcons.robotOutline;


    return Card(
      elevation: 0,
      color: AppTheme.fhBgLight.withOpacity(0.8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(6.0),
        side: BorderSide(color: AppTheme.fhBorderColor.withOpacity(0.7), width: 1),
      ),
      child: InkWell(
        onTap: onStartGame,
        borderRadius: BorderRadius.circular(6.0),
        hoverColor: dynamicAccent.withOpacity(0.05),
        child: Padding(
          padding: const EdgeInsets.all(10.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                       Container( 
                          width: 50,
                          height: 50,
                          padding: const EdgeInsets.all(4),
                          decoration: BoxDecoration(
                            color: AppTheme.fhBgDark.withOpacity(0.6),
                            borderRadius: BorderRadius.circular(4)
                          ),
                          child: Center(child: Icon(enemyVisualIcon, size: 30, color: AppTheme.fhTextSecondary.withOpacity(0.7))),
                        ),
                        const SizedBox(width: 10),
                        Expanded(
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                enemy.name,
                                style: theme.textTheme.titleMedium?.copyWith(
                                    fontFamily: AppTheme.fontDisplay,
                                    fontWeight: FontWeight.bold,
                                    color: AppTheme.fhTextPrimary,
                                    fontSize: 15),
                                maxLines: 2,
                                overflow: TextOverflow.ellipsis,
                              ),
                              if (enemy.theme != null)
                                Text(
                                    "${enemy.theme!.toUpperCase()} ENTITY",
                                    style: theme.textTheme.labelSmall?.copyWith(color: AppTheme.fhAccentPurple.withOpacity(0.8), fontSize: 9, letterSpacing: 0.5, fontWeight: FontWeight.w600),
                                ),
                            ],
                          ),
                        ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Flexible(child: _StatChip(icon: MdiIcons.heartOutline, value: enemy.health.toString(), color: AppTheme.fhAccentGreen)),
                      Flexible(child: _StatChip(icon: MdiIcons.sword, value: enemy.attack.toString(), color: AppTheme.fhAccentOrange)),
                      Flexible(child: _StatChip(icon: MdiIcons.shieldOutline, value: enemy.defense.toString(), color: AppTheme.fhAccentTeal)),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    enemy.description,
                    style: theme.textTheme.bodySmall?.copyWith(color: AppTheme.fhTextSecondary.withOpacity(0.8), fontStyle: FontStyle.italic, fontSize: 11, height: 1.3),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                   const SizedBox(height: 8),
                  Container(
                        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                        decoration: BoxDecoration(
                          color: (difficulty['color'] as Color).withOpacity(0.15),
                          borderRadius: BorderRadius.circular(4),
                          border: Border.all(color: (difficulty['color'] as Color).withOpacity(0.5), width: 0.5)
                        ),
                        child: Text(
                          "Threat Level: ${difficulty['text'] as String}",
                          style: theme.textTheme.labelSmall?.copyWith(
                            color: difficulty['color'] as Color,
                            fontWeight: (difficulty['isBold'] as bool? ?? false) ? FontWeight.bold : FontWeight.w600,
                            fontSize: 10,
                          ),
                        ),
                      ),
                ],
              ),
              const Spacer(), // Push button to bottom
              Padding(
                padding: const EdgeInsets.only(top:10.0),
                child: ElevatedButton(
                  onPressed: onStartGame,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: dynamicAccent,
                    foregroundColor: cardTextColorOnAccent,
                    padding: const EdgeInsets.symmetric(vertical: 10),
                    textStyle: const TextStyle(
                        fontSize: 12,
                        fontFamily: AppTheme.fontBody, 
                        fontWeight: FontWeight.bold),
                  ),
                  child: const Text(
                    'ENGAGE TARGET',
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _StatChip extends StatelessWidget {
  final IconData icon;
  final String value;
  final Color color;

  const _StatChip({required this.icon, required this.value, required this.color});

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min, 
      children: [
        Icon(icon, size: 13, color: color.withOpacity(0.8)),
        const SizedBox(width: 4),
        Flexible(
          child: Text(
            value,
            style: Theme.of(context)
                .textTheme
                .bodyMedium
                ?.copyWith(fontSize: 12, color: AppTheme.fhTextPrimary.withOpacity(0.9), fontWeight: FontWeight.w500),
            maxLines: 1, 
            overflow: TextOverflow.ellipsis, 
          ),
        ),
      ],
    );
  }
}
--- END OF FILE lib/src/widgets/ui/enemy_info_card.dart ---

--- START OF FILE lib/src/widgets/ui/rhombus_checkbox.dart ---
// lib/src/widgets/ui/rhombus_checkbox.dart
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'dart:math' as math;
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

enum CheckboxSize { small, medium }

class RhombusCheckbox extends StatelessWidget {
  final bool checked;
  final ValueChanged<bool?>? onChanged;
  final bool disabled;
  final CheckboxSize size;

  const RhombusCheckbox({
    super.key,
    required this.checked,
    required this.onChanged,
    this.disabled = false,
    this.size = CheckboxSize.medium,
  });

  @override
  Widget build(BuildContext context) {
    final double dimension = size == CheckboxSize.small ? 18.0 : 22.0; // Overall tap target
    final double iconSize = size == CheckboxSize.small ? 12.0 : 14.0;
    final double visualDimension = size == CheckboxSize.small ? 15.0 : 18.0; // Visual size of rhombus

    Color bgColor = checked ? AppTheme.fhAccentTeal : AppTheme.fhBgMedium;
    Color borderColor = disabled
        ? (checked ? AppTheme.fhAccentTeal.withOpacity(0.5) : AppTheme.fhBorderColor.withOpacity(0.5))
        : (checked ? AppTheme.fhAccentTeal : AppTheme.fhBorderColor);

    if (disabled && checked) {
      bgColor = AppTheme.fhAccentTeal.withOpacity(0.6);
    } else if (disabled && !checked) {
      bgColor = AppTheme.fhBgLight.withOpacity(0.4);
    }


    return InkWell(
      onTap: disabled ? null : () => onChanged?.call(!checked),
      borderRadius: BorderRadius.circular(dimension / 4), // Make tap effect slightly rounded
      child: SizedBox(
        width: dimension,
        height: dimension,
        child: Stack(
          alignment: Alignment.center,
          children: [
            Transform.rotate(
              angle: math.pi / 4, // 45 degrees
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 150),
                height: visualDimension * 0.9, // Make it slightly smaller than container for padding
                width: visualDimension * 0.9,
                decoration: BoxDecoration(
                  color: bgColor,
                  border: Border.all(
                    color: borderColor,
                    width: 1.5, // Slightly thicker border
                  ),
                  // No boxShadow for flatter screenshot-like style
                  // borderRadius: BorderRadius.circular(2), // Optional: slight rounding of corners
                ),
              ),
            ),
            if (checked)
              Icon(
                MdiIcons.checkBold, // Using MDI check for a bolder look
                size: iconSize,
                color: disabled ? AppTheme.fhTextSecondary.withOpacity(0.7) : AppTheme.fhBgDark, // Dark check on light teal
              ),
          ],
        ),
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/ui/rhombus_checkbox.dart ---

--- START OF FILE lib/src/screens/settings_screen.dart ---
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/widgets/views/settings_view.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('System Configuration'),
        backgroundColor: AppTheme.fhBgMedium, // Match header style
      ),
      body: const SettingsView(),
    );
  }
}
--- END OF FILE lib/src/screens/settings_screen.dart ---

--- START OF FILE lib/src/screens/login_screen.dart ---
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:provider/provider.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:firebase_auth/firebase_auth.dart'; // Import FirebaseAuthException


class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  String _email = '';
  String _password = '';
  String _username = '';
  bool _isLogin = true;
  bool _isLoading = false;
  String _error = '';
  bool _obscurePassword = true;
  final _usernameController = TextEditingController();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();


  @override
  void dispose() {
    _usernameController.dispose();
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    _formKey.currentState!.save();
    setState(() {
      _isLoading = true;
      _error = '';
    });

    try {
      final gameProvider = Provider.of<GameProvider>(context, listen: false);
      if (_isLogin) {
        await gameProvider.loginUser(_email, _password);
      } else {
        await gameProvider.signupUser(_email, _password, _username);
      }
      // Auth state change will handle navigation in MyApp or GameProvider listener
    } catch (e) {
      // print("[LoginScreen] Auth Error: $e"); // DEBUG
      setState(() {
        if (e is FirebaseAuthException) {
          _error = e.message ?? "An unknown Firebase authentication error occurred.";
        } else {
          _error = "An unexpected error occurred. Please try again.";
        }
      });
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: AppTheme.fhBgDark, // Use the new dark background
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child:
              // Add a ConstrainedBox to limit the width for desktop
              ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 400), // Max width of 400 pixels
            child: Card(
              color: AppTheme.fhBgMedium, // Slightly lighter card background
              elevation: 0, // Flatter design
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8.0),
                side: const BorderSide(color: AppTheme.fhBorderColor, width: 1.5), // Themed border
              ),
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 24.0, vertical: 32.0),
                child: Form(
                  key: _formKey,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: <Widget>[
                      Icon(MdiIcons.shieldCrownOutline, size: 56, color: AppTheme.fhAccentTealFixed), // Themed Icon
                      const SizedBox(height: 16),
                      Text(
                        'TASK DOMINION',
                        style: theme.textTheme.displaySmall?.copyWith( // Use displaySmall for prominent title
                          color: AppTheme.fhAccentTealFixed,
                        ),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 8),
                      Text(
                        _isLogin ? 'Secure Login' : 'Create Account', // Updated subtitle
                        style: theme.textTheme.titleMedium?.copyWith(
                          color: AppTheme.fhTextSecondary,
                        ),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 32),
                      if (!_isLogin)
                        Padding(
                          padding: const EdgeInsets.only(bottom: 16.0),
                          child: TextFormField(
                            controller: _usernameController,
                            decoration: InputDecoration(
                              labelText: 'Username',
                              prefixIcon: Icon(MdiIcons.accountOutline, color: theme.inputDecorationTheme.labelStyle?.color, size: 20),
                            ),
                            style: const TextStyle(color: AppTheme.fhTextPrimary, fontFamily: AppTheme.fontBody),
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Please enter a username.';
                              }
                              if (value.trim().length < 3) {
                                return 'Username must be at least 3 characters.';
                              }
                              return null;
                            },
                            onSaved: (value) => _username = value!.trim(),
                          ),
                        ),
                      TextFormField(
                        controller: _emailController,
                        decoration: InputDecoration(
                          labelText: 'Email Address',
                          prefixIcon: Icon(MdiIcons.emailOutline, color: theme.inputDecorationTheme.labelStyle?.color, size: 20),
                        ),
                        keyboardType: TextInputType.emailAddress,
                        style: const TextStyle(color: AppTheme.fhTextPrimary, fontFamily: AppTheme.fontBody),
                        validator: (value) {
                          if (value == null || value.isEmpty || !value.contains('@')) {
                            return 'Please enter a valid email.';
                          }
                          return null;
                        },
                        onSaved: (value) => _email = value!,
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _passwordController,
                        decoration: InputDecoration(
                          labelText: 'Password',
                          prefixIcon: Icon(MdiIcons.lockOutline, color: theme.inputDecorationTheme.labelStyle?.color, size: 20),
                          suffixIcon: IconButton(
                            icon: Icon(
                              _obscurePassword ? MdiIcons.eyeOutline : MdiIcons.eyeOffOutline,
                              color: theme.inputDecorationTheme.labelStyle?.color,
                            ),
                            onPressed: () {
                              setState(() {
                                _obscurePassword = !_obscurePassword;
                              });
                            },
                          ),
                        ),
                        obscureText: _obscurePassword,
                        style: const TextStyle(color: AppTheme.fhTextPrimary, fontFamily: AppTheme.fontBody),
                        validator: (value) {
                          if (value == null || value.isEmpty || value.length < 6) {
                            return 'Password must be at least 6 characters long.';
                          }
                          return null;
                        },
                        onSaved: (value) => _password = value!,
                      ),
                      if (_error.isNotEmpty)
                        Padding(
                          padding: const EdgeInsets.only(top: 16.0),
                          child: Text(
                            _error,
                            style: const TextStyle(color: AppTheme.fhAccentRed, fontSize: 12, fontFamily: AppTheme.fontBody),
                            textAlign: TextAlign.center,
                          ),
                        ),
                      const SizedBox(height: 32),
                      if (_isLoading)
                        const CircularProgressIndicator(color: AppTheme.fhAccentTealFixed)
                      else
                        ElevatedButton(
                          onPressed: _submit,
                          style: ElevatedButton.styleFrom(
                            minimumSize: const Size(double.infinity, 48),
                          ),
                          child: Text(_isLogin ? 'LOGIN' : 'SIGN UP'),
                        ),
                      const SizedBox(height: 20),
                      TextButton(
                        onPressed: () {
                          setState(() {
                            _isLogin = !_isLogin;
                            _error = '';
                            _formKey.currentState?.reset();
                            _usernameController.clear();
                            _emailController.clear();
                            _passwordController.clear();
                          });
                        },
                        child: Text(
                          _isLogin ? 'Need an account? Sign Up' : 'Already have an account? Login',
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- END OF FILE lib/src/screens/login_screen.dart ---

--- START OF FILE lib/src/screens/home_screen.dart ---
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/widgets/header_widget.dart';
import 'package:myapp_flutter/src/widgets/middle_panel_widget.dart'; // This will be adapted
import 'package:myapp_flutter/src/widgets/player_stats_drawer.dart';
import 'package:myapp_flutter/src/widgets/task_navigation_drawer.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:myapp_flutter/src/widgets/views/artifact_shop_view.dart';
import 'package:myapp_flutter/src/widgets/views/blacksmith_view.dart';
import 'package:myapp_flutter/src/widgets/views/game_view.dart';
import 'package:myapp_flutter/src/widgets/views/task_details_view.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> with SingleTickerProviderStateMixin {
  int _selectedIndex = 0; // For BottomNavigationBar or TabBar
  late GameProvider _gameProvider;
  final ScrollController _scrollController = ScrollController();
  bool _isUsernameDialogShowing = false;
  late TabController _tabController; // Add TabController

  final List<Map<String, dynamic>> _views = [
    {'label': 'MISSIONS', 'value': 'task-details', 'icon': MdiIcons.clipboardListOutline},
    {'label': 'ARMORY', 'value': 'artifact-shop', 'icon': MdiIcons.storefrontOutline},
    {'label': 'FORGE', 'value': 'blacksmith', 'icon': MdiIcons.hammerWrench},
    {'label': 'ARENA', 'value': 'game', 'icon': MdiIcons.swordCross},
  ];

  @override
  void initState() {
    super.initState();
    _gameProvider = Provider.of<GameProvider>(context, listen: false);

    _tabController = TabController(length: _views.length, vsync: this);

    _selectedIndex = _views.indexWhere((view) => view['value'] == _gameProvider.currentView);
    if (_selectedIndex == -1) {
      _selectedIndex = 0;
      _gameProvider.setCurrentView(_views[0]['value'] as String);
    }
    _tabController.index = _selectedIndex; // Set initial tab index

    // Listen to tab controller changes to update provider
    _tabController.addListener(() {
      if (_tabController.indexIsChanging || _tabController.index == _selectedIndex) {
        // Only update if the index is actually changing by user interaction or a direct set.
        // Avoid redundant updates when _selectedIndex is already in sync.
        return;
      }
      setState(() {
        _selectedIndex = _tabController.index;
      });
      _gameProvider.setCurrentView(_views[_selectedIndex]['value'] as String);
      print("[HomeScreen] TabController Listener: Updated selectedIndex to $_selectedIndex for view ${_views[_selectedIndex]['value']}");
    });


    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_gameProvider.selectedTaskId == null && _gameProvider.mainTasks.isNotEmpty) {
        _gameProvider.setSelectedTaskId(_gameProvider.mainTasks.first.id);
      }
      _checkAndPromptForUsername(_gameProvider);
    });
    _gameProvider.addListener(_handleProviderForUsernamePrompt);
    _gameProvider.addListener(_handleCurrentViewChangeFromProvider);

    print("[HomeScreen] initState: Initial selectedIndex: $_selectedIndex, currentView: ${_gameProvider.currentView}");
  }

  void _handleProviderForUsernamePrompt() {
    _checkAndPromptForUsername(Provider.of<GameProvider>(context, listen: false));
  }

  void _handleCurrentViewChangeFromProvider() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    final newIndex = _views.indexWhere((view) => view['value'] == gameProvider.currentView);
    if (newIndex != -1 && newIndex != _selectedIndex) {
      if (mounted) {
        setState(() {
          _selectedIndex = newIndex;
        });
        _tabController.animateTo(newIndex); // Animate to the new tab
        print("[HomeScreen] _handleCurrentViewChangeFromProvider: Updated selectedIndex to $newIndex for view ${gameProvider.currentView}");
      }
    } else if (newIndex == -1 && _views.indexWhere((v) => v['value'] == gameProvider.currentView) == -1) {
      if (mounted && _selectedIndex != 0) {
        setState(() {
          _selectedIndex = 0;
        });
        _tabController.animateTo(0); // Animate to the first tab
        print("[HomeScreen] _handleCurrentViewChangeFromProvider: currentView '${gameProvider.currentView}' not in tabs, defaulting to index 0.");
      }
    }
  }

  void _checkAndPromptForUsername(GameProvider gameProvider) {
    if (mounted && gameProvider.isUsernameMissing && gameProvider.currentUser != null && !_isUsernameDialogShowing && !gameProvider.authLoading && !gameProvider.isDataLoadingAfterLogin) {
      print("[HomeScreen] Prompting for username.");
      setState(() {
        _isUsernameDialogShowing = true;
      });
      _showUsernameDialog(context, gameProvider).then((_) {
        if (mounted) {
          setState(() {
            _isUsernameDialogShowing = false;
          });
        }
      });
    }
  }

  Future<void> _showUsernameDialog(BuildContext context, GameProvider gameProvider) async {
    final TextEditingController usernameController = TextEditingController();
    final GlobalKey<FormState> dialogFormKey = GlobalKey<FormState>();
    print("[HomeScreen] Showing username dialog.");
    final Color currentAccentColor = gameProvider.getSelectedTask()?.taskColor ?? Theme.of(context).colorScheme.secondary;

    return showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: Text('Set Your Callsign', style: TextStyle(color: currentAccentColor)),
          content: Form(
            key: dialogFormKey,
            child: TextFormField(
              controller: usernameController,
              decoration: const InputDecoration(hintText: "Enter callsign (username)"),
              validator: (value) {
                if (value == null || value.trim().isEmpty) return 'Callsign cannot be empty.';
                if (value.trim().length < 3) return 'Must be at least 3 characters.';
                return null;
              },
            ),
          ),
          actions: <Widget>[
            ElevatedButton(
              style: ElevatedButton.styleFrom(backgroundColor: currentAccentColor),
              child: Text('CONFIRM CALLSIGN', style: TextStyle(color: ThemeData.estimateBrightnessForColor(currentAccentColor) == Brightness.dark ? AppTheme.fhTextPrimary : AppTheme.fhBgDark)),
              onPressed: () async {
                if (dialogFormKey.currentState!.validate()) {
                  String newUsername = usernameController.text.trim();
                  Navigator.of(dialogContext).pop();
                  print("[HomeScreen] Username dialog confirmed with: $newUsername");
                  await gameProvider.updateUserDisplayName(newUsername);
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Callsign updated!'), backgroundColor: AppTheme.fhAccentGreen),
                    );
                  }
                }
              },
            ),
          ],
        );
      },
    );
  }

  void _onItemTapped(int index) {
    if (index < 0 || index >= _views.length) return;
    print("[HomeScreen] _onItemTapped: index $index, view value: ${_views[index]['value']}");
    setState(() {
      _selectedIndex = index;
    });
    _gameProvider.setCurrentView(_views[index]['value'] as String);
  }

  @override
  void dispose() {
    _gameProvider.removeListener(_handleProviderForUsernamePrompt);
    _gameProvider.removeListener(_handleCurrentViewChangeFromProvider);
    _scrollController.dispose();
    _tabController.dispose(); // Dispose TabController
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;
    final bool isLargeScreen = screenWidth > 900;

    final gameProvider = context.watch<GameProvider>();
    final Color currentTaskColor = gameProvider.getSelectedTask()?.taskColor ?? AppTheme.fhAccentTealFixed;
    final ThemeData dynamicTheme = AppTheme.getThemeData(primaryAccent: currentTaskColor);

    print("[HomeScreen] build: SelectedIndex: $_selectedIndex, CurrentView from provider: ${gameProvider.currentView}");

    return Theme(
      data: dynamicTheme,
      child: Scaffold(
        body: SafeArea(
          child: Column(
            children: [
              HeaderWidget(currentViewLabel: _views.isNotEmpty && _selectedIndex >= 0 && _selectedIndex < _views.length ? _views[_selectedIndex]['label'] as String : "MISSIONS"),
              Expanded(
                child: isLargeScreen
                    ? Row(
                        children: [
                          Container(
                            width: 280,
                            decoration: BoxDecoration(
                              color: dynamicTheme.cardTheme.color,
                              border: Border(right: BorderSide(color: dynamicTheme.dividerTheme.color ?? AppTheme.fhBorderColor, width: 1)),
                            ),
                            child: const TaskNavigationDrawer(),
                          ),
                          Expanded(
                            child: Column( // New: Column for TabBar and TabBarView
                              children: [
                                Container(
                                  color: dynamicTheme.cardTheme.color,
                                  child: TabBar(
                                    controller: _tabController,
                                    isScrollable: false,
                                    indicatorColor: dynamicTheme.colorScheme.secondary,
                                    labelColor: dynamicTheme.colorScheme.secondary,
                                    unselectedLabelColor: dynamicTheme.textTheme.bodyMedium?.color?.withOpacity(0.7),
                                    tabs: _views.map((view) {
                                      return Tab(
                                        icon: Icon(view['icon'] as IconData),
                                        text: view['label'] as String,
                                      );
                                    }).toList(),
                                  ),
                                ),
                                Expanded( // Ensure TabBarView takes remaining space
                                  child: TabBarView(
                                    controller: _tabController,
                                    children: _views.map<Widget>((v) =>  MiddlePanelWidget(selectedIndex: _views.indexOf(v), views: _views.map<Widget>((v) => _getViewWidget(v['value'] as String)).toList())).toList(),
                                  ),
                                ),
                              ],
                            ),
                          ),
                          Container(
                            width: 320,
                            decoration: BoxDecoration(
                              color: dynamicTheme.cardTheme.color,
                              border: Border(left: BorderSide(color: dynamicTheme.dividerTheme.color ?? AppTheme.fhBorderColor, width: 1)),
                            ),
                            child: const PlayerStatsDrawer(),
                          ),
                        ],
                      )
                    : MiddlePanelWidget(selectedIndex: _selectedIndex, views: _views.map<Widget>((v) => _getViewWidget(v['value'] as String)).toList()),
              ),
            ],
          ),
        ),
        drawer: isLargeScreen ? null : const TaskNavigationDrawer(),
        endDrawer: isLargeScreen ? null : const PlayerStatsDrawer(),
        bottomNavigationBar: isLargeScreen
            ? null
            : BottomNavigationBar(
                items: _views.map((view) {
                  return BottomNavigationBarItem(
                    icon: Icon(view['icon'] as IconData),
                    label: view['label'] as String,
                  );
                }).toList(),
                currentIndex: _selectedIndex.clamp(0, _views.length - 1),
                onTap: _onItemTapped,
              ),
      ),
    );
  }

  Widget _getViewWidget(String viewValue) {
    switch (viewValue) {
      case 'task-details':
        return const TaskDetailsView();
      case 'artifact-shop':
        return const ArtifactShopView();
      case 'blacksmith':
        return const BlacksmithView();
      case 'game':
        return const GameView();
      default:
        if (_views.isNotEmpty) return _getViewWidget(_views[0]['value'] as String);
        return const Center(child: Text('Unknown View'));
    }
  }
}
--- END OF FILE lib/src/screens/home_screen.dart ---

--- START OF FILE lib/src/screens/logbook_screen.dart ---
import 'package:flutter/material.dart';
import 'package:myapp_flutter/src/widgets/views/daily_summary_view.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';

class LogbookScreen extends StatelessWidget {
  const LogbookScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Mission Logbook'),
        backgroundColor: AppTheme.fhBgMedium, // Match header style
      ),
      body: const DailySummaryView(),
    );
  }
}
--- END OF FILE lib/src/screens/logbook_screen.dart ---

--- START OF FILE lib/src/services/ai_service.dart ---
import 'dart:convert';
import 'package:google_generative_ai/google_generative_ai.dart' as genai;
import 'package:myapp_flutter/src/config/api_keys.dart'; // Your API keys file
import 'package:flutter/foundation.dart'; // For kDebugMode

class AIService {
  Future<Map<String, dynamic>> _makeAICall({
    required String prompt,
    required int currentApiKeyIndex,
    required Function(int) onNewApiKeyIndex,
    required Function(String) onLog,
  }) async {
    if (geminiApiKeys.isEmpty || geminiApiKeys.every((key) => key.startsWith('YOUR_GEMINI_API_KEY'))) {
      const errorMsg = "No valid Gemini API keys found. Cannot generate content.";
      onLog("<span style=\"color:var(--fh-accent-red);\">Error: AI content generation failed (No API Key or invalid key).</span>");
      throw Exception(errorMsg);
    }
    if (geminiModelName.isEmpty) {
      const errorMsg = "GEMINI_MODEL_NAME not configured. Cannot generate content.";
      onLog("<span style=\"color:var(--fh-accent-red);\">Error: AI content generation failed (GEMINI_MODEL_NAME not configured).</span>");
      throw Exception(errorMsg);
    }

    // Log the full prompt in debug mode
    if (kDebugMode) {
      print("[AIService] AI Prompt:\n$prompt");
    }


    for (int i = 0; i < geminiApiKeys.length; i++) {
      final int keyAttemptIndex = (currentApiKeyIndex + i) % geminiApiKeys.length;
      final String apiKey = geminiApiKeys[keyAttemptIndex];

      if (apiKey.startsWith('YOUR_GEMINI_API_KEY')) {
        onLog("<span style=\"color:var(--fh-accent-orange);\">Skipping invalid API key at index $keyAttemptIndex.</span>");
        continue;
      }

      try {
        onLog("Trying API key index $keyAttemptIndex for model $geminiModelName...");
        final model = genai.GenerativeModel(model: geminiModelName, apiKey: apiKey);
        final response = await model.generateContent([genai.Content.text(prompt)]);

        String? rawResponseText = response.text;
        if (rawResponseText == null || rawResponseText.trim().isEmpty) {
          throw Exception("AI response was empty or null.");
        }

        // Log the raw response in debug mode
        if (kDebugMode) {
          print("[AIService] Raw AI Response (Key Index $keyAttemptIndex):\n$rawResponseText");
        }
        onLog("Raw AI Response received. Attempting to parse JSON...");


        // More robust JSON extraction
        String jsonString = rawResponseText.trim();
        int jsonStart = jsonString.indexOf('{');
        int jsonEnd = jsonString.lastIndexOf('}');

        if (jsonStart != -1 && jsonEnd != -1 && jsonEnd > jsonStart) {
          jsonString = jsonString.substring(jsonStart, jsonEnd + 1);
        } else {
          onLog("<span style=\"color:var(--fh-accent-red);\">Error: Could not find valid JSON object delimiters {{ ... }} in AI response.</span>");
          if (kDebugMode) {
            print("[AIService] Failed to find JSON delimiters. Raw response was: $rawResponseText");
          }
          throw Exception("Could not extract JSON object from AI response.");
        }
        
        // Attempt to remove common non-JSON prefixes/suffixes if any (like markdown code blocks)
        // This is a secondary check if the above { } extraction wasn't perfect
        if (jsonString.startsWith("```json") && jsonString.endsWith("```")) {
            jsonString = jsonString.substring(7, jsonString.length - 3).trim();
        } else if (jsonString.startsWith("```") && jsonString.endsWith("```")) {
            jsonString = jsonString.substring(3, jsonString.length - 3).trim();
        }


        final Map<String, dynamic> generatedData = jsonDecode(jsonString);
        onNewApiKeyIndex(keyAttemptIndex);
        onLog("<span style=\"color:var(--fh-accent-green);\">Successfully processed AI response with API key index $keyAttemptIndex.</span>");
        return generatedData;

      } catch (e) {
        String errorDetail = e.toString();
         if (e is FormatException) {
          errorDetail = "JSON FormatException: ${e.message}. Check AI response for syntax errors (e.g., trailing commas, unquoted keys, incorrect string escapes).";
          if (kDebugMode) {
            print("[AIService] JSON Parsing Error: ${e.message}. Offending JSON string part (approx): ${e.source.toString().substring(0, (e.offset ?? e.source.toString().length).clamp(0, e.source.toString().length)).substring(0,100)}");
          }
        } else if (errorDetail.contains("API key not valid")) {
            errorDetail = "API key not valid. Please check your configuration.";
        } else if (errorDetail.contains("quota")) {
            errorDetail = "API quota exceeded for this key.";
        } else if (errorDetail.contains("Candidate was blocked due to SAFETY")) {
            errorDetail = "AI response blocked due to safety settings. Try a different prompt or adjust safety settings if possible.";
        }
        onLog("<span style=\"color:var(--fh-accent-red);\">Error with API key index $keyAttemptIndex: $errorDetail</span>");
        if (i == geminiApiKeys.length - 1) {
            throw Exception("All API keys failed. Last error: $errorDetail");
        }
      }
    }
    const finalErrorMsg = "All API keys failed or were invalid.";
    onLog("<span style=\"color:var(--fh-accent-red);\">$finalErrorMsg</span>");
    throw Exception(finalErrorMsg);
  }

  Future<Map<String, List<Map<String, dynamic>>>> generateGameContent({
    required int levelForContent,
    required bool isManual,
    required bool isInitial,
    required int currentApiKeyIndex,
    required Function(int) onNewApiKeyIndex,
    required String existingEnemyIdsString,
    required String existingArtifactIdsString,
    required String existingLocationIdsString, // New
    required List<String> themes,
    required Function(String) onLog,
  }) async {
    onLog("Attempting to generate themed game content (enemies/artifacts/locations)...");

    final int numEnemiesToGeneratePerTheme = isInitial ? 1 : 1;
    final int totalEnemiesToGenerate = themes.length * numEnemiesToGeneratePerTheme + (isInitial ? 2 : 1);
    final int numLocationsToGenerate = isInitial ? 2 : 1; // Generate a couple of locations initially, then one by one

    String artifactInstructions = "";
    for (String themeName in themes) {
      artifactInstructions += """
  - For the theme "$themeName":
    - One 'weapon' artifact with theme: "$themeName".
    - One 'armor' artifact with theme: "$themeName".
    - One 'talisman' artifact with theme: "$themeName".
    - One 'powerup' artifact with theme: "$themeName".
""";
    }

    final String prompt = """
Generate new game content suitable for a player at level $levelForContent in a fantasy RPG.
The player is currently progressing and needs new challenges, rewards, and places to explore.
Provide the output as a single, valid JSON object with three top-level keys: "newEnemies", "newArtifacts", and "newGameLocations".
Ensure there are NO trailing commas in lists or objects. All strings must be properly escaped (e.g. newlines as \\n, quotes as \\").

IMPORTANT:
- Do NOT generate enemies with IDs from this list: [$existingEnemyIdsString].
- Do NOT generate artifacts with IDs from this list: [$existingArtifactIdsString].
- Do NOT generate locations with IDs from this list: [$existingLocationIdsString].
- All generated IDs and names MUST be new and unique.

"newEnemies" should be an array of $totalEnemiesToGenerate enemy objects.
- For each theme in [${themes.map((t) => "'$t'").join(', ')}], generate $numEnemiesToGeneratePerTheme enemy specifically for that theme and a relevant locationKey (see newGameLocations).
- The remaining enemies can be general (theme: null) or pick from the themes.
Each enemy object must have:
- id: string, unique (e.g., "gen_enemy_lvl${levelForContent}_a2f5")
- name: string (e.g., "Shadow Lurker", "Arcane Golem")
- theme: string or null (one of [${themes.map((t) => "'$t'").join(', ')}, null])
- locationKey: string (MUST match one of the 'id's from "newGameLocations" generated in this response, or an existing one if appropriate for theme)
- minPlayerLevel: number (should be $levelForContent or slightly higher, e.g., up to ${levelForContent + 2})
- health: number (range: ${50 + levelForContent * 12} to ${80 + levelForContent * 18})
- attack: number (range: ${8 + (levelForContent * 1.8).floor()} to ${12 + (levelForContent * 2.2).floor()})
- defense: number (range: ${3 + (levelForContent * 0.6).floor()} to ${5 + (levelForContent * 1.1).floor()})
- coinReward: number (range: ${20 + levelForContent * 5} to ${50 + levelForContent * 10})
- xpReward: number (range: ${30 + levelForContent * 8} to ${70 + levelForContent * 15})
- description: string (max 100 chars)

"newArtifacts" should be an array of artifact objects.
$artifactInstructions
Each artifact object must have:
- id: string, unique (e.g., "gen_art_lvl${levelForContent}_tech_wpn_b3c8")
- name: string
- type: string ['weapon', 'armor', 'talisman', 'powerup']
- theme: string (MUST be the theme it was generated for)
- description: string (max 100 chars)
- cost: number (range: ${50 + levelForContent * 10} to ${300 + levelForContent * 25})
- icon: string (a single, relevant emoji)
- For 'weapon', 'armor', 'talisman':
    - baseAtt: number (0 if not applicable)
    - baseRunic: number (0 if not applicable)
    - baseDef: number (0 if not applicable)
    - baseHealth: number (0 if not applicable)
    - baseLuck: number (0-10, integer percentage)
    - baseCooldown: number (0-15, integer percentage)
    - bonusXPMod: number (0.0 to 0.15, decimal for percentage)
    - upgradeBonus: object (e.g., {"att": 2, "luck": 1}). Modest values.
    - maxLevel: number (3, 5, or 7)
- For 'powerup':
    - effectType: string ['direct_damage', 'heal_player']
    - effectValue: number
    - uses: number (typically 1)
    (omit baseStats, upgradeBonus, maxLevel for powerups or set to 0/null)

"newGameLocations" should be an array of $numLocationsToGenerate game location objects.
Each location object must have:
- id: string, unique (e.g., "loc_dark_forest", "loc_crystal_caves_$levelForContent")
- name: string (e.g., "Whispering Woods", "Sunken Temple of Eldoria")
- description: string (short, evocative description, max 150 chars)
- minPlayerLevelToUnlock: number (Based on current level. First one could be $levelForContent, next one ${levelForContent + 3}, etc. Make a progression.)
- iconEmoji: string (a single emoji representing the location, e.g., "🌲", "🏛️", "💎")
- associatedTheme: string or null (e.g., "knowledge", "tech", or null for general, matching one of [${themes.map((t) => "'$t'").join(', ')}, null])
- bossEnemyIdToUnlockNextLocation: string or null (ID of an enemy generated in "newEnemies" that, when defeated, could unlock another location. Can be null.)

Ensure all IDs are unique. Balance stats. Return ONLY the JSON object.
""";
    try {
      final Map<String, dynamic> rawData = await _makeAICall(
        prompt: prompt,
        currentApiKeyIndex: currentApiKeyIndex,
        onNewApiKeyIndex: onNewApiKeyIndex,
        onLog: onLog,
      );

      final List<Map<String, dynamic>> newEnemies = (rawData['newEnemies'] as List?)
          ?.map((e) => e as Map<String, dynamic>).toList() ?? [];
      final List<Map<String, dynamic>> newArtifacts = (rawData['newArtifacts'] as List?)
          ?.map((a) => a as Map<String, dynamic>).toList() ?? [];
      final List<Map<String, dynamic>> newGameLocations = (rawData['newGameLocations'] as List?)
          ?.map((loc) => loc as Map<String, dynamic>).toList() ?? [];
      
      onLog("AI content generation successful. Parsed ${newEnemies.length} enemies, ${newArtifacts.length} artifacts, ${newGameLocations.length} locations.");

      return {'newEnemies': newEnemies, 'newArtifacts': newArtifacts, 'newGameLocations': newGameLocations};

    } catch (e) {
      onLog("<span style=\"color:var(--fh-accent-red);\">AI Call failed for generateGameContent: ${e.toString()}</span>");
      if (kDebugMode) {
        print("[AIService] generateGameContent caught error: $e");
      }
      rethrow;
    }
  }

  Future<List<Map<String, dynamic>>> generateAISubquests({
    required String mainTaskName,
    required String mainTaskDescription,
    String? mainTaskTheme,
    required String generationMode,
    required String userInput,
    required int numSubquests,
    required int currentApiKeyIndex,
    required Function(int) onNewApiKeyIndex,
    required Function(String) onLog,
  }) async {
    onLog("Attempting to generate sub-quests for \"$mainTaskName\"... Mode: $generationMode");

    String modeSpecificInstructions = "";
    switch (generationMode) {
        case "book_chapter":
            modeSpecificInstructions = """
The user is providing details about a book chapter. Input: "$userInput"
Break this down into approximately $numSubquests actionable sub-quests.
For each sub-quest, suggest 1-3 smaller, concrete steps (sub-subtasks).
If a step involves reading pages, make it "countable" with "targetCount". E.g., "Read pages 10-25" -> name: "Read pages 10-25", isCountable: true, targetCount: 16.
""";
            break;
        case "text_list":
            modeSpecificInstructions = """
The user provided a hierarchical text list. Top-level items are sub-quests. Indented items are sub-subtasks. Input:
$userInput
Convert top-level items to sub-quests, indented items to sub-subtasks.
If an item mentions quantity (e.g., "3 sets", "10 pages"), make it "countable" and set "targetCount".
""";
            break;
        case "general_plan":
        default:
            modeSpecificInstructions = """
The user provided a general plan. Input: "$userInput"
Break this into approximately $numSubquests logical sub-quests.
For each sub-quest, suggest 1-3 smaller, concrete steps (sub-subtasks).
Make items "countable" with "targetCount" if they imply quantity.
""";
            break;
    }

    final String prompt = """
You are an assistant for a gamified task management app.
Main quest: "$mainTaskName" (Description: "$mainTaskDescription", Theme: "${mainTaskTheme ?? 'General'}").
AI generation mode: "$generationMode".

$modeSpecificInstructions

Provide the output as a single, valid JSON object with one key: "newSubquests".
"newSubquests" should be an array of sub-quest objects (approx $numSubquests). Each sub-quest object MUST have:
- name: string (concise name)
- isCountable: boolean
- targetCount: number (if isCountable, otherwise 0 or 1)
- subSubTasksData: array of sub-subtask objects. Each sub-subtask object must have:
  - name: string (concise name)
  - isCountable: boolean
  - targetCount: number (if isCountable, otherwise 0 or 1)

Example JSON:
{
  "newSubquests": [
    {
      "name": "Understand Chapter 1 Concepts",
      "isCountable": false,
      "targetCount": 0,
      "subSubTasksData": [
        { "name": "Read pages 1-10", "isCountable": true, "targetCount": 10 },
        { "name": "Summarize key points", "isCountable": false, "targetCount": 1 }
      ]
    }
  ]
}
Create actionable, distinct sub-quests and steps. Ensure names are clear.
If user input is vague for $numSubquests, generate fewer, meaningful ones.
Return ONLY the JSON object, no markdown or comments. NO TRAILING COMMAS.
""";
    try {
      final Map<String, dynamic> rawData = await _makeAICall(
        prompt: prompt,
        currentApiKeyIndex: currentApiKeyIndex,
        onNewApiKeyIndex: onNewApiKeyIndex,
        onLog: onLog,
      );
      final List<Map<String, dynamic>> newSubquests = (rawData['newSubquests'] as List?)
          ?.map((sq) => sq as Map<String, dynamic>).toList() ?? [];

      // Basic validation
      bool isValid = newSubquests.every((sq) =>
        sq['name'] is String &&
        sq['isCountable'] is bool &&
        sq['targetCount'] is num &&
        sq['subSubTasksData'] is List &&
        (sq['subSubTasksData'] as List).every((sss) =>
            sss['name'] is String &&
            sss['isCountable'] is bool &&
            sss['targetCount'] is num
        )
      );

      if (!isValid) {
        onLog("<span style=\"color:var(--fh-accent-orange);\">AI subquest response malformed.</span>");
        if (kDebugMode) {
          print("[AIService] Malformed subquest data: $newSubquests");
        }
        throw Exception("AI subquest response malformed.");
      }
      onLog("AI subquest generation successful. Parsed ${newSubquests.length} subquests.");
      return newSubquests;

    } catch (e) {
      onLog("<span style=\"color:var(--fh-accent-red);\">AI Call failed for generateAISubquests: ${e.toString()}</span>");
      if (kDebugMode) {
        print("[AIService] generateAISubquests caught error: $e");
      }
      rethrow;
    }
  }
}
--- END OF FILE lib/src/services/ai_service.dart ---

--- START OF FILE lib/src/services/storage_service.dart ---
import 'package:cloud_firestore/cloud_firestore.dart';

const String _userCollection = 'users';
const String _userSubcollectionDocId = 'data';
const String _gameStateDocId = 'gameState';

class StorageService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  DocumentReference<Map<String, dynamic>> _userDocRef(String userId) {
    return _firestore
        .collection(_userCollection)
        .doc(userId)
        .collection(_userSubcollectionDocId)
        .doc(_gameStateDocId);
  }

  Future<Map<String, dynamic>?> getUserData(String userId) async {
    if (userId.isEmpty) {
      // print("StorageService Error: userId is required for getUserData.");
      return null;
    }
    try {
      final docSnap = await _userDocRef(userId).get();
      if (docSnap.exists) {
        return docSnap.data();
      } else {
        // print("No game data found for user $userId, will initialize.");
        return null; // Indicates no data, GameProvider will initialize
      }
    } catch (e) {
      // print("Error getting user data from Firestore: $e");
      return null;
    }
  }

  Future<bool> setUserData(String userId, Map<String, dynamic> data) async {
     if (userId.isEmpty) {
      // print("StorageService Error: userId is required for setUserData.");
      return false;
    }
    try {
      await _userDocRef(userId).set(data);
      return true;
    } catch (e) {
      // print("Error setting user data in Firestore: $e");
      return false;
    }
  }

  Future<bool> updateUserData(String userId, Map<String, dynamic> partialData) async {
     if (userId.isEmpty) {
      // print("StorageService Error: userId is required for updateUserData.");
      return false;
    }
    try {
      await _userDocRef(userId).update(partialData);
      return true;
    } catch (e) {
      // print("Error updating user data in Firestore: $e");
      // If the document doesn't exist, update will fail.
      // Consider checking doc existence or using set with merge:true if needed.
      return false;
    }
  }

  Future<bool> deleteUserData(String userId) async {
     if (userId.isEmpty) {
      // print("StorageService Error: userId is required for deleteUserData.");
      return false;
    }
    try {
      await _userDocRef(userId).delete();
      // print("Game data deleted for user $userId.");
      return true;
    } catch (e) {
      // print("Error deleting user data from Firestore: $e");
      return false;
    }
  }
}
--- END OF FILE lib/src/services/storage_service.dart ---

--- START OF FILE lib/src/services/firebase_service.dart ---
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

// This file primarily exports instances. Initialization happens in main.dart.
// Specific service methods (like wrappers around auth or firestore calls)
// can be added here if desired, but GameProvider will mostly use these directly.

final FirebaseAuth firebaseAuthInstance = FirebaseAuth.instance;
final FirebaseFirestore firestoreInstance = FirebaseFirestore.instance;

// Example of a user helper, though GameProvider will handle most auth state
Stream<User?> get authStateChanges => firebaseAuthInstance.authStateChanges();

Future<User?> signInWithEmail(String email, String password) async {
  try {
    UserCredential userCredential = await firebaseAuthInstance.signInWithEmailAndPassword(
      email: email,
      password: password,
    );
    return userCredential.user;
  } on FirebaseAuthException catch (e) { // Catch specific exception
    print('[FirebaseService] signInWithEmail error: Code: ${e.code}, Message: ${e.message}'); // DEBUG
    rethrow; // Rethrow to be caught by UI or provider
  } catch (e) { // Catch generic errors
    print('[FirebaseService] signInWithEmail generic error: $e'); // DEBUG
    rethrow;
  }
}

Future<User?> signUpWithEmail(String email, String password) async {
  try {
    UserCredential userCredential = await firebaseAuthInstance.createUserWithEmailAndPassword(
      email: email,
      password: password,
    );
    return userCredential.user;
  } on FirebaseAuthException catch (e) { // Catch specific exception
    print('[FirebaseService] signUpWithEmail error: Code: ${e.code}, Message: ${e.message}'); // DEBUG
    rethrow;
  } catch (e) { // Catch generic errors
    print('[FirebaseService] signUpWithEmail generic error: $e'); // DEBUG
    rethrow;
  }
}

Future<void> signOut() async {
  try {
    await firebaseAuthInstance.signOut();
  } on FirebaseAuthException catch (e) {
     print('[FirebaseService] signOut error: Code: ${e.code}, Message: ${e.message}'); // DEBUG
     rethrow;
  } catch (e) {
     print('[FirebaseService] signOut generic error: $e'); // DEBUG
     rethrow;
  }
}

Future<void> changePassword(String newPassword) async {
  User? user = firebaseAuthInstance.currentUser;
  if (user != null) {
    try {
      await user.updatePassword(newPassword);
    } on FirebaseAuthException catch (e) { // Catch specific exception
       print('[FirebaseService] changePassword error: Code: ${e.code}, Message: ${e.message}'); // DEBUG
       rethrow;
    } catch (e) { // Catch generic errors
       print('[FirebaseService] changePassword generic error: $e'); // DEBUG
       rethrow;
    }
  } else {
    throw FirebaseAuthException(message: "No user currently signed in.", code: "no-user");
  }
}
--- END OF FILE lib/src/services/firebase_service.dart ---

--- START OF FILE lib/src/models/game_models.dart ---
// lib/src/models/game_models.dart
// import 'package:myapp_flutter/src/utils/constants.dart'; // No longer needed here for constants
import 'package:collection/collection.dart'; // For firstWhereOrNull
import 'package:flutter/material.dart'; // For Color
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart'; // For MdiIcons

class MainTask {
  String id;
  String name;
  String description;
  String theme;
  String colorHex; // e.g., "FF64FFDA"
  int streak;
  int dailyTimeSpent;
  String? lastWorkedDate;
  List<SubTask> subTasks;

  MainTask({
    required this.id,
    required this.name,
    required this.description,
    required this.theme,
    this.colorHex = "FF00F8F8", // Default to a vibrant cyan
    this.streak = 0,
    this.dailyTimeSpent = 0,
    this.lastWorkedDate,
    List<SubTask>? subTasks,
  }) : subTasks = subTasks ?? [];

  // Factory from MainTaskTemplate (which is now in this file)
  factory MainTask.fromTemplate(MainTaskTemplate template) {
    return MainTask(
      id: template.id,
      name: template.name,
      description: template.description,
      theme: template.theme,
      colorHex: template.colorHex,
    );
  }

  factory MainTask.fromJson(Map<String, dynamic> json) {
    return MainTask(
      id: json['id'] as String,
      name: json['name'] as String,
      description: json['description'] as String,
      theme: json['theme'] as String,
      colorHex: json['colorHex'] as String? ?? "FF00F8F8",
      streak: json['streak'] as int? ?? 0,
      dailyTimeSpent: json['dailyTimeSpent'] as int? ?? 0,
      lastWorkedDate: json['lastWorkedDate'] as String?,
      subTasks: (json['subTasks'] as List<dynamic>?)
              ?.map((stJson) => SubTask.fromJson(stJson as Map<String, dynamic>))
              .toList() ??
          [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'theme': theme,
      'colorHex': colorHex,
      'streak': streak,
      'dailyTimeSpent': dailyTimeSpent,
      'lastWorkedDate': lastWorkedDate,
      'subTasks': subTasks.map((st) => st.toJson()).toList(),
    };
  }

  Color get taskColor {
    try {
      return Color(int.parse("0x$colorHex"));
    } catch (e) {
      return AppTheme.fhAccentTealFixed; // Fallback color
    }
  }
}

class SubTask {
  String id;
  String name;
  bool completed;
  int currentTimeSpent; // Storing as minutes
  String? completedDate;
  bool isCountable;
  int targetCount;
  int currentCount;
  List<SubSubTask> subSubTasks;

  SubTask({
    required this.id,
    required this.name,
    this.completed = false,
    this.currentTimeSpent = 0,
    this.completedDate,
    this.isCountable = false,
    this.targetCount = 0,
    this.currentCount = 0,
    List<SubSubTask>? subSubTasks,
  }) : subSubTasks = subSubTasks ?? [];

  factory SubTask.fromJson(Map<String, dynamic> json) {
    return SubTask(
      id: json['id'] as String,
      name: json['name'] as String,
      completed: json['completed'] as bool? ?? false,
      currentTimeSpent: json['currentTimeSpent'] as int? ?? 0,
      completedDate: json['completedDate'] as String?,
      isCountable: json['isCountable'] as bool? ?? false,
      targetCount: json['targetCount'] as int? ?? 0,
      currentCount: json['currentCount'] as int? ?? 0,
      subSubTasks: (json['subSubTasks'] as List<dynamic>?)
              ?.map((sssJson) => SubSubTask.fromJson(sssJson as Map<String, dynamic>))
              .toList() ??
          [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'completed': completed,
      'currentTimeSpent': currentTimeSpent,
      'completedDate': completedDate,
      'isCountable': isCountable,
      'targetCount': targetCount,
      'currentCount': currentCount,
      'subSubTasks': subSubTasks.map((sss) => sss.toJson()).toList(),
    };
  }
}

class SubSubTask {
  String id;
  String name;
  bool completed;
  bool isCountable;
  int targetCount;
  int currentCount;

  SubSubTask({
    required this.id,
    required this.name,
    this.completed = false,
    this.isCountable = false,
    this.targetCount = 0,
    this.currentCount = 0,
  });

  factory SubSubTask.fromJson(Map<String, dynamic> json) {
    return SubSubTask(
      id: json['id'] as String,
      name: json['name'] as String,
      completed: json['completed'] as bool? ?? false,
      isCountable: json['isCountable'] as bool? ?? false,
      targetCount: json['targetCount'] as int? ?? 0,
      currentCount: json['currentCount'] as int? ?? 0,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'completed': completed,
      'isCountable': isCountable,
      'targetCount': targetCount,
      'currentCount': currentCount,
    };
  }
}

class OwnedArtifact {
  String uniqueId;
  String templateId;
  int currentLevel;
  int? uses;

  OwnedArtifact({
    required this.uniqueId,
    required this.templateId,
    required this.currentLevel,
    this.uses,
  });

  factory OwnedArtifact.fromJson(Map<String, dynamic> json) {
    return OwnedArtifact(
      uniqueId: json['uniqueId'] as String,
      templateId: json['templateId'] as String,
      currentLevel: json['currentLevel'] as int,
      uses: json['uses'] as int?,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'uniqueId': uniqueId,
      'templateId': templateId,
      'currentLevel': currentLevel,
      'uses': uses,
    };
  }
}

class CurrentGame {
  EnemyTemplate? enemy;
  double playerCurrentHp;
  List<String> log;
  String? currentPlaceKey; 

  CurrentGame({
    this.enemy,
    required this.playerCurrentHp,
    List<String>? log,
    this.currentPlaceKey,
  }) : log = log ?? [];

  factory CurrentGame.fromJson(Map<String, dynamic> json, List<EnemyTemplate> allEnemyTemplates) {
    EnemyTemplate? currentEnemy;
    if (json['enemy'] != null) {
      final enemyData = json['enemy'] as Map<String, dynamic>;
      currentEnemy = allEnemyTemplates.firstWhereOrNull((t) => t.id == enemyData['id']) ?? EnemyTemplate.fromJson(enemyData);
    }
    return CurrentGame(
      enemy: currentEnemy,
      playerCurrentHp: (json['playerCurrentHp'] as num).toDouble(),
      log: (json['log'] as List<dynamic>?)?.map((entry) => entry as String).toList() ?? [],
      currentPlaceKey: json['currentPlaceKey'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'enemy': enemy?.toJson(),
      'playerCurrentHp': playerCurrentHp,
      'log': log,
      'currentPlaceKey': currentPlaceKey,
    };
  }
}

class GameSettings {
  bool descriptionsVisible;
  bool autoGenerateContent;

  GameSettings({this.descriptionsVisible = true, this.autoGenerateContent = true});

  factory GameSettings.fromJson(Map<String, dynamic> json) {
    return GameSettings(
      descriptionsVisible: json['descriptionsVisible'] as bool? ?? true,
      autoGenerateContent: json['autoGenerateContent'] as bool? ?? true,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'descriptionsVisible': descriptionsVisible,
      'autoGenerateContent': autoGenerateContent,
    };
  }
}

class ActiveTimerInfo {
  DateTime startTime;
  double accumulatedDisplayTime; // In seconds
  bool isRunning;
  String type;
  String mainTaskId;

  ActiveTimerInfo({
    required this.startTime,
    this.accumulatedDisplayTime = 0,
    required this.isRunning,
    required this.type,
    required this.mainTaskId,
  });

  factory ActiveTimerInfo.fromJson(Map<String, dynamic> json) {
    return ActiveTimerInfo(
      startTime: DateTime.parse(json['startTime'] as String),
      accumulatedDisplayTime: (json['accumulatedDisplayTime'] as num? ?? 0).toDouble(),
      isRunning: json['isRunning'] as bool? ?? false,
      type: json['type'] as String? ?? 'subtask',
      mainTaskId: json['mainTaskId'] as String? ?? '',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'startTime': startTime.toIso8601String(),
      'accumulatedDisplayTime': accumulatedDisplayTime,
      'isRunning': isRunning,
      'type': type,
      'mainTaskId': mainTaskId,
    };
  }
}

class PlayerStat {
  final String name;
  final String description;
  final String icon; // Can be an emoji or an MDI icon name (e.g., "mdi-sword")
  double value;
  double base;

  PlayerStat({
    required this.name,
    required this.description,
    required this.icon,
    required this.value,
    required this.base,
  });

  factory PlayerStat.fromJson(Map<String, dynamic> json) {
    double parseNumToDouble(dynamic val, double defaultValue) {
      if (val == null) return defaultValue;
      if (val is num) return val.toDouble();
      if (val is String) return double.tryParse(val) ?? defaultValue;
      return defaultValue;
    }
    String parseString(dynamic val, String defaultValue) {
      if (val == null) return defaultValue;
      if (val is String) return val;
      return val.toString();
    }
    return PlayerStat(
      name: parseString(json['name'], 'Unknown Stat'),
      description: parseString(json['description'], 'No description.'),
      icon: parseString(json['icon'], MdiIcons.helpCircleOutline.codePoint.toString()), // Use MDI icon as string default
      value: parseNumToDouble(json['value'], 0.0),
      base: parseNumToDouble(json['base'], 0.0),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'description': description,
      'icon': icon,
      'value': value,
      'base': base,
    };
  }
}

class ArtifactTemplate {
  final String id;
  final String name;
  final String type; 
  final String? theme;
  final String description;
  final int cost;
  final String icon; // Can be an emoji or an MDI icon name
  final int? baseAtt;
  final int? baseRunic;
  final int? baseDef;
  final int? baseHealth;
  final int? baseLuck; 
  final int? baseCooldown; 
  final double? bonusXPMod; 
  final Map<String, int>? upgradeBonus; 
  final int? maxLevel;
  final String? effectType; 
  final int? effectValue;
  final int? uses;

  ArtifactTemplate({
    required this.id,
    required this.name,
    required this.type,
    this.theme,
    required this.description,
    required this.cost,
    required this.icon,
    this.baseAtt,
    this.baseRunic,
    this.baseDef,
    this.baseHealth,
    this.baseLuck,
    this.baseCooldown,
    this.bonusXPMod,
    this.upgradeBonus,
    this.maxLevel,
    this.effectType,
    this.effectValue,
    this.uses,
  });

  factory ArtifactTemplate.fromJson(Map<String, dynamic> json) {
    Map<String, int>? parsedUpgradeBonus;
    if (json['upgradeBonus'] != null && json['upgradeBonus'] is Map) {
      parsedUpgradeBonus = {};
      try {
        (json['upgradeBonus'] as Map<String, dynamic>).forEach((key, value) {
          if (value is num) {
            parsedUpgradeBonus![key] = value.toInt();
          } else if (value is String) parsedUpgradeBonus![key] = int.tryParse(value) ?? 0;
        });
      } catch (e) { /* ... */ }
    }
    int? parseInt(dynamic val) {
      if (val == null) return null;
      if (val is int) return val;
      if (val is double) return val.toInt();
      if (val is String) return int.tryParse(val);
      return null;
    }
    double? parseDouble(dynamic val) {
      if (val == null) return null;
      if (val is double) return val;
      if (val is int) return val.toDouble();
      if (val is String) return double.tryParse(val);
      return null;
    }
    return ArtifactTemplate(
      id: json['id'] as String? ?? 'unknown_id_${DateTime.now().millisecondsSinceEpoch}',
      name: json['name'] as String? ?? 'Unknown Artifact',
      type: json['type'] as String? ?? 'unknown',
      theme: json['theme'] as String?,
      description: json['description'] as String? ?? 'No description.',
      cost: parseInt(json['cost']) ?? 0,
      icon: json['icon'] as String? ?? MdiIcons.treasureChest.codePoint.toString(), // Default to MDI icon string
      baseAtt: parseInt(json['baseAtt']),
      baseRunic: parseInt(json['baseRunic']),
      baseDef: parseInt(json['baseDef']),
      baseHealth: parseInt(json['baseHealth']),
      baseLuck: parseInt(json['baseLuck']),
      baseCooldown: parseInt(json['baseCooldown']),
      bonusXPMod: parseDouble(json['bonusXPMod']),
      upgradeBonus: parsedUpgradeBonus,
      maxLevel: parseInt(json['maxLevel']),
      effectType: json['effectType'] as String?,
      effectValue: parseInt(json['effectValue']),
      uses: parseInt(json['uses']),
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id, 'name': name, 'type': type, 'theme': theme, 'description': description,
      'cost': cost, 'icon': icon, 'baseAtt': baseAtt, 'baseRunic': baseRunic, 'baseDef': baseDef,
      'baseHealth': baseHealth, 'baseLuck': baseLuck, 'baseCooldown': baseCooldown,
      'bonusXPMod': bonusXPMod, 'upgradeBonus': upgradeBonus, 'maxLevel': maxLevel,
      'effectType': effectType, 'effectValue': effectValue, 'uses': uses,
    };
  }
}

class EnemyTemplate {
  final String id;
  final String name;
  final String? theme;
  final String? locationKey; 
  final int minPlayerLevel;
  final int health; 
  final int attack;
  final int defense;
  int hp; 
  final int coinReward;
  final int xpReward;
  final String description;

  EnemyTemplate({
    required this.id,
    required this.name,
    this.theme,
    this.locationKey,
    required this.minPlayerLevel,
    required this.health,
    required this.attack,
    required this.defense,
    int? hp, 
    required this.coinReward,
    required this.xpReward,
    required this.description,
  }) : hp = hp ?? health; 

  factory EnemyTemplate.fromJson(Map<String, dynamic> json) {
    int? parseInt(dynamic val) {
      if (val == null) return null;
      if (val is int) return val;
      if (val is double) return val.toInt();
      if (val is String) return int.tryParse(val);
      return null;
    }
    final maxHealth = parseInt(json['health']) ?? 10;
    return EnemyTemplate(
      id: json['id'] as String? ?? 'unknown_enemy_${DateTime.now().millisecondsSinceEpoch}',
      name: json['name'] as String? ?? 'Nameless Foe',
      theme: json['theme'] as String?,
      locationKey: json['locationKey'] as String?,
      minPlayerLevel: parseInt(json['minPlayerLevel']) ?? 1,
      health: maxHealth,
      hp: parseInt(json['hp']) ?? maxHealth,
      attack: parseInt(json['attack']) ?? 1,
      defense: parseInt(json['defense']) ?? 0,
      coinReward: parseInt(json['coinReward']) ?? 0,
      xpReward: parseInt(json['xpReward']) ?? 0,
      description: json['description'] as String? ?? 'A mysterious enemy.',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id, 'name': name, 'theme': theme, 'locationKey': locationKey,
      'minPlayerLevel': minPlayerLevel, 'health': health, 'hp': hp,
      'attack': attack, 'defense': defense, 'coinReward': coinReward,
      'xpReward': xpReward, 'description': description,
    };
  }
}

class Rune {
  String id;
  String name;
  String description;
  String icon; 
  String type; 
  String effectType; 
  double effectValue; 
  double? effectDuration; 
  String? targetStat; 
  int cost; 
  int? requiredLevel;

  Rune({
    required this.id,
    required this.name,
    required this.description,
    required this.icon,
    required this.type,
    required this.effectType,
    required this.effectValue,
    this.effectDuration,
    this.targetStat,
    required this.cost,
    this.requiredLevel,
  });

  factory Rune.fromJson(Map<String, dynamic> json) {
    return Rune(
      id: json['id'] as String,
      name: json['name'] as String,
      description: json['description'] as String,
      icon: json['icon'] as String,
      type: json['type'] as String,
      effectType: json['effectType'] as String,
      effectValue: (json['effectValue'] as num).toDouble(),
      effectDuration: (json['effectDuration'] as num?)?.toDouble(),
      targetStat: json['targetStat'] as String?,
      cost: json['cost'] as int,
      requiredLevel: json['requiredLevel'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'icon': icon,
      'type': type,
      'effectType': effectType,
      'effectValue': effectValue,
      'effectDuration': effectDuration,
      'targetStat': targetStat,
      'cost': cost,
      'requiredLevel': requiredLevel,
    };
  }
}

class OwnedRune {
  String uniqueId;
  String runeId; 
  bool isActive; 

  OwnedRune({
    required this.uniqueId,
    required this.runeId,
    this.isActive = false,
  });

   factory OwnedRune.fromJson(Map<String, dynamic> json) {
    return OwnedRune(
      uniqueId: json['uniqueId'] as String,
      runeId: json['runeId'] as String,
      isActive: json['isActive'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'uniqueId': uniqueId,
      'runeId': runeId,
      'isActive': isActive,
    };
  }
}

// Moved from constants.dart
class MainTaskTemplate {
  final String id;
  final String name;
  final String description;
  final String theme;
  final String colorHex; 

  MainTaskTemplate({
    required this.id,
    required this.name,
    required this.description,
    required this.theme,
    this.colorHex = "FF00F8F8", // Default Cyan
  });
}

// Moved from constants.dart
class GameLocation {
  final String id; // Changed key to id for consistency
  final String name;
  final String description;
  final int minPlayerLevelToUnlock;
  final String iconEmoji; // Using specific field for emoji
  final String? associatedTheme;
  final String? bossEnemyIdToUnlockNextLocation; // ID of an enemy in this location

  GameLocation({
    required this.id,
    required this.name,
    required this.description,
    this.minPlayerLevelToUnlock = 1,
    required this.iconEmoji,
    this.associatedTheme,
    this.bossEnemyIdToUnlockNextLocation,
  });

  factory GameLocation.fromJson(Map<String, dynamic> json) {
    return GameLocation(
      id: json['id'] as String? ?? 'loc_${DateTime.now().millisecondsSinceEpoch}',
      name: json['name'] as String? ?? 'Unknown Area',
      description: json['description'] as String? ?? 'A mysterious place.',
      minPlayerLevelToUnlock: json['minPlayerLevelToUnlock'] as int? ?? 1,
      iconEmoji: json['iconEmoji'] as String? ?? '❓',
      associatedTheme: json['associatedTheme'] as String?,
      bossEnemyIdToUnlockNextLocation: json['bossEnemyIdToUnlockNextLocation'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'minPlayerLevelToUnlock': minPlayerLevelToUnlock,
      'iconEmoji': iconEmoji,
      'associatedTheme': associatedTheme,
      'bossEnemyIdToUnlockNextLocation': bossEnemyIdToUnlockNextLocation,
    };
  }
}
--- END OF FILE lib/src/models/game_models.dart ---

--- START OF FILE lib/src/config/api_keys.dart ---
// lib/src/config/api_keys.dart
// IMPORTANT: Add this file to your .gitignore
// ignore_for_file: constant_identifier_names
const List<String> geminiApiKeys = ['AIzaSyAjyofndMStYX6AT_C8CIBj-GZZeObA0PQ','AIzaSyAu9swfNci4KFg63TjnxoV9zCfwXz9wuuA','AIzaSyB97ORZRyH0Ke154I8WjvhD5G-WUTIuDd4','AIzaSyB97ORZRyH0Ke154I8WjvhD5G-WUTIuDd4','AIzaSyB97ORZRyH0Ke154I8WjvhD5G-WUTIuDd4'];

const String geminiModelName = 'gemini-2.0-flash'; // Updated to consistent model name
--- END OF FILE lib/src/config/api_keys.dart ---

--- START OF FILE lib/src/theme/app_theme.dart ---
import 'package:flutter/material.dart';

class AppTheme {
  // Valorant-inspired color palette (BASE colors)
  static const Color fhBgDeepDark = Color(0xFF0F1923); 
  static const Color fhBgDark = Color(0xFF1A2838); 
  static const Color fhBgMedium = Color(0xFF203040); 
  static const Color fhBgLight = Color(0xFF2C3E50); 
  static const Color fhBorderColor = Color(0xFF384B5F); 

  static const Color fhTextPrimary = Color(0xFFEAEAEA); 
  static const Color fhTextSecondary = Color(0xFFB0B8C0); 
  static const Color fhTextDisabled = Color(0xFF707880);

  // Fixed accents (won't change with task theme)
  static const Color fhAccentRed = Color(0xFFFD4556); // Valorant Red (e.g., for errors, critical actions)
  static const Color fhAccentTealFixed = Color(0xFF00F8F8); 
  static const Color fhAccentTeal = Color(0xFF00F8F8); // Default system teal (can be used if no task color)
  static const Color fhAccentGold = Color(0xFFFFE075); 
  static const Color fhAccentPurple = Color(0xFF8A2BE2); 
  static const Color fhAccentGreen = Color(0xFF4CAF50); 
  static const Color fhAccentOrange = Color(0xFFFF7043); 

  static const String fontDisplay = 'RobotoCondensed'; 
  static const String fontBody = 'OpenSans';

  // Method to generate ThemeData with a dynamic primary accent color
  static ThemeData getThemeData({required Color primaryAccent}) {
    final Brightness accentBrightness = ThemeData.estimateBrightnessForColor(primaryAccent);
    final Color onPrimaryAccent = accentBrightness == Brightness.dark ? fhTextPrimary : fhBgDark;

    return ThemeData(
      brightness: Brightness.dark,
      primaryColor: primaryAccent, // Dynamic primary accent
      scaffoldBackgroundColor: fhBgDeepDark,

      colorScheme: ColorScheme.dark(
        primary: primaryAccent, // Dynamic primary accent
        secondary: primaryAccent, // Also use dynamic accent for secondary for consistency
        surface: fhBgDark, 
        error: fhAccentRed,
        onPrimary: onPrimaryAccent, // Text on dynamic primary accent
        onSecondary: onPrimaryAccent, // Text on dynamic secondary accent
        onSurface: fhTextPrimary, 
        onError: fhTextPrimary,
      ),

      fontFamily: fontBody,

      appBarTheme: AppBarTheme(
        backgroundColor: fhBgDark, 
        elevation: 0, 
        centerTitle: true,
        iconTheme: const IconThemeData(color: fhTextSecondary, size: 22),
        titleTextStyle: TextStyle(
          fontFamily: fontDisplay,
          color: fhTextPrimary,
          fontWeight: FontWeight.bold,
          fontSize: 20, 
          letterSpacing: 1.1,
        ),
      ),

      textTheme: TextTheme(
        displayLarge: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontWeight: FontWeight.bold, fontSize: 48, letterSpacing: 1.2),
        displayMedium: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontWeight: FontWeight.bold, fontSize: 36, letterSpacing: 1.1),
        displaySmall: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontWeight: FontWeight.w600, fontSize: 28),
        headlineLarge: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontWeight: FontWeight.bold, fontSize: 22),
        headlineMedium: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontWeight: FontWeight.w600, fontSize: 20),
        headlineSmall: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontWeight: FontWeight.w500, fontSize: 18),
        titleLarge: TextStyle(fontFamily: fontBody, color: fhTextPrimary, fontWeight: FontWeight.bold, fontSize: 16),
        titleMedium: TextStyle(fontFamily: fontBody, color: fhTextPrimary, fontWeight: FontWeight.w500, fontSize: 14),
        titleSmall: TextStyle(fontFamily: fontBody, color: fhTextSecondary, fontSize: 12, fontWeight: FontWeight.w400),
        bodyLarge: TextStyle(fontFamily: fontBody, color: fhTextPrimary, fontSize: 15, height: 1.5),
        bodyMedium: TextStyle(fontFamily: fontBody, color: fhTextSecondary, fontSize: 13, height: 1.4),
        bodySmall: TextStyle(fontFamily: fontBody, color: fhTextSecondary, fontSize: 11, height: 1.3),
        labelLarge: TextStyle(fontFamily: fontBody, color: onPrimaryAccent, fontWeight: FontWeight.bold, letterSpacing: 1, fontSize: 14), 
        labelMedium: TextStyle(fontFamily: fontBody, color: fhTextSecondary, letterSpacing: 0.8, fontSize: 12),
        labelSmall: TextStyle(fontFamily: fontBody, color: fhTextSecondary, letterSpacing: 0.5, fontSize: 10),
      ),

      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: primaryAccent, // Dynamic accent for buttons
          foregroundColor: onPrimaryAccent,
          textStyle: TextStyle(fontFamily: fontBody, fontWeight: FontWeight.bold, fontSize: 14, letterSpacing: 0.8),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4.0)),
          elevation: 2,
        ),
      ),

      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          side: BorderSide(color: primaryAccent, width: 1.5), // Dynamic accent
          foregroundColor: primaryAccent, // Dynamic accent
          textStyle: TextStyle(fontFamily: fontBody, fontWeight: FontWeight.bold, fontSize: 14, letterSpacing: 0.8),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4.0)),
        ),
      ),

      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: primaryAccent, // Dynamic accent
          textStyle: TextStyle(fontFamily: fontBody, fontSize: 13, fontWeight: FontWeight.w600),
        ),
      ),

      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: fhBgMedium.withOpacity(0.8),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        hintStyle: TextStyle(color: fhTextSecondary.withOpacity(0.7), fontFamily: fontBody, fontSize: 13),
        labelStyle: TextStyle(color: fhTextSecondary, fontFamily: fontBody, fontSize: 14),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(4.0),
          borderSide: const BorderSide(color: fhBorderColor, width: 1.0),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(4.0),
          borderSide: const BorderSide(color: fhBorderColor, width: 1.0),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(4.0),
          borderSide: BorderSide(color: primaryAccent, width: 1.5), // Dynamic accent
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(4.0),
          borderSide: BorderSide(color: fhAccentRed.withOpacity(0.7), width: 1.0),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(4.0),
          borderSide: const BorderSide(color: fhAccentRed, width: 1.5),
        ),
        prefixIconColor: fhTextSecondary,
        suffixIconColor: fhTextSecondary,
      ),

      progressIndicatorTheme: ProgressIndicatorThemeData(
        color: primaryAccent, // Dynamic accent for progress
        linearTrackColor: fhBgMedium,
        circularTrackColor: fhBgMedium,
        linearMinHeight: 5,
      ),

      chipTheme: ChipThemeData(
        backgroundColor: fhBgMedium,
        labelStyle: TextStyle(color: fhTextPrimary, fontFamily: fontBody, fontSize: 11),
        selectedColor: primaryAccent, // Dynamic accent
        secondarySelectedColor: primaryAccent.withOpacity(0.7), // Dynamic accent
        disabledColor: fhBorderColor.withOpacity(0.5),
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
        side: BorderSide(color: fhBorderColor.withOpacity(0.3)),
      ),

      tabBarTheme: TabBarThemeData(
        labelColor: primaryAccent, // Dynamic accent
        unselectedLabelColor: fhTextSecondary,
        indicator: UnderlineTabIndicator(
          borderSide: BorderSide(color: primaryAccent, width: 2.0), // Dynamic accent
        ),
        labelStyle: TextStyle(fontFamily: fontDisplay, fontWeight: FontWeight.bold, fontSize: 13, letterSpacing: 0.5),
        unselectedLabelStyle: TextStyle(fontFamily: fontDisplay, fontWeight: FontWeight.w500, fontSize: 13, letterSpacing: 0.5),
        indicatorSize: TabBarIndicatorSize.label,
      ),

      iconTheme: const IconThemeData(
        color: fhTextSecondary,
        size: 20,
      ),

      tooltipTheme: TooltipThemeData(
        preferBelow: false,
        textStyle: TextStyle(fontSize: 11, color: fhBgDark, fontFamily: fontBody),
        decoration: BoxDecoration(
          color: fhAccentGold.withOpacity(0.95),
          borderRadius: BorderRadius.circular(4),
        ),
      ),

      dividerTheme: DividerThemeData(
        color: fhBorderColor.withOpacity(0.5),
        thickness: 1,
        space: 1,
      ),

      cardTheme: CardThemeData(
        color: fhBgDark, 
        elevation: 0, 
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(2.0), 
          side: BorderSide(color: fhBorderColor.withOpacity(0.4), width: 1),
        ),
        margin: const EdgeInsets.symmetric(vertical: 6, horizontal: 0),
      ),

      listTileTheme: ListTileThemeData(
        iconColor: fhTextSecondary,
        textColor: fhTextPrimary,
        tileColor: Colors.transparent, 
        selectedTileColor: primaryAccent.withOpacity(0.1), // Dynamic accent
        titleTextStyle: TextStyle(fontFamily: fontBody, fontSize: 14, fontWeight: FontWeight.w500),
        subtitleTextStyle: TextStyle(fontFamily: fontBody, fontSize: 12, color: fhTextSecondary),
        minVerticalPadding: 12,
      ),

      switchTheme: SwitchThemeData(
        thumbColor: WidgetStateProperty.resolveWith<Color?>((Set<WidgetState> states) {
          if (states.contains(WidgetState.selected)) {
            return primaryAccent; // Dynamic accent
          }
          return fhTextSecondary.withOpacity(0.6);
        }),
        trackColor: WidgetStateProperty.resolveWith<Color?>((Set<WidgetState> states) {
          if (states.contains(WidgetState.selected)) {
            return primaryAccent.withOpacity(0.3); // Dynamic accent
          }
          return fhBorderColor.withOpacity(0.3);
        }),
        trackOutlineColor: WidgetStateProperty.all(Colors.transparent),
      ),

      dialogTheme: DialogThemeData(
        backgroundColor: fhBgMedium,
        titleTextStyle: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontSize: 20, fontWeight: FontWeight.w600),
        contentTextStyle: TextStyle(fontFamily: fontBody, color: fhTextPrimary, fontSize: 14),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4.0)),
        elevation: 5,
      ),
      
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
          backgroundColor: fhBgDeepDark,
          selectedItemColor: primaryAccent, // Dynamic Accent
          unselectedItemColor: fhTextSecondary.withOpacity(0.8),
          selectedLabelStyle: TextStyle(fontSize: 10, fontFamily: fontBody, fontWeight: FontWeight.bold, letterSpacing: 0.5),
          unselectedLabelStyle: TextStyle(fontSize: 10, fontFamily: fontBody, letterSpacing: 0.5),
          type: BottomNavigationBarType.fixed,
          elevation: 0,
      ),
    );
  }
}
--- END OF FILE lib/src/theme/app_theme.dart ---

--- START OF FILE lib/src/providers/game_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:myapp_flutter/src/services/firebase_service.dart' as fb_service;
import 'package:myapp_flutter/src/services/storage_service.dart';
import 'package:myapp_flutter/src/utils/constants.dart';
import 'package:myapp_flutter/src/utils/helpers.dart' as helper;
import 'package:firebase_auth/firebase_auth.dart';
import 'package:intl/intl.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:collection/collection.dart';
import 'dart:async';

import 'package:myapp_flutter/src/models/game_models.dart';

import 'actions/task_actions.dart';
import 'actions/item_actions.dart';
import 'actions/combat_actions.dart';
import 'actions/ai_generation_actions.dart';
import 'actions/timer_actions.dart';


class GameProvider with ChangeNotifier {
  final StorageService _storageService = StorageService();
  Timer? _periodicUiTimer;
  Timer? _autoSaveTimer;

  User? _currentUser;
  User? get currentUser => _currentUser;
  bool _authLoading = true;
  bool get authLoading => _authLoading;
  bool _isDataLoadingAfterLogin = false;
  bool get isDataLoadingAfterLogin => _isDataLoadingAfterLogin;
  bool _isUsernameMissing = false;
  bool get isUsernameMissing => _isUsernameMissing;


  String? _lastLoginDate;
  double _coins = 100;
  double _xp = 0;
  int _playerLevel = 1;
  double _playerEnergy = baseMaxPlayerEnergy;
  List<MainTask> _mainTasks = initialMainTaskTemplates.map((t) => MainTask.fromTemplate(t)).toList();
  Map<String, dynamic> _completedByDay = {};
  List<OwnedArtifact> _artifacts = [];
  List<ArtifactTemplate> _artifactTemplatesList = [];
  List<EnemyTemplate> _enemyTemplatesList = [];
  List<GameLocation> _gameLocationsList = []; // New list for game locations
  List<Rune> _runeTemplatesList = []; 
  List<OwnedRune> _ownedRunes = []; 

  Map<String, PlayerStat> _playerGameStats = {
    ...Map.from(basePlayerGameStats.map((key, value) => MapEntry(key, PlayerStat(name: value.name, description: value.description, icon: value.icon, value: value.value, base: value.base)))),
  };
  void _ensureBonusXpModStat() {
    if (!_playerGameStats.containsKey('bonusXPMod')) {
      _playerGameStats['bonusXPMod'] = PlayerStat(name: 'XP CALC MOD', value: 0, base: 0, description: 'Internal XP modifier from gear.', icon: 'mdi-percent-outline'); // Using MDI string
    }
  }


  Map<String, String?> _equippedItems = {'weapon': null, 'armor': null, 'talisman': null};
  Map<String, String?> _equippedRunes = {'rune_slot_1': null, 'rune_slot_2': null}; 

  List<String> _defeatedEnemyIds = [];
  CurrentGame _currentGame = CurrentGame(playerCurrentHp: basePlayerGameStats['vitality']!.value, currentPlaceKey: initialGameLocations.isNotEmpty ? initialGameLocations.first.id : null);
  GameSettings _settings = GameSettings();
  String _currentView = 'task-details';
  String? _selectedTaskId = initialMainTaskTemplates.isNotEmpty ? initialMainTaskTemplates[0].id : null;
  int _apiKeyIndex = 0;
  Map<String, ActiveTimerInfo> _activeTimers = {};

  bool _hasUnsavedChanges = false;
  bool _isManuallySaving = false;
  bool get isManuallySaving => _isManuallySaving;
  bool _isManuallyLoading = false;
  bool get isManuallyLoading => _isManuallyLoading;
  DateTime? _lastSuccessfulSaveTimestamp;
  DateTime? get lastSuccessfulSaveTimestamp => _lastSuccessfulSaveTimestamp;


  bool _isGeneratingGlobalContent = false;
  bool get isGeneratingContent => _isGeneratingGlobalContent;
  bool _isGeneratingSubquestsForTask = false;
  bool get isGeneratingSubquests => _isGeneratingSubquestsForTask;

  String? get lastLoginDate => _lastLoginDate;
  double get coins => _coins;
  double get xp => _xp;
  int get playerLevel => _playerLevel;
  double get playerEnergy => _playerEnergy;
  List<MainTask> get mainTasks => _mainTasks;
  Map<String, dynamic> get completedByDay => _completedByDay;
  List<OwnedArtifact> get artifacts => _artifacts;
  List<ArtifactTemplate> get artifactTemplatesList => _artifactTemplatesList;
  List<EnemyTemplate> get enemyTemplatesList => _enemyTemplatesList;
  List<GameLocation> get gameLocationsList => _gameLocationsList; // Getter for locations
  List<Rune> get runeTemplatesList => _runeTemplatesList;
  List<OwnedRune> get ownedRunes => _ownedRunes;

  Map<String, PlayerStat> get playerGameStats => _playerGameStats;
  Map<String, String?> get equippedItems => _equippedItems;
  Map<String, String?> get equippedRunes => _equippedRunes;

  List<String> get defeatedEnemyIds => _defeatedEnemyIds;
  CurrentGame get currentGame => _currentGame;
  GameSettings get settings => _settings;
  String get currentView => _currentView;
  String? get selectedTaskId => _selectedTaskId;
  int get apiKeyIndex => _apiKeyIndex;
  Map<String, ActiveTimerInfo> get activeTimers => _activeTimers;

  double get calculatedMaxEnergy => baseMaxPlayerEnergy + (_playerLevel - 1) * playerEnergyPerLevelVitality;
  double get xpNeededForNextLevel => helper.xpToNext(_playerLevel, xpPerLevelBase, xpLevelMultiplier);
  double get currentLevelXPStart => helper.xpForLevel(_playerLevel, xpPerLevelBase, xpLevelMultiplier);
  double get currentLevelXPProgress => _xp - currentLevelXPStart;
  double get xpProgressPercent => xpNeededForNextLevel > 0 ? (currentLevelXPProgress / xpNeededForNextLevel).clamp(0.0, 1.0) * 100 : 0;


  late final TaskActions _taskActions;
  late final ItemActions _itemActions;
  late final CombatActions _combatActions;
  late final AIGenerationActions _aiGenerationActions;
  late final TimerActions _timerActions;

  GameProvider() {
    print("[GameProvider] Constructor called. Initializing...");
    _ensureBonusXpModStat(); 
    _initialize();
    _taskActions = TaskActions(this);
    _itemActions = ItemActions(this);
    _combatActions = CombatActions(this);
    _aiGenerationActions = AIGenerationActions(this);
    _timerActions = TimerActions(this);

    _periodicUiTimer?.cancel();
    _periodicUiTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_activeTimers.values.any((info) => info.isRunning)) {
        notifyListeners();
      }
    });
    print("[GameProvider] Initialization complete.");
  }

  @override
  void dispose() {
    print("[GameProvider] dispose called.");
    _periodicUiTimer?.cancel();
    _autoSaveTimer?.cancel();
    super.dispose();
  }

  Future<void> _initialize() async { // Made async
    fb_service.authStateChanges.listen(_onAuthStateChanged);
    _autoSaveTimer?.cancel();
    _autoSaveTimer = Timer.periodic(const Duration(minutes: 1), (timer) {
      if (_hasUnsavedChanges && _currentUser != null && !_isManuallySaving && !_isManuallyLoading) {
        print("[GameProvider] Auto-saving changes...");
        _performActualSave();
      }
    });

    // Asynchronously load initial data that doesn't depend on user auth
    // to potentially speed up the perceived load time if applicable.
    // For example, if artifactTemplatesList, enemyTemplatesList, gameLocationsList
    // could be loaded from a local cache or bundled asset first.
    // For now, they are initialized from constants, which is fast.
    // If these were from a slow source, this is where you'd async it.
    // Example:
    // _artifactTemplatesList = await _loadInitialArtifactTemplatesFromAsset();
    // _enemyTemplatesList = await _loadInitialEnemyTemplatesFromAsset();
    // _gameLocationsList = await _loadInitialGameLocationsFromAsset();
    // notifyListeners(); // If UI can show something with this partial data
  }

  Future<void> _onAuthStateChanged(User? user) async {
    print("[GameProvider] _onAuthStateChanged triggered. User: ${user?.uid}");
    if (_authLoading && _currentUser != null && user != null && _currentUser!.uid == user.uid) {
        print("[GameProvider] Auth state unchanged for same user, returning.");
        return;
    }

    _authLoading = true;
    notifyListeners();

    if (user != null) {
        print("[GameProvider] User signed in: ${user.uid}. Loading data...");
        _currentUser = user;
        _isDataLoadingAfterLogin = true;
        notifyListeners();

        final data = await _storageService.getUserData(user.uid);
        if (data != null) {
            print("[GameProvider] User data found, loading state.");
            _loadStateFromMap(data);
            _hasUnsavedChanges = false;
        } else {
            print("[GameProvider] No user data found, resetting to initial state.");
            await _resetToInitialState(); // Make reset async if it involves async ops
            _lastLoginDate = helper.getTodayDateString();
            _hasUnsavedChanges = true; // Mark as changed to trigger initial save
            await _performActualSave();
        }

        _handleDailyReset();
        if (settings.autoGenerateContent && (_enemyTemplatesList.isEmpty || _artifactTemplatesList.isEmpty || _runeTemplatesList.isEmpty || _gameLocationsList.isEmpty)) {
            print("[GameProvider] Initial content generation needed.");
            // Don't await here if it blocks UI too much, let it run in background
            generateGameContent(_playerLevel, isManual: false, isInitial: true).catchError((e) {
              print("Error during initial content generation: $e");
              // Optionally log to game log
            });
        }

        if (_currentUser?.displayName == null || _currentUser!.displayName!.trim().isEmpty) {
            print("[GameProvider] Username is missing for current user.");
            _isUsernameMissing = true;
        } else {
            _isUsernameMissing = false;
        }
        _isDataLoadingAfterLogin = false;
    } else {
        print("[GameProvider] User signed out or null. Resetting state.");
        _currentUser = null;
        await _resetToInitialState(); // Make reset async
        _isDataLoadingAfterLogin = false;
        _hasUnsavedChanges = false;
    }

    _authLoading = false;
    notifyListeners();
    print("[GameProvider] _onAuthStateChanged finished. AuthLoading: $_authLoading, IsDataLoadingAfterLogin: $_isDataLoadingAfterLogin");
  }


  Map<String, dynamic> _gameStateToMap() {
    return {
      'lastLoginDate': _lastLoginDate,
      'coins': _coins,
      'xp': _xp,
      'playerLevel': _playerLevel,
      'playerEnergy': _playerEnergy,
      'mainTasks': _mainTasks.map((mt) => mt.toJson()).toList(),
      'completedByDay': _completedByDay,
      'artifacts': _artifacts.map((a) => a.toJson()).toList(),
      'artifactTemplatesList': _artifactTemplatesList.map((at) => at.toJson()).toList(),
      'enemyTemplatesList': _enemyTemplatesList.map((et) => et.toJson()).toList(),
      'gameLocationsList': _gameLocationsList.map((gl) => gl.toJson()).toList(), // Save locations
      'runeTemplatesList': _runeTemplatesList.map((rt) => rt.toJson()).toList(),
      'ownedRunes': _ownedRunes.map((or) => or.toJson()).toList(),
      'playerGameStats': _playerGameStats.map((key, stat) => MapEntry(key, stat.toJson())),
      'equippedItems': _equippedItems,
      'equippedRunes': _equippedRunes,
      'defeatedEnemyIds': _defeatedEnemyIds,
      'currentGame': _currentGame.toJson(),
      'settings': settings.toJson(),
      'currentView': _currentView,
      'selectedTaskId': _selectedTaskId,
      'apiKeyIndex': _apiKeyIndex,
      'activeTimers': _activeTimers.map((key, value) => MapEntry(key, value.toJson())),
      'lastSuccessfulSaveTimestamp': _lastSuccessfulSaveTimestamp?.toIso8601String(),
    };
  }

  void _loadStateFromMap(Map<String, dynamic> data) {
    print("[GameProvider] Loading state from map: ${data.keys.toList()}");
    _lastLoginDate = data['lastLoginDate'] as String?;
    _coins = (data['coins'] as num? ?? 100).toDouble();
    _xp = (data['xp'] as num? ?? 0).toDouble();
    _playerLevel = data['playerLevel'] as int? ?? 1;
    _playerEnergy = (data['playerEnergy'] as num? ?? baseMaxPlayerEnergy).toDouble();

    _mainTasks = (data['mainTasks'] as List<dynamic>?)
        ?.map((mtJson) => MainTask.fromJson(mtJson as Map<String, dynamic>))
        .toList() ?? initialMainTaskTemplates.map((t) => MainTask.fromTemplate(t)).toList();

    _completedByDay = data['completedByDay'] as Map<String, dynamic>? ?? {};
    _completedByDay.forEach((date, dayDataMap) {
        if (dayDataMap is Map<String, dynamic>) {
            dayDataMap.putIfAbsent('taskTimes', () => <String, int>{});
            dayDataMap.putIfAbsent('subtasksCompleted', () => <Map<String, dynamic>>[]);
            dayDataMap.putIfAbsent('checkpointsCompleted', () => <Map<String, dynamic>>[]);
        }
    });

    _artifacts = (data['artifacts'] as List<dynamic>?)
        ?.map((aJson) => OwnedArtifact.fromJson(aJson as Map<String, dynamic>))
        .toList() ?? [];

    _artifactTemplatesList = (data['artifactTemplatesList'] as List<dynamic>?)
        ?.map((atJson) => ArtifactTemplate.fromJson(atJson as Map<String, dynamic>))
        .toList() ?? initialArtifactTemplates; // Use initial if not present

    _enemyTemplatesList = (data['enemyTemplatesList'] as List<dynamic>?)
        ?.map((etJson) => EnemyTemplate.fromJson(etJson as Map<String, dynamic>))
        .toList() ?? initialEnemyTemplates; // Use initial if not present

    _gameLocationsList = (data['gameLocationsList'] as List<dynamic>?)
        ?.map((glJson) => GameLocation.fromJson(glJson as Map<String, dynamic>))
        .toList() ?? initialGameLocations; // Use initial if not present


    _runeTemplatesList = (data['runeTemplatesList'] as List<dynamic>?)
        ?.map((rtJson) => Rune.fromJson(rtJson as Map<String, dynamic>))
        .toList() ?? [];
    _ownedRunes = (data['ownedRunes'] as List<dynamic>?)
        ?.map((orJson) => OwnedRune.fromJson(orJson as Map<String, dynamic>))
        .toList() ?? [];


    final statsData = data['playerGameStats'] as Map<String, dynamic>?;
    _playerGameStats = { 
      ...Map.from(basePlayerGameStats.map((key, value) => MapEntry(key, PlayerStat(name: value.name, description: value.description, icon: value.icon, value: value.value, base: value.base)))),
    };
    _ensureBonusXpModStat(); 

    if (statsData != null) {
        statsData.forEach((String key, dynamic statJsonValue) {
            if (_playerGameStats.containsKey(key) && statJsonValue is Map<String, dynamic>) {
                 _playerGameStats[key] = PlayerStat.fromJson(statJsonValue);
            } else if (!_playerGameStats.containsKey(key) && statJsonValue is Map<String, dynamic> && key == 'bonusXPMod'){
                 _playerGameStats[key] = PlayerStat.fromJson(statJsonValue);
            }
        });
    }

    _equippedItems = Map<String, String?>.from(data['equippedItems'] as Map<dynamic, dynamic>? ?? {'weapon': null, 'armor': null, 'talisman': null});
    _equippedRunes = Map<String, String?>.from(data['equippedRunes'] as Map<dynamic, dynamic>? ?? {'rune_slot_1': null, 'rune_slot_2': null});
    _defeatedEnemyIds = (data['defeatedEnemyIds'] as List<dynamic>?)?.map((id) => id as String).toList() ?? [];

    _currentGame = data['currentGame'] != null
        ? CurrentGame.fromJson(data['currentGame'] as Map<String, dynamic>, _enemyTemplatesList)
        : CurrentGame(playerCurrentHp: _playerGameStats['vitality']!.value, currentPlaceKey: _gameLocationsList.isNotEmpty ? _gameLocationsList.first.id : null);
    
    // Ensure currentPlaceKey is valid
    if (_currentGame.currentPlaceKey == null && _gameLocationsList.isNotEmpty) {
      _currentGame.currentPlaceKey = _gameLocationsList.first.id;
    } else if (_currentGame.currentPlaceKey != null && !_gameLocationsList.any((loc) => loc.id == _currentGame.currentPlaceKey)) {
      _currentGame.currentPlaceKey = _gameLocationsList.isNotEmpty ? _gameLocationsList.first.id : null;
    }


    _settings = data['settings'] != null
        ? GameSettings.fromJson(data['settings'] as Map<String, dynamic>)
        : GameSettings();

    _currentView = data['currentView'] as String? ?? 'task-details';
    _selectedTaskId = data['selectedTaskId'] as String? ?? (_mainTasks.isNotEmpty ? _mainTasks[0].id : null);
    _apiKeyIndex = data['apiKeyIndex'] as int? ?? 0;

    _activeTimers = (data['activeTimers'] as Map<String, dynamic>?)
        ?.map((key, value) => MapEntry(key, ActiveTimerInfo.fromJson(value as Map<String, dynamic>))) ?? {};

    final timestampString = data['lastSuccessfulSaveTimestamp'] as String?;
    _lastSuccessfulSaveTimestamp = timestampString != null ? DateTime.tryParse(timestampString) : null;

    _recalculatePlayerLevel();
    _updatePlayerStatsFromItemsAndRunes();
    print("[GameProvider] State loaded. Current XP: $_xp, Level: $_playerLevel");
  }

  Future<void> _resetToInitialState() async { // Make async
    print("[GameProvider] Resetting to initial state.");
    _lastLoginDate = null;
    _coins = 100;
    _xp = 0;
    _playerLevel = 1;
    _playerEnergy = baseMaxPlayerEnergy;
    _mainTasks = initialMainTaskTemplates.map((t) => MainTask.fromTemplate(t)).toList();
    _completedByDay = {};
    _artifacts = []; 
    
    // Potentially load these from assets async if they become large
    _artifactTemplatesList = List.from(initialArtifactTemplates); 
    _enemyTemplatesList = List.from(initialEnemyTemplates); 
    _gameLocationsList = List.from(initialGameLocations); 

    _runeTemplatesList = [];
    _ownedRunes = [];
    _playerGameStats = {
      ...Map.from(basePlayerGameStats.map((key, value) => MapEntry(key, PlayerStat(name: value.name, description: value.description, icon: value.icon, value: value.value, base: value.base)))),
    };
    _ensureBonusXpModStat();
    _equippedItems = {'weapon': null, 'armor': null, 'talisman': null};
    _equippedRunes = {'rune_slot_1': null, 'rune_slot_2': null};
    _defeatedEnemyIds = [];
    _currentGame = CurrentGame(
        playerCurrentHp: _playerGameStats['vitality']!.value,
        currentPlaceKey: _gameLocationsList.isNotEmpty ? _gameLocationsList.first.id : null
    );
    _settings = GameSettings();
    _currentView = 'task-details';
    _selectedTaskId = _mainTasks.isNotEmpty ? _mainTasks[0].id : null;
    _apiKeyIndex = 0;
    _activeTimers = {};
    _isUsernameMissing = false;
    _lastSuccessfulSaveTimestamp = null;
    _hasUnsavedChanges = true;

    final rustySword = _artifactTemplatesList.firstWhereOrNull((art) => art.id == "art_rusty_sword");
    if (rustySword != null) {
        _artifacts.add(OwnedArtifact(uniqueId: "owned_${rustySword.id}_init", templateId: rustySword.id, currentLevel: 1));
        _equippedItems['weapon'] = "owned_${rustySword.id}_init";
    }
    final leatherJerkin = _artifactTemplatesList.firstWhereOrNull((art) => art.id == "art_leather_jerkin");
    if (leatherJerkin != null) {
        _artifacts.add(OwnedArtifact(uniqueId: "owned_${leatherJerkin.id}_init", templateId: leatherJerkin.id, currentLevel: 1));
        _equippedItems['armor'] = "owned_${leatherJerkin.id}_init";
    }
    _updatePlayerStatsFromItemsAndRunes();
    print("[GameProvider] Initial state reset complete.");
  }

  Future<void> _performActualSave() async {
    if (_currentUser != null) {
      print("[GameProvider] Performing actual save to Firestore for user ${_currentUser!.uid}");
      final success = await _storageService.setUserData(_currentUser!.uid, _gameStateToMap()); // Changed to setUserData for full overwrite
      if(success) {
        _lastSuccessfulSaveTimestamp = DateTime.now();
        _hasUnsavedChanges = false;
        notifyListeners(); // To update UI with new save timestamp if displayed
        print("[GameProvider] Save successful. Timestamp: $_lastSuccessfulSaveTimestamp");
      } else {
        print("[GameProvider] Save FAILED.");
        // Optionally, add a log to the game's UI log about save failure
         setProviderState(
            currentGame: CurrentGame(
              enemy: _currentGame.enemy,
              playerCurrentHp: _currentGame.playerCurrentHp,
              log: [..._currentGame.log, "<span style=\"color:${AppTheme.fhAccentRed.value.toRadixString(16).substring(2)};\">Critical Error: Failed to save game data to cloud!</span>"],
              currentPlaceKey: _currentGame.currentPlaceKey,
            ),
            doPersist: false, // Don't try to re-save immediately
            doNotify: true
          );
      }
    } else {
      print("[GameProvider] Cannot save, no current user.");
    }
  }

  Future<void> manuallySaveToCloud() async {
    if (_currentUser == null) throw Exception("Not logged in. Cannot save.");
    print("[GameProvider] Manually saving to cloud...");
    _isManuallySaving = true;
    notifyListeners();
    try {
      await _performActualSave();
    } finally {
      _isManuallySaving = false;
      notifyListeners();
      print("[GameProvider] Manual save finished.");
    }
  }

  Future<void> manuallyLoadFromCloud() async {
    if (_currentUser == null) throw Exception("Not logged in. Cannot load.");
     print("[GameProvider] Manually loading from cloud...");
    _isManuallyLoading = true;
    notifyListeners();
    try {
      final data = await _storageService.getUserData(_currentUser!.uid);
      if (data != null) {
        _loadStateFromMap(data);
        _handleDailyReset();
        if (settings.autoGenerateContent && (_enemyTemplatesList.isEmpty || _artifactTemplatesList.isEmpty || _runeTemplatesList.isEmpty || _gameLocationsList.isEmpty)) {
          // Don't await this if it blocks UI too much
           generateGameContent(_playerLevel, isManual: false, isInitial: true).catchError((e){
             print("Error during manual load content gen: $e");
           });
        }
        if (_currentUser?.displayName == null || _currentUser!.displayName!.trim().isEmpty) {
            _isUsernameMissing = true;
        } else {
            _isUsernameMissing = false;
        }
        _hasUnsavedChanges = false; // Data is now in sync with cloud
      } else {
        throw Exception("No data found on cloud.");
      }
    } finally {
      _isManuallyLoading = false;
      notifyListeners();
      print("[GameProvider] Manual load finished.");
    }
  }

  Future<void> loginUser(String email, String password) async {
    print("[GameProvider] Attempting login for email: $email");
    await fb_service.signInWithEmail(email, password);
  }

 Future<void> signupUser(String email, String password, String username) async {
    print("[GameProvider] Attempting signup for email: $email, username: $username");
    _authLoading = true;
    notifyListeners();
    try {
        UserCredential userCredential = await fb_service.firebaseAuthInstance.createUserWithEmailAndPassword(
            email: email,
            password: password,
        );
        _currentUser = userCredential.user;
        if (_currentUser != null) {
            print("[GameProvider] Signup successful, user UID: ${_currentUser!.uid}. Updating display name.");
            await _currentUser!.updateDisplayName(username);
            await _currentUser!.reload();
            _currentUser = fb_service.firebaseAuthInstance.currentUser; // Refresh user object

            await _resetToInitialState(); // Make reset async
            _lastLoginDate = helper.getTodayDateString();
            _hasUnsavedChanges = true; // Mark for initial save
            await _performActualSave();

            _handleDailyReset();
            if (settings.autoGenerateContent && (_enemyTemplatesList.isEmpty || _artifactTemplatesList.isEmpty || _runeTemplatesList.isEmpty || _gameLocationsList.isEmpty)) {
                // Don't await this if it blocks UI too much
                generateGameContent(_playerLevel, isManual: false, isInitial: true).catchError((e){
                   print("Error during signup content gen: $e");
                });
            }
            _isDataLoadingAfterLogin = false;
            _isUsernameMissing = false;
            print("[GameProvider] Signup and initial setup complete for user: $username");
        } else {
            throw Exception("Signup successful but user object is null.");
        }
    } catch (e) {
        _currentUser = null;
        print("[GameProvider] Signup failed: $e");
        rethrow;
    } finally {
        _authLoading = false;
        notifyListeners();
    }
}


  Future<void> logoutUser() async {
    print("[GameProvider] Logging out user...");
    if (_hasUnsavedChanges && _currentUser != null) {
        print("[GameProvider] Saving unsaved changes before logout.");
        await _performActualSave();
    }
    try {
      await fb_service.signOut();
      print("[GameProvider] User signed out successfully.");
    } catch (e) {
      print("[GameProvider] Error during sign out: $e");
      rethrow;
    }
  }

  Future<void> changePasswordHandler(String newPassword) async {
    if (_currentUser != null) {
      print("[GameProvider] Attempting to change password for user ${_currentUser!.uid}");
      await fb_service.changePassword(newPassword);
       _hasUnsavedChanges = true;
       notifyListeners();
       print("[GameProvider] Password change successful (client-side).");
    } else {
      throw Exception("No user is currently signed in.");
    }
  }

  Future<void> updateUserDisplayName(String newUsername) async {
    if (_currentUser != null) {
      print("[GameProvider] Updating display name to '$newUsername' for user ${_currentUser!.uid}");
      await _currentUser!.updateDisplayName(newUsername);
      await _currentUser!.reload();
      _currentUser = fb_service.firebaseAuthInstance.currentUser;

      _isUsernameMissing = false;
      _hasUnsavedChanges = true;
      notifyListeners();
      await _performActualSave();
      print("[GameProvider] Display name updated and saved.");
    }
  }


  void setCurrentView(String view) {
    if (_currentView != view) {
      print("[GameProvider] Setting current view from '$_currentView' to '$view'");
      _currentView = view;
      _hasUnsavedChanges = true;
      notifyListeners();
    }
  }

  void setSelectedTaskId(String? taskId) {
    if (_selectedTaskId != taskId) {
        print("[GameProvider] Setting selected task ID from '$_selectedTaskId' to '$taskId'");
        _selectedTaskId = taskId;
        _hasUnsavedChanges = true;
        notifyListeners();
    }
  }

  void setSettings(GameSettings newSettings) {
    _settings = newSettings;
    _hasUnsavedChanges = true;
    notifyListeners();
    print("[GameProvider] Settings updated. DescriptionsVisible: ${newSettings.descriptionsVisible}, AutoGenerate: ${newSettings.autoGenerateContent}");
  }

  String romanize(int num) => helper.romanize(num);

  MainTask? getSelectedTask() {
    if (_selectedTaskId == null) {
      return _mainTasks.firstOrNull;
    }
    return _mainTasks.firstWhereOrNull((t) => t.id == _selectedTaskId) ?? _mainTasks.firstOrNull;
  }


  void _recalculatePlayerLevel() {
    int newLevel = 1;
    double xpAtStartOfLvl = 0;
    while (true) {
        final double xpNeeded = helper.xpToNext(newLevel, xpPerLevelBase, xpLevelMultiplier);
        if (_xp >= xpAtStartOfLvl + xpNeeded) {
            xpAtStartOfLvl += xpNeeded;
            newLevel++;
        } else {
            break;
        }
    }
    if (_playerLevel != newLevel) {
        final oldLevel = _playerLevel;
        _playerLevel = newLevel;
        print("[GameProvider] Player level changed from $oldLevel to $_playerLevel. XP: $_xp");
        if (_playerLevel > oldLevel) {
             _handleLevelUpEffect();
        } else {
            _hasUnsavedChanges = true;
            notifyListeners();
        }
    }
  }

  void _handleLevelUpEffect() {
    if (_currentUser == null) return;
    print("[GameProvider] Player leveled up to $_playerLevel! Handling effects.");

    const double strengthIncreasePerLevel = 0.5;
    const double defenseIncreasePerLevel = 0.3;
    const double runicIncreasePerLevel = 0.25;

    _playerGameStats['vitality']!.base = basePlayerGameStats['vitality']!.base + ((_playerLevel -1) * playerEnergyPerLevelVitality);
    _playerGameStats['strength']!.base = basePlayerGameStats['strength']!.base + ((_playerLevel -1) * strengthIncreasePerLevel).roundToDouble();
    _playerGameStats['defense']!.base = basePlayerGameStats['defense']!.base + ((_playerLevel-1) * defenseIncreasePerLevel).roundToDouble();
    _playerGameStats['runic']!.base = basePlayerGameStats['runic']!.base + ((_playerLevel-1) * runicIncreasePerLevel).roundToDouble();

    _updatePlayerStatsFromItemsAndRunes();

    _playerEnergy = calculatedMaxEnergy;
    _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;

    if (settings.autoGenerateContent) {
        print("[GameProvider] Auto-generating content for new level $_playerLevel.");
        generateGameContent(_playerLevel, isManual: false, isInitial: false).catchError((e){
          print("Error during level up content gen: $e");
        });
    } else {
        _currentGame.log = [..._currentGame.log, "<span style=\"color:#${AppTheme.fhAccentTealFixed.value.toRadixString(16).substring(2)}\">You feel a surge of power! New opportunities might await (check settings).</span>"];
    }
    _hasUnsavedChanges = true;
    notifyListeners();
  }

  void _handleDailyReset() {
    if (_currentUser == null) return;
    final today = helper.getTodayDateString();
    if (_lastLoginDate != today) {
      print("[GameProvider] Daily reset triggered. Last login: $_lastLoginDate, Today: $today");
      _mainTasks = _mainTasks.map((task) {
        int newStreak = task.streak;
        if (_lastLoginDate != null) {
          final yesterday = DateTime.now().subtract(const Duration(days: 1));
          final yesterdayStr = DateFormat('yyyy-MM-dd').format(yesterday);
          if (task.dailyTimeSpent < dailyTaskGoalMinutes &&
              task.lastWorkedDate != null &&
              task.lastWorkedDate != today &&
              task.lastWorkedDate != yesterdayStr) {
            newStreak = 0;
             print("[GameProvider] Task '${task.name}' streak reset due to inactivity.");
          }
        }
        return MainTask(
          id: task.id, name: task.name, description: task.description, theme: task.theme, colorHex: task.colorHex,
          streak: newStreak, dailyTimeSpent: 0, lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks,
        );
      }).toList();

      _playerEnergy = calculatedMaxEnergy;
      _defeatedEnemyIds = [];
      _lastLoginDate = today;
      _hasUnsavedChanges = true;
      notifyListeners();
      print("[GameProvider] Daily reset complete. Player energy restored. Streaks updated.");
    }
  }

  void _updatePlayerStatsFromItemsAndRunes() {
    final Map<String, PlayerStat> newStats = {
      ...Map.from(basePlayerGameStats.map((key, bs) => MapEntry(key, PlayerStat(name: bs.name, base: bs.base, value: bs.base, description: bs.description, icon: bs.icon)))),
    };
    _ensureBonusXpModStat(); 
    if (!newStats.containsKey('bonusXPMod')) {
      newStats['bonusXPMod'] = PlayerStat(name: 'XP CALC MOD', value: 0, base: 0, description: 'Internal XP modifier from gear.', icon: 'mdi-percent-outline');
    }


    const double strengthIncreasePerLevel = 0.5;
    const double defenseIncreasePerLevel = 0.3;
    const double runicIncreasePerLevel = 0.25;

    newStats['vitality']!.base = basePlayerGameStats['vitality']!.base + ((_playerLevel - 1) * playerEnergyPerLevelVitality);
    newStats['strength']!.base = basePlayerGameStats['strength']!.base + ((_playerLevel - 1) * strengthIncreasePerLevel).roundToDouble();
    newStats['defense']!.base = basePlayerGameStats['defense']!.base + ((_playerLevel-1) * defenseIncreasePerLevel).roundToDouble();
    newStats['runic']!.base = basePlayerGameStats['runic']!.base + ((_playerLevel-1) * runicIncreasePerLevel).roundToDouble();

    newStats.forEach((key, stat) {
      stat.value = stat.base; 
    });

    _equippedItems.forEach((slot, uniqueId) {
      if (uniqueId != null) {
        final owned = _artifacts.firstWhereOrNull((art) => art.uniqueId == uniqueId);
        if (owned != null) {
          final template = _artifactTemplatesList.firstWhereOrNull((t) => t.id == owned.templateId);
          if (template != null && template.type != 'powerup') {
            final effective = _itemActions.getArtifactEffectiveStats(owned); 
            newStats['strength']!.value += effective.baseAtt ?? 0;
            newStats['defense']!.value += effective.baseDef ?? 0;
            newStats['vitality']!.value += effective.baseHealth ?? 0;
            newStats['runic']!.value += effective.baseRunic ?? 0;
            newStats['luck']!.value += effective.baseLuck?.toDouble() ?? 0;
            newStats['cooldown']!.value += effective.baseCooldown?.toDouble() ?? 0;
            newStats['bonusXPMod']!.value += effective.bonusXPMod ?? 0.0;
          }
        }
      }
    });

    _equippedRunes.forEach((slot, uniqueOwnedRuneId) {
      if (uniqueOwnedRuneId != null) {
        final ownedRune = _ownedRunes.firstWhereOrNull((or) => or.uniqueId == uniqueOwnedRuneId);
        if (ownedRune != null) {
          final runeTemplate = _runeTemplatesList.firstWhereOrNull((rt) => rt.id == ownedRune.runeId);
          if (runeTemplate != null && runeTemplate.type.contains("passive")) { 
            if (runeTemplate.effectType == 'stat_boost' && runeTemplate.targetStat != null && newStats.containsKey(runeTemplate.targetStat!)) {
              newStats[runeTemplate.targetStat!]!.value += runeTemplate.effectValue;
            }
          }
        }
      }
    });


    newStats['luck']!.value = newStats['luck']!.value.clamp(0, double.infinity).toDouble();
    newStats['bonusXPMod']!.value = newStats['bonusXPMod']!.value.clamp(0, double.infinity).toDouble();

    _playerGameStats = newStats;

    if (_currentGame.playerCurrentHp > _playerGameStats['vitality']!.value) {
      _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;
    } else if (_currentGame.enemy == null && _currentGame.playerCurrentHp < _playerGameStats['vitality']!.value) {
        _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;
    }
     print("[GameProvider] Player stats updated. Vitality: ${_playerGameStats['vitality']!.value}, Strength: ${_playerGameStats['strength']!.value}");
  }

  bool isLocationUnlocked(String locationId) {
    final location = _gameLocationsList.firstWhereOrNull((loc) => loc.id == locationId);
    if (location == null) {
      print("[GameProvider] isLocationUnlocked: Location ID '$locationId' not found.");
      return false; 
    }

    if (_playerLevel < location.minPlayerLevelToUnlock) {
      return false;
    }
    return true;
  }


  Future<void> clearAllGameData() async {
    if (_currentUser == null) return;
    print("[GameProvider] Clearing all game data for user ${_currentUser!.uid}");
    await _storageService.deleteUserData(_currentUser!.uid);
    await _resetToInitialState(); // Make reset async
    await _performActualSave();

    if (settings.autoGenerateContent) {
       print("[GameProvider] Generating initial content after data purge.");
       await generateGameContent(1, isManual: true, isInitial: true);
    }
    notifyListeners();
    print("[GameProvider] All game data cleared and reset.");
  }

  Future<void> resetPlayerLevelAndProgress() async {
    if (_currentUser == null) return;
    print("[GameProvider] Resetting player level and progress.");
    _playerLevel = 1;
    _xp = 0;
    _playerGameStats = {
        ...Map.from(basePlayerGameStats.map((key, value) => MapEntry(key, PlayerStat(name: value.name, description: value.description, icon: value.icon, value: value.value, base: value.base)))),
    };
    _ensureBonusXpModStat();
    _updatePlayerStatsFromItemsAndRunes();
    _playerEnergy = calculatedMaxEnergy;
    _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;
    _defeatedEnemyIds = [];
    if (settings.autoGenerateContent) {
        print("[GameProvider] Generating content for reset level 1.");
        await generateGameContent(1, isManual: false, isInitial: false);
    }
    _currentGame.log = [..._currentGame.log, "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">Player level and progress have been reset.</span>"];
    _hasUnsavedChanges = true;
    notifyListeners();
    print("[GameProvider] Player level and progress reset complete.");
  }

  void clearAllOwnedArtifacts() {
     print("[GameProvider] Clearing all owned artifacts.");
    setProviderState(
      artifacts: [],
      equippedItems: {'weapon': null, 'armor': null, 'talisman': null}, // Unequip all
      currentGame: CurrentGame(
        enemy: _currentGame.enemy,
        playerCurrentHp: _currentGame.playerCurrentHp,
        log: [..._currentGame.log, "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">All owned artifacts cleared from inventory.</span>"],
        currentPlaceKey: _currentGame.currentPlaceKey,
      )
    );
  }


  Future<void> clearDiscoverablePowerUps() async {
    if (_currentUser == null) return;
    print("[GameProvider] Clearing discoverable power-ups.");
    final List<String> ownedPowerUpTemplateIds = _artifacts
        .where((owned) {
            final template = _artifactTemplatesList.firstWhereOrNull((t) => t.id == owned.templateId);
            return template != null && template.type == 'powerup';
        })
        .map((owned) => owned.templateId)
        .toSet()
        .toList();

    final List<ArtifactTemplate> newArtifactTemplates = _artifactTemplatesList.where((template) {
        return template.type != 'powerup' || ownedPowerUpTemplateIds.contains(template.id);
    }).toList();

    setProviderState(
        artifactTemplatesList: newArtifactTemplates,
        currentGame: CurrentGame(
            enemy: _currentGame.enemy,
            playerCurrentHp: _currentGame.playerCurrentHp,
            log: [..._currentGame.log, "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">Discoverable power-up schematics purged. Owned items remain.</span>"],
            currentPlaceKey: _currentGame.currentPlaceKey,
        )
    );
  }

  Future<void> removeAllEnemyTemplates() async {
    if (_currentUser == null) return;
    print("[GameProvider] Removing all enemy templates.");
    setProviderState(
        enemyTemplatesList: [],
        currentGame: CurrentGame(
            enemy: _currentGame.enemy,
            playerCurrentHp: _currentGame.playerCurrentHp,
            log: [..._currentGame.log, "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">All enemy intelligence wiped from the database.</span>"],
            currentPlaceKey: _currentGame.currentPlaceKey,
        )
    );
  }

  void addMainTask({required String name, required String description, required String theme, required String colorHex}) => _taskActions.addMainTask(name: name, description: description, theme: theme, colorHex: colorHex);
  void editMainTask(String taskId, {required String name, required String description, required String theme, required String colorHex}) => _taskActions.editMainTask(taskId, name: name, description: description, theme: theme, colorHex: colorHex);
  void logToDailySummary(String type, Map<String, dynamic> data) => _taskActions.logToDailySummary(type, data);
  String addSubtask(String mainTaskId, Map<String, dynamic> subtaskData) => _taskActions.addSubtask(mainTaskId, subtaskData);
  void updateSubtask(String mainTaskId, String subtaskId, Map<String, dynamic> updates) => _taskActions.updateSubtask(mainTaskId, subtaskId, updates);
  bool completeSubtask(String mainTaskId, String subtaskId) => _taskActions.completeSubtask(mainTaskId, subtaskId);
  void deleteSubtask(String mainTaskId, String subtaskId) => _taskActions.deleteSubtask(mainTaskId, subtaskId);
  void duplicateCompletedSubtask(String mainTaskId, String subtaskId) => _taskActions.duplicateCompletedSubtask(mainTaskId, subtaskId);
  void addSubSubtask(String mainTaskId, String parentSubtaskId, Map<String, dynamic> subSubtaskData) => _taskActions.addSubSubtask(mainTaskId, parentSubtaskId, subSubtaskData);
  void updateSubSubtask(String mainTaskId, String parentSubtaskId, String subSubtaskId, Map<String, dynamic> updates) => _taskActions.updateSubSubtask(mainTaskId, parentSubtaskId, subSubtaskId, updates);
  void completeSubSubtask(String mainTaskId, String parentSubtaskId, String subSubtaskId) => _taskActions.completeSubSubtask(mainTaskId, parentSubtaskId, subSubtaskId);
  void deleteSubSubtask(String mainTaskId, String parentSubtaskId, String subSubtaskId) => _taskActions.deleteSubSubtask(mainTaskId, parentSubtaskId, subSubtaskId);

  OwnedArtifact? getArtifactByUniqueId(String uniqueId) => _itemActions.getArtifactByUniqueId(uniqueId);
  ArtifactTemplate? getArtifactTemplateById(String templateId) => _itemActions.getArtifactTemplateById(templateId);
  ArtifactTemplate getArtifactEffectiveStats(OwnedArtifact ownedArtifact) => _itemActions.getArtifactEffectiveStats(ownedArtifact);
  void buyArtifact(String templateId) => _itemActions.buyArtifact(templateId);
  bool upgradeArtifact(String uniqueId) => _itemActions.upgradeArtifact(uniqueId);
  bool sellArtifact(String uniqueId) => _itemActions.sellArtifact(uniqueId);
  void equipArtifact(String uniqueId) => _itemActions.equipArtifact(uniqueId);
  void unequipArtifact(String slot) => _itemActions.unequipArtifact(slot);
  void acquireRune(String runeId) { print("[GameProvider] Placeholder: Acquire Rune $runeId"); notifyListeners(); }
  void equipRune(String ownedRuneUniqueId, String slot) { print("[GameProvider] Placeholder: Equip Rune $ownedRuneUniqueId to $slot"); _updatePlayerStatsFromItemsAndRunes(); notifyListeners(); }
  void unequipRune(String slot) { print("[GameProvider] Placeholder: Unequip Rune from $slot"); _updatePlayerStatsFromItemsAndRunes(); notifyListeners(); }


  void startGame(String enemyId) => _combatActions.startGame(enemyId);
  void handleFight() => _combatActions.handleFight();
  void usePowerUp(String uniqueId) => _combatActions.usePowerUp(uniqueId);
  void forfeitMatch() => _combatActions.forfeitMatch();

  Future<void> generateGameContent(int level, {bool isManual = false, bool isInitial = false}) =>
    _aiGenerationActions.generateGameContent(level, isManual: isManual, isInitial: isInitial);
  Future<void> triggerAISubquestGeneration(MainTask mainTask, String generationMode, String userInput, int numSubquests) =>
    _aiGenerationActions.triggerAISubquestGeneration(mainTask, generationMode, userInput, numSubquests);

  void startTimer(String id, String type, String mainTaskId) => _timerActions.startTimer(id, type, mainTaskId);
  void pauseTimer(String id) => _timerActions.pauseTimer(id);
  void logTimerAndReset(String id) => _timerActions.logTimerAndReset(id);


  void setProviderState({
    String? lastLoginDate,
    double? coins,
    double? xp,
    double? playerEnergy,
    List<MainTask>? mainTasks,
    Map<String, dynamic>? completedByDay,
    List<OwnedArtifact>? artifacts,
    List<ArtifactTemplate>? artifactTemplatesList,
    List<EnemyTemplate>? enemyTemplatesList,
    List<GameLocation>? gameLocationsList, 
    List<Rune>? runeTemplatesList, 
    List<OwnedRune>? ownedRunes, 
    Map<String, PlayerStat>? playerGameStats,
    Map<String, String?>? equippedItems,
    Map<String, String?>? equippedRunes, 
    List<String>? defeatedEnemyIds,
    CurrentGame? currentGame,
    Map<String, ActiveTimerInfo>? activeTimers,
    DateTime? lastSuccessfulSaveTimestamp,
    bool? isUsernameMissing,
    bool doNotify = true,
    bool doPersist = true,
  }) {
    bool changed = false;
    int oldLevel = _playerLevel;

    if (lastLoginDate != null && _lastLoginDate != lastLoginDate) { _lastLoginDate = lastLoginDate; changed = true; }
    if (coins != null && _coins != coins) { _coins = coins; changed = true; }

    if (xp != null && _xp != xp) {
      _xp = xp;
      _recalculatePlayerLevel(); 
      changed = true;
    }

    if (playerEnergy != null && _playerEnergy != playerEnergy) { _playerEnergy = playerEnergy.clamp(0, calculatedMaxEnergy); changed = true; }
    
    // For lists and maps, ensure a change is detected if the reference changes or content changes
    if (mainTasks != null && !listEquals(_mainTasks, mainTasks)) { 
        _mainTasks = List.from(mainTasks); // Create new list to ensure change detection
        changed = true; 
    }
    if (completedByDay != null && !mapEquals(_completedByDay, completedByDay)) { 
        _completedByDay = Map.from(completedByDay); 
        changed = true; 
    }

    bool itemsOrRunesOrEquippedChanged = false;
    if (artifacts != null && !listEquals(_artifacts, artifacts)) { 
        _artifacts = List.from(artifacts); 
        itemsOrRunesOrEquippedChanged = true; 
        changed = true; 
    }
    if (artifactTemplatesList != null && !listEquals(_artifactTemplatesList, artifactTemplatesList)) { 
        _artifactTemplatesList = List.from(artifactTemplatesList); 
        changed = true; 
    }
    if (enemyTemplatesList != null && !listEquals(_enemyTemplatesList, enemyTemplatesList)) { 
        _enemyTemplatesList = List.from(enemyTemplatesList); 
        changed = true; 
    }
    if (gameLocationsList != null && !listEquals(_gameLocationsList, gameLocationsList)) { 
        _gameLocationsList = List.from(gameLocationsList); 
        changed = true; 
    }
    if (runeTemplatesList != null && !listEquals(_runeTemplatesList, runeTemplatesList)) { 
        _runeTemplatesList = List.from(runeTemplatesList); 
        changed = true; 
    }
    if (ownedRunes != null && !listEquals(_ownedRunes, ownedRunes)) { 
        _ownedRunes = List.from(ownedRunes); 
        itemsOrRunesOrEquippedChanged = true; 
        changed = true; 
    }


    if (playerGameStats != null && !mapEquals(_playerGameStats, playerGameStats)) {
        playerGameStats.forEach((key, newStat) {
            if (_playerGameStats.containsKey(key)) {
                _playerGameStats[key]!.base = newStat.base; 
                _playerGameStats[key]!.value = newStat.value; // Ensure value is also updated
            } else {
                 _playerGameStats[key] = newStat; 
            }
        });
        _ensureBonusXpModStat(); 
        itemsOrRunesOrEquippedChanged = true; 
        changed = true;
    }

    if (equippedItems != null && !mapEquals(_equippedItems, equippedItems)) { 
        _equippedItems = Map.from(equippedItems); 
        itemsOrRunesOrEquippedChanged = true; 
        changed = true; 
    }
    if (equippedRunes != null && !mapEquals(_equippedRunes, equippedRunes)) { 
        _equippedRunes = Map.from(equippedRunes); 
        itemsOrRunesOrEquippedChanged = true; 
        changed = true; 
    }


    if (itemsOrRunesOrEquippedChanged || oldLevel != _playerLevel) { 
         _updatePlayerStatsFromItemsAndRunes();
    }

    if (defeatedEnemyIds != null && !listEquals(_defeatedEnemyIds, defeatedEnemyIds)) { 
        _defeatedEnemyIds = List.from(defeatedEnemyIds); 
        changed = true; 
    }
    if (currentGame != null && _currentGame != currentGame) { // This comparison might need to be deeper
        _currentGame = currentGame; // Assume currentGame is a new instance
        if (_playerGameStats['vitality'] != null && _currentGame.playerCurrentHp > _playerGameStats['vitality']!.value) {
            _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;
        }
        changed = true;
    }
    if (activeTimers != null && !mapEquals(_activeTimers, activeTimers)) { 
        _activeTimers = Map.from(activeTimers); 
        changed = true; 
    }
    if (lastSuccessfulSaveTimestamp != null && _lastSuccessfulSaveTimestamp != lastSuccessfulSaveTimestamp) { 
        _lastSuccessfulSaveTimestamp = lastSuccessfulSaveTimestamp; 
        changed = true; 
    }
    if (isUsernameMissing != null && _isUsernameMissing != isUsernameMissing) { 
        _isUsernameMissing = isUsernameMissing; 
        changed = true; 
    }

    if (changed) {
      if (kDebugMode && doNotify) {
        print("[GameProvider] setProviderState detected changes, will notify. Persist: $doPersist.");
      }
      if (doPersist) _hasUnsavedChanges = true;
      if (doNotify) notifyListeners();
    }
  }

  void setProviderAIGlobalLoading(bool isLoading) {
    if (_isGeneratingGlobalContent != isLoading) {
      _isGeneratingGlobalContent = isLoading;
      print("[GameProvider] AI Global Loading set to: $isLoading");
      notifyListeners();
    }
  }
   void setProviderAISubquestLoading(bool isLoading) {
    if (_isGeneratingSubquestsForTask != isLoading) {
      _isGeneratingSubquestsForTask = isLoading;
      print("[GameProvider] AI Subquest Loading set to: $isLoading");
      notifyListeners();
    }
  }
  void setProviderApiKeyIndex(int index) {
    if (_apiKeyIndex != index) {
      _apiKeyIndex = index;
      print("[GameProvider] API Key Index set to: $index");
      // No need to notify listeners for this internal state unless UI depends on it directly
    }
  }

}
--- END OF FILE lib/src/providers/game_provider.dart ---

--- START OF FILE lib/src/providers/actions/ai_generation_actions.dart ---
// lib/src/providers/actions/ai_generation_actions.dart
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/services/ai_service.dart';
import 'package:myapp_flutter/src/models/game_models.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart';
import 'package:flutter/foundation.dart'; // For kDebugMode

class AIGenerationActions {
  final GameProvider _provider;
  final AIService _aiService = AIService();

  AIGenerationActions(this._provider);

  Future<void> generateGameContent(int levelForContent, {bool isManual = false, bool isInitial = false}) async {
    if (_provider.isGeneratingContent && !isManual && !isInitial) {
      print("[AIActions] generateGameContent skipped, already in progress.");
      return;
    }
    _provider.setProviderAIGlobalLoading(true);
    print("[AIActions] Starting generateGameContent for level $levelForContent. Manual: $isManual, Initial: $isInitial");


    final themes = ['tech', 'knowledge', 'learning', 'discipline', 'order', 'nature', 'ancient', 'shadow', 'light']; // Expanded themes
    final existingEnemyIdsString = _provider.enemyTemplatesList.map((e) => e.id).join(', ');
    final existingArtifactIdsString = _provider.artifactTemplatesList.map((a) => a.id).join(', ');
    final existingLocationIdsString = _provider.gameLocationsList.map((loc) => loc.id).join(', '); // Added

    try {
      final result = await _aiService.generateGameContent(
        levelForContent: levelForContent,
        isManual: isManual,
        isInitial: isInitial,
        currentApiKeyIndex: _provider.apiKeyIndex,
        onNewApiKeyIndex: (newIndex) {
          print("[AIActions] API key index updated to $newIndex");
          _provider.setProviderApiKeyIndex(newIndex);
        },
        existingEnemyIdsString: existingEnemyIdsString.isNotEmpty ? existingEnemyIdsString : 'none',
        existingArtifactIdsString: existingArtifactIdsString.isNotEmpty ? existingArtifactIdsString : 'none',
        existingLocationIdsString: existingLocationIdsString.isNotEmpty ? existingLocationIdsString : 'none', // Added
        themes: themes,
        onLog: (logMessage) {
           _provider.setProviderState(
            currentGame: CurrentGame(
                enemy: _provider.currentGame.enemy,
                playerCurrentHp: _provider.currentGame.playerCurrentHp,
                log: [..._provider.currentGame.log, logMessage],
                currentPlaceKey: _provider.currentGame.currentPlaceKey,
            ),
            doPersist: false,
            doNotify: true
          );
        },
      );

      final List<EnemyTemplate> uniqueNewEnemies = result['newEnemies']!
          .map((eJson) => EnemyTemplate.fromJson(eJson))
          .where((e) => !_provider.enemyTemplatesList.any((et) => et.id == e.id))
          .toList();

      final List<ArtifactTemplate> uniqueNewArtifacts = result['newArtifacts']!
          .map((aJson) => ArtifactTemplate.fromJson(aJson))
          .where((a) => !_provider.artifactTemplatesList.any((at) => at.id == a.id))
          .toList();
      
      final List<GameLocation> uniqueNewLocations = (result['newGameLocations'] ?? [])
          .map((locJson) => GameLocation.fromJson(locJson))
          .where((loc) => !_provider.gameLocationsList.any((gl) => gl.id == loc.id))
          .toList();
      
      print("[AIActions] AI generated: ${uniqueNewEnemies.length} enemies, ${uniqueNewArtifacts.length} artifacts, ${uniqueNewLocations.length} locations.");


      _provider.setProviderState(
        enemyTemplatesList: [..._provider.enemyTemplatesList, ...uniqueNewEnemies],
        artifactTemplatesList: [..._provider.artifactTemplatesList, ...uniqueNewArtifacts],
        gameLocationsList: [..._provider.gameLocationsList, ...uniqueNewLocations], // Add new locations
        currentGame: CurrentGame(
            enemy: _provider.currentGame.enemy,
            playerCurrentHp: _provider.currentGame.playerCurrentHp,
            log: [..._provider.currentGame.log, "<span style=\"color:${AppTheme.fhAccentGreen.value.toRadixString(16).substring(2)};\">New challenges, treasures, and realms have appeared! (AI Generated)</span>"],
            currentPlaceKey: _provider.currentGame.currentPlaceKey,
        )
      );

    } catch (e) {
       print("[AIActions] Error in generateGameContent: ${e.toString()}");
       _provider.setProviderState(
        currentGame: CurrentGame(
            enemy: _provider.currentGame.enemy,
            playerCurrentHp: _provider.currentGame.playerCurrentHp,
            log: [..._provider.currentGame.log, "<span style=\"color:${AppTheme.fhAccentRed.value.toRadixString(16).substring(2)};\">AI content generation failed: ${e.toString()}</span>"],
            currentPlaceKey: _provider.currentGame.currentPlaceKey,
        )
      );
    } finally {
      _provider.setProviderAIGlobalLoading(false);
      print("[AIActions] Finished generateGameContent.");
    }
  }

  Future<void> triggerAISubquestGeneration(MainTask mainTaskForSubquests, String generationMode, String userInput, int numSubquests) async {
    if (_provider.isGeneratingSubquests) {
        print("[AIActions] triggerAISubquestGeneration skipped, already in progress.");
        return;
    }
    _provider.setProviderAISubquestLoading(true);
    print("[AIActions] Starting triggerAISubquestGeneration for task '${mainTaskForSubquests.name}'. Mode: $generationMode");


    try {
      final generatedSubquestsRaw = await _aiService.generateAISubquests(
        mainTaskName: mainTaskForSubquests.name,
        mainTaskDescription: mainTaskForSubquests.description,
        mainTaskTheme: mainTaskForSubquests.theme,
        generationMode: generationMode,
        userInput: userInput,
        numSubquests: numSubquests,
        currentApiKeyIndex: _provider.apiKeyIndex,
        onNewApiKeyIndex: (newIndex) {
            print("[AIActions] API key index updated to $newIndex during subquest gen.");
            _provider.setProviderApiKeyIndex(newIndex);
        },
        onLog: (logMessage) {
           _provider.setProviderState(
            currentGame: CurrentGame(
                enemy: _provider.currentGame.enemy,
                playerCurrentHp: _provider.currentGame.playerCurrentHp,
                log: [..._provider.currentGame.log, logMessage],
                currentPlaceKey: _provider.currentGame.currentPlaceKey,
            ),
            doPersist: false,
            doNotify: true
          );
        },

      );

      final List<SubTask> newSubTasksForParent = [];
      for (var subquestData in generatedSubquestsRaw) {
          final List<Map<String, dynamic>> subSubTasksDataList = (subquestData['subSubTasksData'] as List<dynamic>? ?? []).cast<Map<String, dynamic>>();
          final List<SubSubTask> currentSubSubTasks = [];
          for (int i = 0; i < subSubTasksDataList.length; i++) {
              final sssData = subSubTasksDataList[i];
              currentSubSubTasks.add(SubSubTask(
                  id: 'ssub_${DateTime.now().millisecondsSinceEpoch}_${newSubTasksForParent.length}_$i',
                  name: sssData['name'] as String,
                  isCountable: sssData['isCountable'] as bool? ?? false,
                  targetCount: (sssData['isCountable'] as bool? ?? false) ? (sssData['targetCount'] as int? ?? 1) : 0,
              ));
          }

          newSubTasksForParent.add(SubTask(
              id: 'sub_${DateTime.now().millisecondsSinceEpoch}_${newSubTasksForParent.length}',
              name: subquestData['name'] as String,
              isCountable: subquestData['isCountable'] as bool? ?? false,
              targetCount: (subquestData['isCountable'] as bool? ?? false) ? (subquestData['targetCount'] as int? ?? 1) : 0,
              subSubTasks: currentSubSubTasks,
          ));
      }

      final newMainTasks = _provider.mainTasks.map((task) {
        if (task.id == mainTaskForSubquests.id) {
          return MainTask(
            id: task.id, name: task.name, description: task.description, theme: task.theme, colorHex: task.colorHex,
            streak: task.streak, dailyTimeSpent: task.dailyTimeSpent, lastWorkedDate: task.lastWorkedDate,
            subTasks: [...task.subTasks, ...newSubTasksForParent],
          );
        }
        return task;
      }).toList();
      
      print("[AIActions] Generated ${newSubTasksForParent.length} new sub-quests for task '${mainTaskForSubquests.name}'.");

      _provider.setProviderState(
        mainTasks: newMainTasks,
        currentGame: CurrentGame(
            enemy: _provider.currentGame.enemy,
            playerCurrentHp: _provider.currentGame.playerCurrentHp,
            log: [..._provider.currentGame.log, "<span style=\"color:${AppTheme.fhAccentGreen.value.toRadixString(16).substring(2)};\">AI successfully generated ${generatedSubquestsRaw.length} new sub-quests for '${mainTaskForSubquests.name}'.</span>"],
            currentPlaceKey: _provider.currentGame.currentPlaceKey,
        )
      );

    } catch (e) {
      print("[AIActions] Error in triggerAISubquestGeneration: ${e.toString()}");
      _provider.setProviderState(
        currentGame: CurrentGame(
            enemy: _provider.currentGame.enemy,
            playerCurrentHp: _provider.currentGame.playerCurrentHp,
            log: [..._provider.currentGame.log, "<span style=\"color:${AppTheme.fhAccentRed.value.toRadixString(16).substring(2)};\">AI sub-quest generation failed: ${e.toString()}</span>"],
            currentPlaceKey: _provider.currentGame.currentPlaceKey,
        )
      );
    } finally {
      _provider.setProviderAISubquestLoading(false);
      print("[AIActions] Finished triggerAISubquestGeneration.");
    }
  }
}
--- END OF FILE lib/src/providers/actions/ai_generation_actions.dart ---

--- START OF FILE lib/src/providers/actions/combat_actions.dart ---
// lib/src/providers/actions/combat_actions.dart
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/utils/constants.dart';
import 'package:myapp_flutter/src/models/game_models.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart'; // For colors in log
import 'dart:math';
import 'package:collection/collection.dart'; // For firstWhereOrNull

class CombatActions {
  final GameProvider _provider;

  CombatActions(this._provider);

  void startGame(String enemyId) {
    final enemyTemplate = _provider.enemyTemplatesList.firstWhereOrNull((e) => e.id == enemyId);
    if (enemyTemplate == null) return;

    final newGame = CurrentGame(
      enemy: EnemyTemplate( // Create a mutable copy for combat
        id: enemyTemplate.id, name: enemyTemplate.name, theme: enemyTemplate.theme,
        minPlayerLevel: enemyTemplate.minPlayerLevel, health: enemyTemplate.health,
        attack: enemyTemplate.attack, defense: enemyTemplate.defense,
        coinReward: enemyTemplate.coinReward, xpReward: enemyTemplate.xpReward,
        description: enemyTemplate.description, hp: enemyTemplate.health // Start with full HP
      ),
      playerCurrentHp: _provider.playerGameStats['vitality']!.value,
      log: ["<span style=\"font-weight:bold;\">You encounter ${enemyTemplate.name}!</span> ${enemyTemplate.description}"],
    );

    _provider.setProviderState(currentGame: newGame);
  }

  void handleFight() {
    if (_provider.currentGame.enemy == null || _provider.playerEnergy < energyPerAttack) {
      if (_provider.playerEnergy < energyPerAttack && _provider.currentGame.enemy != null) {
        _provider.setProviderState(
          currentGame: CurrentGame(
            enemy: _provider.currentGame.enemy,
            playerCurrentHp: _provider.currentGame.playerCurrentHp,
            log: [..._provider.currentGame.log, "<span style=\"color:${AppTheme.fhAccentRed.value.toRadixString(16).substring(2)};\">Not enough energy!</span>"],
          )
        );
      }
      return;
    }

    final currentEnemy = _provider.currentGame.enemy!; // This is already a mutable copy
    final playerStats = _provider.playerGameStats;
    final currentLog = List<String>.from(_provider.currentGame.log);

    int playerDamage = max(1, (playerStats['strength']!.value + (playerStats['runic']!.value / 2).floor() - currentEnemy.defense).toInt());
    currentEnemy.hp = max(0, currentEnemy.hp - playerDamage); // Mutate the current enemy's HP

    currentLog.add("You hit ${currentEnemy.name} for $playerDamage damage. (${currentEnemy.name} HP: ${currentEnemy.hp})");

    final Map<String, dynamic> updatesToPersist = {
      'playerEnergy': _provider.playerEnergy - energyPerAttack,
    };

    EnemyTemplate? nextEnemyState = currentEnemy;

    if (currentEnemy.hp <= 0) {
      currentLog.add("${currentEnemy.name} defeated!");
      final double luckBonus = 1 + (playerStats['luck']!.value / 100);
      final double xpBonusFromArtifact = playerStats['bonusXPMod']?.value ?? 0;
      final double totalXPMultiplier = luckBonus * (1 + xpBonusFromArtifact);
      final int coinReward = (currentEnemy.coinReward * luckBonus).floor();
      final int xpRewardVal = (currentEnemy.xpReward * totalXPMultiplier).floor();
      currentLog.add("You gain $coinReward Ø and $xpRewardVal XP.");

      updatesToPersist['coins'] = _provider.coins + coinReward;
      updatesToPersist['xp'] = _provider.xp + xpRewardVal;
      updatesToPersist['defeatedEnemyIds'] = [...Set<String>.from(_provider.defeatedEnemyIds)..add(currentEnemy.id)].toList();
      nextEnemyState = null;
    } else {
      int enemyDamage = max(1, (currentEnemy.attack - playerStats['defense']!.value).toInt());
      updatesToPersist['playerCurrentHp'] = max(0.0, _provider.currentGame.playerCurrentHp - enemyDamage);
      currentLog.add("${currentEnemy.name} hits you for $enemyDamage damage. (Your HP: ${updatesToPersist['playerCurrentHp']})");
      if (updatesToPersist['playerCurrentHp'] <= 0) {
        currentLog.add("You have been defeated! Retreat to recover.");
        nextEnemyState = null;
      }
    }

    updatesToPersist['currentGame'] = CurrentGame(
      enemy: nextEnemyState,
      playerCurrentHp: updatesToPersist['playerCurrentHp'] as double? ?? _provider.currentGame.playerCurrentHp,
      log: currentLog,
    );
     if (!updatesToPersist.containsKey('playerCurrentHp')) {
      (updatesToPersist['currentGame'] as CurrentGame).playerCurrentHp = _provider.currentGame.playerCurrentHp;
    }


    _provider.setProviderState(
      playerEnergy: updatesToPersist['playerEnergy'] as double?,
      coins: updatesToPersist['coins'] as double?,
      xp: updatesToPersist['xp'] as double?,
      defeatedEnemyIds: updatesToPersist['defeatedEnemyIds'] as List<String>?,
      currentGame: updatesToPersist['currentGame'] as CurrentGame,
      doPersist: false
    );

  }

  void usePowerUp(String uniqueId) {
    final powerUpInstance = _provider.artifacts.firstWhereOrNull((a) => a.uniqueId == uniqueId);
    final template = powerUpInstance != null ? _provider.artifactTemplatesList.firstWhereOrNull((t) => t.id == powerUpInstance.templateId) : null;

    if (template == null || powerUpInstance == null || template.type != 'powerup' || (powerUpInstance.uses != null && powerUpInstance.uses! <= 0) || _provider.currentGame.enemy == null) {
      if (_provider.currentGame.enemy == null && template != null) { // Added template null check
         _provider.setProviderState(
          currentGame: CurrentGame(
            enemy: _provider.currentGame.enemy,
            playerCurrentHp: _provider.currentGame.playerCurrentHp,
            log: [..._provider.currentGame.log, "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)};\">Can only use power-ups in combat!</span>"],
          )
        );
      }
      return;
    }

    final currentEnemy = _provider.currentGame.enemy!; // This is a mutable copy from startGame
    final playerStats = _provider.playerGameStats;
    final currentLog = List<String>.from(_provider.currentGame.log);
    final Map<String, dynamic> updatesToPersist = {};

    double playerHpAfterPowerUp = _provider.currentGame.playerCurrentHp;
    EnemyTemplate? nextEnemyState = currentEnemy;


    if (template.effectType == 'direct_damage') {
      final int damage = max(1, (template.effectValue ?? 0) - (currentEnemy.defense / 2).floor());
      currentEnemy.hp = max(0, currentEnemy.hp - damage); // Mutate current enemy
      currentLog.add("<span style=\"color:${AppTheme.fhAccentPurple.value.toRadixString(16).substring(2)};\">You used ${template.name}!</span> It hits ${currentEnemy.name} for $damage damage. (${currentEnemy.name} HP: ${currentEnemy.hp})");
    } else if (template.effectType == 'heal_player') {
      playerHpAfterPowerUp = min(playerStats['vitality']!.value, _provider.currentGame.playerCurrentHp + (template.effectValue ?? 0));
      updatesToPersist['playerCurrentHp'] = playerHpAfterPowerUp;
      currentLog.add("<span style=\"color:${AppTheme.fhAccentPurple.value.toRadixString(16).substring(2)};\">You used ${template.name}!</span> You healed for ${template.effectValue} HP. (Your HP: $playerHpAfterPowerUp)");
    }

    updatesToPersist['artifacts'] = _provider.artifacts.map((art) {
      if (art.uniqueId == uniqueId) {
        return OwnedArtifact(uniqueId: art.uniqueId, templateId: art.templateId, currentLevel: art.currentLevel, uses: (art.uses ?? 1) - 1);
      }
      return art;
    }).where((art) => art.uses == null || art.uses! > 0).toList();


    if (currentEnemy.hp <= 0) {
      currentLog.add("${currentEnemy.name} defeated by the power-up!");
      final double luckBonus = 1 + (playerStats['luck']!.value / 100);
      final double xpBonusFromArtifact = playerStats['bonusXPMod']?.value ?? 0;
      final double totalXPMultiplier = luckBonus * (1 + xpBonusFromArtifact);
      final int coinReward = (currentEnemy.coinReward * luckBonus).floor();
      final int xpRewardVal = (currentEnemy.xpReward * totalXPMultiplier).floor();
      currentLog.add("You gain $coinReward Ø and $xpRewardVal XP.");
      updatesToPersist['coins'] = _provider.coins + coinReward;
      updatesToPersist['xp'] = _provider.xp + xpRewardVal;
      updatesToPersist['defeatedEnemyIds'] = [...Set<String>.from(_provider.defeatedEnemyIds)..add(currentEnemy.id)].toList();
      nextEnemyState = null;
    }

    updatesToPersist['currentGame'] = CurrentGame(
      enemy: nextEnemyState,
      playerCurrentHp: updatesToPersist['playerCurrentHp'] as double? ?? _provider.currentGame.playerCurrentHp,
      log: currentLog,
    );
    if (!updatesToPersist.containsKey('playerCurrentHp')) {
      (updatesToPersist['currentGame'] as CurrentGame).playerCurrentHp = _provider.currentGame.playerCurrentHp;
    }

    _provider.setProviderState(
      artifacts: updatesToPersist['artifacts'] as List<OwnedArtifact>?,
      coins: updatesToPersist['coins'] as double?,
      xp: updatesToPersist['xp'] as double?,
      defeatedEnemyIds: updatesToPersist['defeatedEnemyIds'] as List<String>?,
      currentGame: updatesToPersist['currentGame'] as CurrentGame,
      doPersist: false
    );
    
  }

  void forfeitMatch() {
    if (_provider.currentGame.enemy == null) return;
    final int coinsLost = (_provider.coins * 0.10).floor();
    final double maxHp = _provider.playerGameStats['vitality']!.value;

    _provider.setProviderState(
      coins: _provider.coins - coinsLost,
      playerEnergy: 0,
      currentGame: CurrentGame(
        playerCurrentHp: maxHp,
        enemy: null,
        log: [..._provider.currentGame.log, "<span style=\"color:${AppTheme.fhAccentRed.value.toRadixString(16).substring(2)};\">You forfeited the match!</span> Lost $coinsLost Ø and all energy."],
      )
    );
  }
}
--- END OF FILE lib/src/providers/actions/combat_actions.dart ---

--- START OF FILE lib/src/providers/actions/task_actions.dart ---
// lib/src/providers/actions/task_actions.dart
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/utils/constants.dart';
import 'package:myapp_flutter/src/models/game_models.dart';
import 'package:myapp_flutter/src/utils/helpers.dart';
import 'package:collection/collection.dart'; 

class TaskActions {
  final GameProvider _provider;

  TaskActions(this._provider);

  void addMainTask({required String name, required String description, required String theme, required String colorHex}) {
    final newTask = MainTask(
      id: 'mt_${DateTime.now().millisecondsSinceEpoch}',
      name: name,
      description: description,
      theme: theme,
      colorHex: colorHex,
    );
    _provider.setProviderState(mainTasks: [..._provider.mainTasks, newTask]);
  }

  void editMainTask(String taskId, {required String name, required String description, required String theme, required String colorHex}) {
    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == taskId) {
        return MainTask(
          id: task.id,
          name: name,
          description: description,
          theme: theme,
          colorHex: colorHex,
          streak: task.streak,
          dailyTimeSpent: task.dailyTimeSpent,
          lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks,
        );
      }
      return task;
    }).toList();
    _provider.setProviderState(mainTasks: newMainTasks);
  }


  void logToDailySummary(String type, Map<String, dynamic> data) {
    final today = getTodayDateString();
    final newCompletedByDay = Map<String, dynamic>.from(_provider.completedByDay);
    final dayData = Map<String, dynamic>.from(newCompletedByDay[today] ?? {
      'taskTimes': <String, int>{},
      'subtasksCompleted': <Map<String, dynamic>>[],
      'checkpointsCompleted': <Map<String, dynamic>>[] 
    });

    if (type == 'taskTime') {
      final taskTimes = Map<String, int>.from(dayData['taskTimes'] as Map? ?? {});
      taskTimes[data['taskId'] as String] = (taskTimes[data['taskId'] as String] ?? 0) + (data['time'] as int);
      dayData['taskTimes'] = taskTimes;
    } else if (type == 'subtaskCompleted') {
      final subtasksCompleted = List<Map<String, dynamic>>.from(dayData['subtasksCompleted'] as List? ?? []);
      subtasksCompleted.add(data);
      dayData['subtasksCompleted'] = subtasksCompleted;
    } else if (type == 'subSubtaskCompleted') { 
      final checkpointsCompleted = List<Map<String, dynamic>>.from(dayData['checkpointsCompleted'] as List? ?? []);
      checkpointsCompleted.add(data);
      dayData['checkpointsCompleted'] = checkpointsCompleted;
    }

    newCompletedByDay[today] = dayData;
    _provider.setProviderState(completedByDay: newCompletedByDay);
  }

  String addSubtask(String mainTaskId, Map<String, dynamic> subtaskData) {
    final newSubtask = SubTask(
      id: 'sub_${DateTime.now().millisecondsSinceEpoch}_${(_provider.mainTasks.fold<int>(0, (prev, task) => prev + task.subTasks.length) + 1)}',
      name: subtaskData['name'] as String,
      isCountable: subtaskData['isCountable'] as bool? ?? false,
      targetCount: subtaskData['isCountable'] as bool? ?? false ? (subtaskData['targetCount'] as int? ?? 1) : 0,
      subSubTasks: (subtaskData['subSubTasksData'] as List<Map<String, dynamic>>?)
          ?.map((sssData) => SubSubTask(
                id: 'ssub_${DateTime.now().millisecondsSinceEpoch}_${(_provider.mainTasks.fold<int>(0, (prev, task) => prev + task.subTasks.fold<int>(0, (prevSt, st) => prevSt + st.subSubTasks.length)) + 1)}_${sssData['name']?.hashCode ?? 0}',
                name: sssData['name'] as String,
                isCountable: sssData['isCountable'] as bool? ?? false,
                targetCount: sssData['isCountable'] as bool? ?? false ? (sssData['targetCount'] as int? ?? 1) : 0,
              ))
          .toList() ??
          [],
    );

    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id, name: task.name, description: task.description, theme: task.theme, colorHex: task.colorHex,
          streak: task.streak, dailyTimeSpent: task.dailyTimeSpent, lastWorkedDate: task.lastWorkedDate,
          subTasks: [...task.subTasks, newSubtask],
        );
      }
      return task;
    }).toList();
    _provider.setProviderState(mainTasks: newMainTasks);
    return newSubtask.id;
  }

  void updateSubtask(String mainTaskId, String subtaskId, Map<String, dynamic> updates) {
    MainTask? taskToUpdate = _provider.mainTasks.firstWhereOrNull((t) => t.id == mainTaskId);
    if (taskToUpdate == null) return;

    SubTask? subtaskToUpdate = taskToUpdate.subTasks.firstWhereOrNull((s) => s.id == subtaskId);
    if (subtaskToUpdate == null) return;

    final int oldSubtaskTime = subtaskToUpdate.currentTimeSpent;

    if (updates.containsKey('name')) subtaskToUpdate.name = updates['name'] as String;
    if (updates.containsKey('isCountable')) subtaskToUpdate.isCountable = updates['isCountable'] as bool;
    if (updates.containsKey('targetCount')) subtaskToUpdate.targetCount = updates['targetCount'] as int;
    if (updates.containsKey('currentCount')) {
      subtaskToUpdate.currentCount = (updates['currentCount'] as int).clamp(0, subtaskToUpdate.targetCount);
    }
    if (updates.containsKey('currentTimeSpent')) subtaskToUpdate.currentTimeSpent = updates['currentTimeSpent'] as int;

    int timeDifference = 0;
    if (updates.containsKey('currentTimeSpent')) {
      timeDifference = subtaskToUpdate.currentTimeSpent - oldSubtaskTime;
    }

    final Map<String, dynamic> stateUpdatesForSetAndPersist = {};

    if (timeDifference != 0) {
      taskToUpdate.dailyTimeSpent = (taskToUpdate.dailyTimeSpent) + timeDifference;
      taskToUpdate.lastWorkedDate = getTodayDateString();
      logToDailySummary('taskTime', {'taskId': mainTaskId, 'time': timeDifference});
      if (timeDifference > 0) {
        stateUpdatesForSetAndPersist['playerEnergy'] = (_provider.playerEnergy + timeDifference * energyRegenPerMinuteTasked).clamp(0, _provider.calculatedMaxEnergy);
      }
    }

    final int oldDailyTotalBeforeThisChange = taskToUpdate.dailyTimeSpent - timeDifference;
    if (oldDailyTotalBeforeThisChange < dailyTaskGoalMinutes && taskToUpdate.dailyTimeSpent >= dailyTaskGoalMinutes) {
      final double luckBonus = 1 + (_provider.playerGameStats['luck']!.value / 100);
      final double xpBonusFromArtifact = _provider.playerGameStats['bonusXPMod']?.value ?? 0.0;
      final double totalXPMultiplier = luckBonus * (1 + xpBonusFromArtifact);

      stateUpdatesForSetAndPersist['coins'] = _provider.coins + (streakBonusCoins * luckBonus).floor();
      stateUpdatesForSetAndPersist['xp'] = _provider.xp + (streakBonusXp * totalXPMultiplier).floor();
      taskToUpdate.streak = taskToUpdate.streak + 1;
    }

    final newMainTasks = _provider.mainTasks.map((t) => t.id == mainTaskId ? taskToUpdate : t).toList();
    stateUpdatesForSetAndPersist['mainTasks'] = newMainTasks;
    _provider.setProviderState(
      coins: stateUpdatesForSetAndPersist['coins'] as double?,
      xp: stateUpdatesForSetAndPersist['xp'] as double?,
      playerEnergy: stateUpdatesForSetAndPersist['playerEnergy'] as double?,
      mainTasks: newMainTasks,
    );
  }

  bool completeSubtask(String mainTaskId, String subtaskId) {
    MainTask? mainTask = _provider.mainTasks.firstWhereOrNull((t) => t.id == mainTaskId);
    if (mainTask == null) return false;
    SubTask? subTask = mainTask.subTasks.firstWhereOrNull((st) => st.id == subtaskId);
    if (subTask == null || subTask.completed) return false;

    if (subTask.isCountable && subTask.currentCount < subTask.targetCount) {
      return false;
    }
    if (subTask.currentTimeSpent <= 0 && !subTask.isCountable) {
      bool allSubSubTasksDone = subTask.subSubTasks.every((sss) => sss.completed);
      if (subTask.subSubTasks.isNotEmpty && !allSubSubTasksDone) {
          return false;
      }
      if (subTask.subSubTasks.isEmpty && subTask.currentTimeSpent <= 0) {
          return false; 
      }
    }

    ActiveTimerInfo? timerForSubtask = _provider.activeTimers[subtaskId];
    SubTask updatedSubTaskForRewards = SubTask(
      id: subTask.id, name: subTask.name, currentTimeSpent: subTask.currentTimeSpent,
      isCountable: subTask.isCountable, targetCount: subTask.targetCount, currentCount: subTask.currentCount,
      subSubTasks: subTask.subSubTasks
    );

    if (timerForSubtask != null) {
        double totalSecondsToLog = timerForSubtask.accumulatedDisplayTime;
        if (timerForSubtask.isRunning) {
            totalSecondsToLog += (DateTime.now().difference(timerForSubtask.startTime).inMilliseconds) / 1000;
        }
        final int elapsedMinutes = (totalSecondsToLog / 60).round();

        if (elapsedMinutes > 0) {
            updateSubtask(mainTaskId, subtaskId, {'currentTimeSpent': subTask.currentTimeSpent + elapsedMinutes});
            final MainTask? refetchedMainTask = _provider.mainTasks.firstWhereOrNull((t) => t.id == mainTaskId);
             if (refetchedMainTask != null) {
                updatedSubTaskForRewards = refetchedMainTask.subTasks.firstWhereOrNull((st) => st.id == subtaskId) ?? subTask;
            }
        }
        final newActiveTimers = Map<String, ActiveTimerInfo>.from(_provider.activeTimers);
        newActiveTimers.remove(subtaskId);
        _provider.setProviderState(activeTimers: newActiveTimers, doPersist: false);
    }

    final double luckBonus = 1 + (_provider.playerGameStats['luck']!.value / 100);
    final double xpBonusFromArtifact = _provider.playerGameStats['bonusXPMod']?.value ?? 0.0;
    final double totalXPMultiplier = luckBonus * (1 + xpBonusFromArtifact);

    double proportionalXp = 0;
    double proportionalCoins = 0;

    if (updatedSubTaskForRewards.isCountable) {
        proportionalXp = updatedSubTaskForRewards.targetCount * xpPerCountUnitSubtask;
        proportionalCoins = updatedSubTaskForRewards.targetCount * coinsPerCountUnitSubtask;
    } else { 
        proportionalXp = updatedSubTaskForRewards.currentTimeSpent * xpPerMinuteSubtask;
        proportionalCoins = updatedSubTaskForRewards.currentTimeSpent * coinsPerMinuteSubtask;
    }

    final double baseCompletionXp = subtaskCompletionXpBase + _provider.playerLevel + mainTask.streak;
    final double baseCompletionCoins = subtaskCompletionCoinBase + (_provider.playerLevel * 0.5) + (mainTask.streak * 0.2);

    final int finalXpReward = ((baseCompletionXp + proportionalXp) * totalXPMultiplier).floor();
    final int finalCoinReward = ((baseCompletionCoins + proportionalCoins) * luckBonus).floor();

    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id, name: task.name, description: task.description, theme: task.theme, colorHex: task.colorHex,
          streak: task.streak, dailyTimeSpent: task.dailyTimeSpent, lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks.map((st) {
            if (st.id == subtaskId) {
              return SubTask(
                id: st.id, name: st.name, completed: true, completedDate: getTodayDateString(),
                currentTimeSpent: st.currentTimeSpent, isCountable: st.isCountable, targetCount: st.targetCount,
                currentCount: st.currentCount, subSubTasks: st.subSubTasks
              );
            }
            return st;
          }).toList(),
        );
      }
      return task;
    }).toList();

    _provider.setProviderState(
      mainTasks: newMainTasks,
      xp: _provider.xp + finalXpReward,
      coins: _provider.coins + finalCoinReward,
    );

    logToDailySummary('subtaskCompleted', {
      'parentTaskId': mainTask.id,
      'name': updatedSubTaskForRewards.name,
      'timeLogged': updatedSubTaskForRewards.currentTimeSpent,
      'isCountable': updatedSubTaskForRewards.isCountable,
      'currentCount': updatedSubTaskForRewards.currentCount,
      'targetCount': updatedSubTaskForRewards.targetCount
    });
    return true;
  }

  void deleteSubtask(String mainTaskId, String subtaskId) {
    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id, name: task.name, description: task.description, theme: task.theme, colorHex: task.colorHex,
          streak: task.streak, dailyTimeSpent: task.dailyTimeSpent, lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks.where((st) => st.id != subtaskId).toList(),
        );
      }
      return task;
    }).toList();

    final newActiveTimers = Map<String, ActiveTimerInfo>.from(_provider.activeTimers);
    newActiveTimers.remove(subtaskId);
    _provider.setProviderState(mainTasks: newMainTasks, activeTimers: newActiveTimers);
  }

  void duplicateCompletedSubtask(String mainTaskId, String subtaskId) {
    MainTask? taskToUpdate = _provider.mainTasks.firstWhereOrNull((task) => task.id == mainTaskId);
    if (taskToUpdate == null) return;

    SubTask? subTaskToDuplicate = taskToUpdate.subTasks.firstWhereOrNull((st) => st.id == subtaskId);
    if (subTaskToDuplicate == null || !subTaskToDuplicate.completed) return;

    final newSubtask = SubTask(
      id: 'sub_${DateTime.now().millisecondsSinceEpoch}_${(taskToUpdate.subTasks.length + 1)}',
      name: subTaskToDuplicate.name,
      completed: false,
      currentTimeSpent: 0,
      completedDate: null,
      isCountable: subTaskToDuplicate.isCountable,
      targetCount: subTaskToDuplicate.targetCount,
      currentCount: 0,
      subSubTasks: subTaskToDuplicate.subSubTasks.map((sss) => SubSubTask(
        id: 'ssub_${DateTime.now().millisecondsSinceEpoch}_${(subTaskToDuplicate.subSubTasks.length + 1)}_${sss.name.hashCode}',
        name: sss.name,
        completed: false,
        isCountable: sss.isCountable,
        targetCount: sss.targetCount,
        currentCount: 0,
      )).toList(),
    );

    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id, name: task.name, description: task.description, theme: task.theme, colorHex: task.colorHex,
          streak: task.streak, dailyTimeSpent: task.dailyTimeSpent, lastWorkedDate: task.lastWorkedDate,
          subTasks: [...task.subTasks, newSubtask],
        );
      }
      return task;
    }).toList();
    _provider.setProviderState(mainTasks: newMainTasks);
  }

  void addSubSubtask(String mainTaskId, String parentSubtaskId, Map<String, dynamic> subSubtaskData) {
    final newSubSubtask = SubSubTask(
      id: 'ssub_${DateTime.now().millisecondsSinceEpoch}_${subSubtaskData['name']?.hashCode ?? 0}',
      name: subSubtaskData['name'] as String,
      isCountable: subSubtaskData['isCountable'] as bool? ?? false,
      targetCount: subSubtaskData['isCountable'] as bool? ?? false ? (subSubtaskData['targetCount'] as int? ?? 1) : 0,
    );

    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id, name: task.name, description: task.description, theme: task.theme, colorHex: task.colorHex,
          streak: task.streak, dailyTimeSpent: task.dailyTimeSpent, lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks.map((st) {
            if (st.id == parentSubtaskId) {
              return SubTask(
                id: st.id, name: st.name, completed: st.completed, currentTimeSpent: st.currentTimeSpent,
                completedDate: st.completedDate, isCountable: st.isCountable, targetCount: st.targetCount,
                currentCount: st.currentCount,
                subSubTasks: [...st.subSubTasks, newSubSubtask],
              );
            }
            return st;
          }).toList(),
        );
      }
      return task;
    }).toList();
    _provider.setProviderState(mainTasks: newMainTasks);
  }

  void updateSubSubtask(String mainTaskId, String parentSubtaskId, String subSubtaskId, Map<String, dynamic> updates) {
      final newMainTasks = _provider.mainTasks.map((task) {
        if (task.id == mainTaskId) {
            return MainTask(
                id: task.id, name: task.name, description: task.description, theme: task.theme, colorHex: task.colorHex,
                streak: task.streak, dailyTimeSpent: task.dailyTimeSpent, lastWorkedDate: task.lastWorkedDate,
                subTasks: task.subTasks.map((st) {
                    if (st.id == parentSubtaskId) {
                        return SubTask(
                            id: st.id, name: st.name, completed: st.completed, currentTimeSpent: st.currentTimeSpent,
                            completedDate: st.completedDate, isCountable: st.isCountable, targetCount: st.targetCount,
                            currentCount: st.currentCount,
                            subSubTasks: st.subSubTasks.map((sss) {
                                if (sss.id == subSubtaskId) {
                                    final updatedSss = SubSubTask(
                                        id: sss.id,
                                        name: updates['name'] as String? ?? sss.name,
                                        completed: updates['completed'] as bool? ?? sss.completed,
                                        isCountable: updates['isCountable'] as bool? ?? sss.isCountable,
                                        targetCount: updates['targetCount'] as int? ?? sss.targetCount,
                                        currentCount: updates['currentCount'] as int? ?? sss.currentCount,
                                    );
                                    if (updatedSss.isCountable) {
                                        updatedSss.currentCount = updatedSss.currentCount.clamp(0, updatedSss.targetCount);
                                    }
                                    return updatedSss;
                                }
                                return sss;
                            }).toList(),
                        );
                    }
                    return st;
                }).toList(),
            );
        }
        return task;
    }).toList();
    _provider.setProviderState(mainTasks: newMainTasks);
  }

  void completeSubSubtask(String mainTaskId, String parentSubtaskId, String subSubtaskId) {
    double xpReward = 0;
    double coinReward = 0;
    bool subSubTaskCompletedSuccessfully = false;
    SubSubTask? completedSubSubTaskInstance;

    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id, name: task.name, description: task.description, theme: task.theme, colorHex: task.colorHex,
          streak: task.streak, dailyTimeSpent: task.dailyTimeSpent, lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks.map((st) {
            if (st.id == parentSubtaskId) {
              return SubTask(
                id: st.id, name: st.name, completed: st.completed, currentTimeSpent: st.currentTimeSpent,
                completedDate: st.completedDate, isCountable: st.isCountable, targetCount: st.targetCount,
                currentCount: st.currentCount,
                subSubTasks: st.subSubTasks.map((sss) {
                  if (sss.id == subSubtaskId && !sss.completed) {
                    if (sss.isCountable && sss.currentCount < sss.targetCount) {
                      subSubTaskCompletedSuccessfully = false;
                      return sss;
                    }
                    final double luckBonus = 1 + (_provider.playerGameStats['luck']!.value / 100);
                    final double xpBonusFromArtifact = _provider.playerGameStats['bonusXPMod']?.value ?? 0.0;
                    final double totalXPMultiplier = luckBonus * (1 + xpBonusFromArtifact);
                    
                    double proportionalXp = 0;
                    double proportionalCoins = 0;

                    if (sss.isCountable) {
                        proportionalXp = sss.targetCount * xpPerCountUnitSubSubtask;
                        proportionalCoins = sss.targetCount * coinsPerCountUnitSubSubtask;
                    }
                    
                    xpReward = ((subSubtaskCompletionXpBase + proportionalXp) * totalXPMultiplier).floorToDouble();
                    coinReward = ((subSubtaskCompletionCoinBase + proportionalCoins) * luckBonus).floorToDouble();
                    
                    completedSubSubTaskInstance = SubSubTask(
                        id: sss.id, name: sss.name, completed: true, 
                        isCountable: sss.isCountable, targetCount: sss.targetCount, 
                        currentCount: sss.currentCount
                    );
                    subSubTaskCompletedSuccessfully = true;
                    return completedSubSubTaskInstance!;
                  }
                  return sss;
                }).toList(),
              );
            }
            return st;
          }).toList(),
        );
      }
      return task;
    }).toList();

    if (subSubTaskCompletedSuccessfully && completedSubSubTaskInstance != null) {
      _provider.setProviderState(
        mainTasks: newMainTasks,
        xp: _provider.xp + xpReward,
        coins: _provider.coins + coinReward,
      );
      logToDailySummary('subSubtaskCompleted', {
        'mainTaskId': mainTaskId,
        'parentSubtaskId': parentSubtaskId,
        'subSubtaskId': subSubtaskId,
        'name': completedSubSubTaskInstance!.name,
        'isCountable': completedSubSubTaskInstance!.isCountable,
        'currentCount': completedSubSubTaskInstance!.currentCount,
        'targetCount': completedSubSubTaskInstance!.targetCount,
        'parentSubtaskName': _provider.mainTasks.firstWhereOrNull((m) => m.id == mainTaskId)?.subTasks.firstWhereOrNull((s) => s.id == parentSubtaskId)?.name ?? 'N/A',
        'mainTaskName': _provider.mainTasks.firstWhereOrNull((m) => m.id == mainTaskId)?.name ?? 'N/A'
      });
    }
  }

  void deleteSubSubtask(String mainTaskId, String parentSubtaskId, String subSubtaskId) {
    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id, name: task.name, description: task.description, theme: task.theme, colorHex: task.colorHex,
          streak: task.streak, dailyTimeSpent: task.dailyTimeSpent, lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks.map((st) {
            if (st.id == parentSubtaskId) {
              return SubTask(
                id: st.id, name: st.name, completed: st.completed, currentTimeSpent: st.currentTimeSpent,
                completedDate: st.completedDate, isCountable: st.isCountable, targetCount: st.targetCount,
                currentCount: st.currentCount,
                subSubTasks: st.subSubTasks.where((sss) => sss.id != subSubtaskId).toList(),
              );
            }
            return st;
          }).toList(),
        );
      }
      return task;
    }).toList();
    _provider.setProviderState(mainTasks: newMainTasks);
  }
}
--- END OF FILE lib/src/providers/actions/task_actions.dart ---

--- START OF FILE lib/src/providers/actions/item_actions.dart ---
// lib/src/providers/actions/item_actions.dart
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/utils/constants.dart';
import 'package:myapp_flutter/src/models/game_models.dart';
import 'package:myapp_flutter/src/theme/app_theme.dart'; // For colors in log
import 'package:myapp_flutter/src/utils/helpers.dart' as helper;
import 'package:collection/collection.dart'; // For firstWhereOrNull

class ItemActions {
  final GameProvider _provider;

  ItemActions(this._provider);

  OwnedArtifact? getArtifactByUniqueId(String uniqueId) {
      return _provider.artifacts.firstWhereOrNull((art) => art.uniqueId == uniqueId);
  }

  ArtifactTemplate? getArtifactTemplateById(String templateId) {
      return _provider.artifactTemplatesList.firstWhereOrNull((tmpl) => tmpl.id == templateId);
  }

  ArtifactTemplate getArtifactEffectiveStats(OwnedArtifact ownedArtifact) {
    final template = _provider.artifactTemplatesList.firstWhereOrNull((t) => t.id == ownedArtifact.templateId);
    if (template == null) return ArtifactTemplate(id:'', name:'Unknown Artifact', type:'', description: '', cost: 0, icon: '❓');

    final level = ownedArtifact.currentLevel;

    int currentAtt = template.baseAtt ?? 0;
    int currentRunic = template.baseRunic ?? 0;
    int currentDef = template.baseDef ?? 0;
    int currentHealth = template.baseHealth ?? 0;
    int currentLuck = template.baseLuck ?? 0;
    int currentCooldown = template.baseCooldown ?? 0;
    double currentBonusXPMod = template.bonusXPMod ?? 0.0;

    if (template.type != 'powerup' && level > 1 && template.upgradeBonus != null) {
      template.upgradeBonus!.forEach((key, bonusPerLevel) {
        final totalBonusForStat = bonusPerLevel * (level - 1); // Generic for integer bonuses
        final doubleTotalBonusForStat = bonusPerLevel.toDouble() * (level - 1); // Generic for double bonuses

        switch (key) {
          case 'att': currentAtt += totalBonusForStat; break;
          case 'runic': currentRunic += totalBonusForStat; break;
          case 'def': currentDef += totalBonusForStat; break;
          case 'health': currentHealth += totalBonusForStat; break;
          case 'luck': currentLuck += totalBonusForStat; break;
          case 'cooldown': currentCooldown += totalBonusForStat; break;
          // If bonusPerLevel for bonusXPMod is already a decimal (e.g., 0.01 for 1%),
          // then direct multiplication is correct.
          case 'bonusXPMod': currentBonusXPMod += doubleTotalBonusForStat; break;
        }
      });
    }

    return ArtifactTemplate(
      id: template.id, name: template.name, type: template.type, theme: template.theme,
      description: template.description, cost: template.cost, icon: template.icon,
      baseAtt: currentAtt, baseRunic: currentRunic, baseDef: currentDef, baseHealth: currentHealth,
      baseLuck: currentLuck, baseCooldown: currentCooldown, bonusXPMod: currentBonusXPMod,
      upgradeBonus: template.upgradeBonus, maxLevel: template.maxLevel,
      effectType: template.effectType, effectValue: template.effectValue,
      uses: template.type == 'powerup' ? ownedArtifact.uses : template.uses,
    );
  }

  void buyArtifact(String templateId) {
    final template = _provider.artifactTemplatesList.firstWhereOrNull((t) => t.id == templateId);
    if (template == null || _provider.coins < template.cost) return;

    final newArtifactInstance = OwnedArtifact(
      uniqueId: 'artuid_${DateTime.now().millisecondsSinceEpoch}_${template.id.hashCode}',
      templateId: template.id,
      currentLevel: 1,
      uses: template.type == 'powerup' ? template.uses ?? 1 : null,
    );
    _provider.setProviderState(
      coins: _provider.coins - template.cost,
      artifacts: [..._provider.artifacts, newArtifactInstance],
    );
  }

  bool upgradeArtifact(String uniqueId) {
    final ownedArtifact = _provider.artifacts.firstWhereOrNull((a) => a.uniqueId == uniqueId);
    final template = ownedArtifact != null ? _provider.artifactTemplatesList.firstWhereOrNull((t) => t.id == ownedArtifact.templateId) : null;

    if (template == null || ownedArtifact == null || template.type == 'powerup' || ownedArtifact.currentLevel >= (template.maxLevel ?? 1)) return false;

    final upgradeCost = (template.cost * blacksmithUpgradeCostMultiplier * (helper.xpLevelMultiplierPow(1.2, ownedArtifact.currentLevel -1))).floor();
    if (_provider.coins < upgradeCost) return false;

    final newArtifacts = _provider.artifacts.map((art) {
      if (art.uniqueId == uniqueId) {
        return OwnedArtifact(uniqueId: art.uniqueId, templateId: art.templateId, currentLevel: art.currentLevel + 1, uses: art.uses);
      }
      return art;
    }).toList();
    _provider.setProviderState(coins: _provider.coins - upgradeCost, artifacts: newArtifacts);
    return true;
  }

  bool sellArtifact(String uniqueId) {
    final artifactToSell = _provider.artifacts.firstWhereOrNull((a) => a.uniqueId == uniqueId);
    final template = artifactToSell != null ? _provider.artifactTemplatesList.firstWhereOrNull((t) => t.id == artifactToSell.templateId) : null;
    if (template == null || artifactToSell == null) return false;

    double sellMultiplier = 1.0;
    if (template.type == 'powerup' && template.uses != null && template.uses! > 0 && artifactToSell.uses != null) {
        sellMultiplier = (artifactToSell.uses! / template.uses!);
    }
    final int sellPrice = (template.cost * artifactSellPercentage * sellMultiplier).floor();

    final newArtifacts = _provider.artifacts.where((art) => art.uniqueId != uniqueId).toList();
    Map<String, String?> newEquippedItems = Map.from(_provider.equippedItems);
    bool unequipped = false;
    newEquippedItems.forEach((slot, itemId) {
      if (itemId == uniqueId) {
        newEquippedItems[slot] = null;
        unequipped = true;
      }
    });

    final newLog = List<String>.from(_provider.currentGame.log)
      ..add("<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">${template.name} sold for $sellPrice Ø.</span>");

    _provider.setProviderState(
      coins: _provider.coins + sellPrice,
      artifacts: newArtifacts,
      equippedItems: unequipped ? newEquippedItems : _provider.equippedItems,
      currentGame: CurrentGame(
        enemy: _provider.currentGame.enemy,
        playerCurrentHp: _provider.currentGame.playerCurrentHp,
        log: newLog,
      )
    );
    return true;
  }

  void equipArtifact(String uniqueId) {
    final ownedArtifact = _provider.artifacts.firstWhereOrNull((a) => a.uniqueId == uniqueId);
    final template = ownedArtifact != null ? _provider.artifactTemplatesList.firstWhereOrNull((t) => t.id == ownedArtifact.templateId) : null;
    if (template == null || ownedArtifact == null || template.type == 'powerup') return;

    final newEquippedItems = Map<String, String?>.from(_provider.equippedItems);
    newEquippedItems[template.type] = uniqueId;
    _provider.setProviderState(equippedItems: newEquippedItems);
  }

  void unequipArtifact(String slot) {
    final newEquippedItems = Map<String, String?>.from(_provider.equippedItems);
    newEquippedItems[slot] = null;
    _provider.setProviderState(equippedItems: newEquippedItems);
  }
}
--- END OF FILE lib/src/providers/actions/item_actions.dart ---

--- START OF FILE lib/src/providers/actions/timer_actions.dart ---
// lib/src/providers/actions/timer_actions.dart
import 'package:myapp_flutter/src/providers/game_provider.dart';
import 'package:myapp_flutter/src/models/game_models.dart';

class TimerActions {
  final GameProvider _provider;

  TimerActions(this._provider);

  void startTimer(String id, String type, String mainTaskId) {
    Map<String, ActiveTimerInfo> updatedActiveTimers = Map.from(_provider.activeTimers);

    // Pause any other running timer
    for (var entry in updatedActiveTimers.entries) {
      final timerId = entry.key;
      final timerInfo = entry.value;
      if (timerInfo.isRunning && timerId != id) {
        final double elapsed = (DateTime.now().difference(timerInfo.startTime).inMilliseconds) / 1000.0;
        updatedActiveTimers[timerId] = ActiveTimerInfo(
          startTime: timerInfo.startTime,
          accumulatedDisplayTime: timerInfo.accumulatedDisplayTime + elapsed,
          isRunning: false,
          type: timerInfo.type,
          mainTaskId: timerInfo.mainTaskId,
        );
      }
    }

    // Start or resume the selected timer
    final existingTimer = updatedActiveTimers[id];
    updatedActiveTimers[id] = ActiveTimerInfo(
      startTime: DateTime.now(),
      accumulatedDisplayTime: existingTimer?.accumulatedDisplayTime ?? 0, // Retain accumulated time
      isRunning: true,
      type: type,
      mainTaskId: mainTaskId,
    );
    _provider.setProviderState(activeTimers: updatedActiveTimers);
  }

  void pauseTimer(String id) {
    final timer = _provider.activeTimers[id];
    if (timer != null && timer.isRunning) {
      final double elapsed = (DateTime.now().difference(timer.startTime).inMilliseconds) / 1000.0;
      final newActiveTimers = Map<String, ActiveTimerInfo>.from(_provider.activeTimers);
      newActiveTimers[id] = ActiveTimerInfo(
        startTime: timer.startTime, // Keep original startTime, elapsed time is added to accumulated
        accumulatedDisplayTime: timer.accumulatedDisplayTime + elapsed,
        isRunning: false,
        type: timer.type,
        mainTaskId: timer.mainTaskId,
      );
      _provider.setProviderState(activeTimers: newActiveTimers);
    }
  }

  void logTimerAndReset(String id) {
    final timer = _provider.activeTimers[id];
    if (timer != null) {
      double totalSecondsToLog = timer.accumulatedDisplayTime;
      if (timer.isRunning) {
        totalSecondsToLog += (DateTime.now().difference(timer.startTime).inMilliseconds) / 1000.0;
      }
      final int minutesToLog = (totalSecondsToLog / 60).round();

      if (minutesToLog > 0) {
        if (timer.type == 'subtask') {
          final MainTask currentMainTask = _provider.mainTasks.firstWhere((t) => t.id == timer.mainTaskId, orElse: () => MainTask(id:'', name:'', description:'', theme:''));
          if (currentMainTask != null && currentMainTask.id.isNotEmpty) {
            final SubTask subtask = currentMainTask.subTasks.firstWhere((st) => st.id == id, orElse: () => SubTask(id:'', name:''));
            if (subtask != null && subtask.id.isNotEmpty) {
              // Update the subtask's currentTimeSpent
              // This will also trigger daily goal checks and energy regen in updateSubtask
              _provider.updateSubtask(timer.mainTaskId, id, {'currentTimeSpent': subtask.currentTimeSpent + minutesToLog});
            }
          }
        }
      }

      final newActiveTimers = Map<String, ActiveTimerInfo>.from(_provider.activeTimers);
      newActiveTimers.remove(id);
      _provider.setProviderState(activeTimers: newActiveTimers);
    }
  }
}
--- END OF FILE lib/src/providers/actions/timer_actions.dart ---

--- START OF FILE test/widget_test.dart ---
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:myapp_flutter/src/app.dart'; // Changed import
import 'package:provider/provider.dart'; // Added for GameProvider
import 'package:myapp_flutter/src/providers/game_provider.dart'; // Added for GameProvider
import 'package:firebase_core/firebase_core.dart'; // Added for Firebase
import './mock.dart'; // For Firebase mock

void main() {
  // Mock Firebase core setup
  setupFirebaseAuthMocks();

  setUpAll(() async {
    await Firebase.initializeApp();
  });

  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    // Wrap with ChangeNotifierProvider for GameProvider
    await tester.pumpWidget(
      ChangeNotifierProvider(
        create: (context) => GameProvider(), // Provide a GameProvider instance
        child: const MyApp(),
      ),
    );

    // Due to the async nature of Firebase initialization and initial auth state loading,
    // we might need to pump a few times or use pumpAndSettle.
    // For this basic test, we'll assume the LoginScreen shows up first if no user.
    // Or, if a user is mocked/logged in, it might go to HomeScreen.
    // The original test looked for '0' and '1' which suggests a counter.
    // This app structure is different. Let's verify something basic from LoginScreen or HomeScreen.

    // If LoginScreen is expected (no user by default in GameProvider mock or fresh state)
    await tester.pumpAndSettle(); // Wait for UI to stabilize

    // Check if LoginScreen elements are present
    // This is a placeholder. Actual test would depend on GameProvider's initial state.
    // For now, let's assume we get to a state where a MaterialApp is built.
    expect(find.byType(MaterialApp), findsOneWidget);
    
    // The original test was for a counter app, this app is different.
    // This test needs to be adapted to the new app's functionality.
    // For now, a smoke test that the app builds is sufficient.
    // Example: Verify "TASK DOMINION" text from LoginScreen or HeaderWidget appears.
    // As GameProvider might show a loading spinner first, then LoginScreen.
    // final loginTitle = find.text('TASK DOMINION');
    // expect(loginTitle, findsOneWidget); // This might fail depending on initial loading state.
  });
}

--- END OF FILE test/widget_test.dart ---

--- START OF FILE test/mock.dart ---

import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';

// Mock FirebaseAppPlatform
class MockFirebaseAppPlatform extends Mock implements FirebaseAppPlatform {
  @override
  String get name => 'mock'; // Or any other default you prefer
  @override
  FirebaseOptions get options => const FirebaseOptions(
        apiKey: 'mock_api_key',
        appId: 'mock_app_id',
        messagingSenderId: 'mock_sender_id',
        projectId: 'mock_project_id',
      );
}

// Mock FirebaseCorePlatform
class MockFirebaseCorePlatform extends Mock implements FirebasePlatform {
  @override
  Future<FirebaseAppPlatform> initializeApp({
    String? name,
    FirebaseOptions? options,
  }) async {
    return MockFirebaseAppPlatform();
  }

  @override
  List<FirebaseAppPlatform> get apps => [MockFirebaseAppPlatform()];

  @override
  FirebaseAppPlatform app([String name = defaultFirebaseAppName]) {
    return MockFirebaseAppPlatform();
  }
}


void setupFirebaseAuthMocks() {
  TestWidgetsFlutterBinding.ensureInitialized();

  // Mock FirebaseCorePlatform
  final mockCorePlatform = MockFirebaseCorePlatform();
  FirebasePlatform.instance = mockCorePlatform;
  
  // Mock FirebaseAppPlatform (used by Firebase.initializeApp)
  // This part might be tricky as Firebase.initializeApp directly calls native code.
  // For simple unit/widget tests not deeply testing Firebase,
  // ensuring Firebase.initializeApp doesn't throw is often enough.
  // The above mockCorePlatform should handle the Firebase.app() calls.

  // If you are testing Firebase Auth, Firestore, etc., you'd also mock their respective platform interfaces
  // using packages like firebase_auth_mocks, cloud_firestore_mocks, or custom mocks.
}

--- END OF FILE test/mock.dart ---
