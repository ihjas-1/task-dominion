--- START OF FILE .gitattributes ---
# Auto detect text files and perform LF normalization
* text=auto

--- END OF FILE .gitattributes ---

--- START OF FILE .gitignore ---
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.buildlog/
.history
.svn/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.pub-cache/
.pub/
build/
ios/Pods/
ios/DerivedData/
ios/.symlinks/
ios/Flutter/App.framework
ios/Flutter/Flutter.framework
ios/Flutter/Generated.xcconfig
ios/Flutter/flutter_export_environment.sh
# Flutter web builds
web/
app.*.symbols # Android symbols
app.*.map.json # KSM map

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release


# Rider files
.idea/
*.sln
*.suo
*.user
*.rider.*

# VS Code specific
.vscode/settings.json
.vscode/tasks.json
.vscode/launch.json
.vscode/extensions.json
*.code-workspace

# Output files
coverage/
# Ignore files specific to RubyMotion
.repl_history

# Windows builds
windows/flutter/generated_plugins.cmake
windows/flutter/generated_plugin_registrant.cc
windows/flutter/generated_plugin_registrant.h
windows/runner/Debug/
windows/runner/Profile/
windows/runner/Release/
windows/runner/flutter_window.h
windows/runner/flutter_window.cpp
windows/runner/main.cpp
windows/runner/utils.h
windows/runner/utils.cpp
windows/runner/win3.1_resource.rc
windows/plugins/

# Linux builds
linux/flutter/generated_plugins.cmake
linux/flutter/generated_plugin_registrant.cc
linux/flutter/generated_plugin_registrant.h
linux/flutter/ephemeral/
linux/flutter/ephemeral.stamp

# macOS builds
macos/Flutter/GeneratedPluginRegistrant.swift
macos/Flutter/Generated.xcconfig
macos/Flutter/ephemeral_dir_path
macos/Flutter/ephemeral.app
macos/Flutter/Flutter- আরো একবার.h

--- END OF FILE .gitignore ---

--- START OF FILE .metadata ---
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "b25305a8832cfc6ba632a7f87ad455e319dccce8"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8
      base_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8
    - platform: android
      create_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8
      base_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8
    - platform: ios
      create_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8
      base_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8
    - platform: linux
      create_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8
      base_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8
    - platform: macos
      create_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8
      base_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8
    - platform: web
      create_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8
      base_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8
    - platform: windows
      create_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8
      base_revision: b25305a8832cfc6ba632a7f87ad455e319dccce8

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'

--- END OF FILE .metadata ---

--- START OF FILE analysis_options.yaml ---
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule
    # prefer_const_constructors: true # Example of enabling a rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options

--- END OF FILE analysis_options.yaml ---

--- START OF FILE devtools_options.yaml ---
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:

--- END OF FILE devtools_options.yaml ---

--- START OF FILE firebase.json ---
{"flutter":{"platforms":{"android":{"default":{"projectId":"task-dominion","appId":"1:1059901273076:android:bdeb039da1e16ab1843fa1","fileOutput":"android/app/google-services.json"}},"dart":{"lib/firebase_options.dart":{"projectId":"task-dominion","configurations":{"android":"1:1059901273076:android:bdeb039da1e16ab1843fa1","web":"1:1059901273076:web:86c0ab680c91dc5f843fa1","windows":"1:1059901273076:web:86c0ab680c91dc5f843fa1"}}}}}}
--- END OF FILE firebase.json ---

--- START OF FILE pubspec.lock ---
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  _fe_analyzer_shared:
    dependency: transitive
    description:
      name: _fe_analyzer_shared
      sha256: e55636ed79578b9abca5fecf9437947798f5ef7456308b5cb85720b793eac92f
      url: "https://pub.dev"
    source: hosted
    version: "82.0.0"
  _flutterfire_internals:
    dependency: transitive
    description:
      name: _flutterfire_internals
      sha256: "214e6f07e2a44f45972e0365c7b537eaeaddb4598db0778dd4ac64b4acd3f5b1"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.55"
  analyzer:
    dependency: transitive
    description:
      name: analyzer
      sha256: "904ae5bb474d32c38fb9482e2d925d5454cda04ddd0e55d2e6826bc72f6ba8c0"
      url: "https://pub.dev"
    source: hosted
    version: "7.4.5"
  archive:
    dependency: transitive
    description:
      name: archive
      sha256: "2fde1607386ab523f7a36bb3e7edb43bd58e6edaf2ffb29d8a6d578b297fdbbd"
      url: "https://pub.dev"
    source: hosted
    version: "4.0.7"
  args:
    dependency: transitive
    description:
      name: args
      sha256: d0481093c50b1da8910eb0bb301626d4d8eb7284aa739614d2b394ee09e3ea04
      url: "https://pub.dev"
    source: hosted
    version: "2.7.0"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "758e6d74e971c3e5aceb4110bfd6698efc7f501675bcfe0c775459a8140750eb"
      url: "https://pub.dev"
    source: hosted
    version: "2.13.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "8aab1771e1243a5063b8b0ff68042d67334e3feab9e95b9490f9a6ebf73b42ea"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  build:
    dependency: transitive
    description:
      name: build
      sha256: cef23f1eda9b57566c81e2133d196f8e3df48f244b317368d65c5943d91148f0
      url: "https://pub.dev"
    source: hosted
    version: "2.4.2"
  built_collection:
    dependency: transitive
    description:
      name: built_collection
      sha256: "376e3dd27b51ea877c28d525560790aee2e6fbb5f20e2f85d5081027d94e2100"
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  built_value:
    dependency: transitive
    description:
      name: built_value
      sha256: ea90e81dc4a25a043d9bee692d20ed6d1c4a1662a28c03a96417446c093ed6b4
      url: "https://pub.dev"
    source: hosted
    version: "8.9.5"
  change_app_package_name:
    dependency: "direct dev"
    description:
      name: change_app_package_name
      sha256: "8e43b754fe960426904d77ed4c62fa8c9834deaf6e293ae40963fa447482c4c5"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.0"
  characters:
    dependency: transitive
    description:
      name: characters
      sha256: f71061c654a3380576a52b451dd5532377954cf9dbd272a78fc8479606670803
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  checked_yaml:
    dependency: transitive
    description:
      name: checked_yaml
      sha256: feb6bed21949061731a7a75fc5d2aa727cf160b91af9a3e464c5e3a32e28b5ff
      url: "https://pub.dev"
    source: hosted
    version: "2.0.3"
  cli_util:
    dependency: transitive
    description:
      name: cli_util
      sha256: ff6785f7e9e3c38ac98b2fb035701789de90154024a75b6cb926445e83197d1c
      url: "https://pub.dev"
    source: hosted
    version: "0.4.2"
  clock:
    dependency: transitive
    description:
      name: clock
      sha256: fddb70d9b5277016c77a80201021d40a2247104d9f4aa7bab7157b7e3f05b84b
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  cloud_firestore:
    dependency: "direct main"
    description:
      name: cloud_firestore
      sha256: d25c956be5261c14bc9a69c9662de8addb308376b4b53a64469aade52e7b02f8
      url: "https://pub.dev"
    source: hosted
    version: "5.6.8"
  cloud_firestore_platform_interface:
    dependency: transitive
    description:
      name: cloud_firestore_platform_interface
      sha256: ee2b8f8c602ede36073afd3741e99cfea9dd982b4a44833daf665134d151c32a
      url: "https://pub.dev"
    source: hosted
    version: "6.6.8"
  cloud_firestore_web:
    dependency: transitive
    description:
      name: cloud_firestore_web
      sha256: b99bc4f1f70787f694b73bc6fce238d4d6cc822c9b31ba8ef1578b180b6f77bc
      url: "https://pub.dev"
    source: hosted
    version: "4.4.8"
  code_builder:
    dependency: transitive
    description:
      name: code_builder
      sha256: "0ec10bf4a89e4c613960bf1e8b42c64127021740fb21640c29c909826a5eea3e"
      url: "https://pub.dev"
    source: hosted
    version: "4.10.1"
  collection:
    dependency: "direct main"
    description:
      name: collection
      sha256: "2f5709ae4d3d59dd8f7cd309b4e023046b57d8a6c82130785d2b0e5868084e76"
      url: "https://pub.dev"
    source: hosted
    version: "1.19.1"
  convert:
    dependency: transitive
    description:
      name: convert
      sha256: b30acd5944035672bc15c6b7a8b47d773e41e2f17de064350988c5d02adb1c68
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: "1e445881f28f22d6140f181e07737b22f1e099a5e1ff94b0af2f9e4a463f4855"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.6"
  cupertino_icons:
    dependency: "direct main"
    description:
      name: cupertino_icons
      sha256: ba631d1c7f7bef6b729a622b7b752645a2d076dba9976925b8f25725a30e1ee6
      url: "https://pub.dev"
    source: hosted
    version: "1.0.8"
  dart_style:
    dependency: transitive
    description:
      name: dart_style
      sha256: "27eb0ae77836989a3bc541ce55595e8ceee0992807f14511552a898ddd0d88ac"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.1"
  equatable:
    dependency: transitive
    description:
      name: equatable
      sha256: "567c64b3cb4cf82397aac55f4f0cbd3ca20d77c6c03bedbc4ceaddc08904aef7"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.7"
  fake_async:
    dependency: transitive
    description:
      name: fake_async
      sha256: "5368f224a74523e8d2e7399ea1638b37aecfca824a3cc4dfdf77bf1fa905ac44"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.3"
  ffi:
    dependency: transitive
    description:
      name: ffi
      sha256: "289279317b4b16eb2bb7e271abccd4bf84ec9bdcbe999e278a94b804f5630418"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  file:
    dependency: transitive
    description:
      name: file
      sha256: a3b4f84adafef897088c160faf7dfffb7696046cb13ae90b508c2cbc95d3b8d4
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  firebase_auth:
    dependency: "direct main"
    description:
      name: firebase_auth
      sha256: "10cd3f00a247f33b0a5c77574011a87379432bf3fec77a500b55f2bcc30ddd8b"
      url: "https://pub.dev"
    source: hosted
    version: "5.5.4"
  firebase_auth_platform_interface:
    dependency: transitive
    description:
      name: firebase_auth_platform_interface
      sha256: "2d15872a8899b0459fab6b4c148fd142e135acfc8a303d383d80b455e4dba7bd"
      url: "https://pub.dev"
    source: hosted
    version: "7.6.3"
  firebase_auth_web:
    dependency: transitive
    description:
      name: firebase_auth_web
      sha256: efba45393050ca03d992eae1d305d5fc8c0c9f5980624053512e935c23767c4f
      url: "https://pub.dev"
    source: hosted
    version: "5.14.3"
  firebase_core:
    dependency: "direct main"
    description:
      name: firebase_core
      sha256: "8cfe3c900512399ce8d50fcc817e5758ff8615eeb6fa5c846a4cc47bbf6353b6"
      url: "https://pub.dev"
    source: hosted
    version: "3.13.1"
  firebase_core_platform_interface:
    dependency: "direct main"
    description:
      name: firebase_core_platform_interface
      sha256: d7253d255ff10f85cfd2adaba9ac17bae878fa3ba577462451163bd9f1d1f0bf
      url: "https://pub.dev"
    source: hosted
    version: "5.4.0"
  firebase_core_web:
    dependency: transitive
    description:
      name: firebase_core_web
      sha256: ddd72baa6f727e5b23f32d9af23d7d453d67946f380bd9c21daf474ee0f7326e
      url: "https://pub.dev"
    source: hosted
    version: "2.23.0"
  fixnum:
    dependency: transitive
    description:
      name: fixnum
      sha256: b6dc7065e46c974bc7c5f143080a6764ec7a4be6da1285ececdc37be96de53be
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  fl_chart:
    dependency: "direct main"
    description:
      name: fl_chart
      sha256: "577aeac8ca414c25333334d7c4bb246775234c0e44b38b10a82b559dd4d764e7"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_colorpicker:
    dependency: "direct main"
    description:
      name: flutter_colorpicker
      sha256: "969de5f6f9e2a570ac660fb7b501551451ea2a1ab9e2097e89475f60e07816ea"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  flutter_launcher_icons:
    dependency: "direct dev"
    description:
      name: flutter_launcher_icons
      sha256: "526faf84284b86a4cb36d20a5e45147747b7563d921373d4ee0559c54fcdbcea"
      url: "https://pub.dev"
    source: hosted
    version: "0.13.1"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      sha256: "5398f14efa795ffb7a33e9b6a08798b26a180edac4ad7db3f231e40f82ce11e1"
      url: "https://pub.dev"
    source: hosted
    version: "5.0.0"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_web_plugins:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  glob:
    dependency: transitive
    description:
      name: glob
      sha256: c3f1ee72c96f8f78935e18aa8cecced9ab132419e8625dc187e1c2408efc20de
      url: "https://pub.dev"
    source: hosted
    version: "2.1.3"
  google_generative_ai:
    dependency: "direct main"
    description:
      name: google_generative_ai
      sha256: "71f613d0247968992ad87a0eb21650a566869757442ba55a31a81be6746e0d1f"
      url: "https://pub.dev"
    source: hosted
    version: "0.4.7"
  http:
    dependency: transitive
    description:
      name: http
      sha256: "2c11f3f94c687ee9bad77c171151672986360b2b001d109814ee7140b2cf261b"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "178d74305e7866013777bab2c3d8726205dc5a4dd935297175b19a23a2e66571"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.2"
  image:
    dependency: transitive
    description:
      name: image
      sha256: "4e973fcf4caae1a4be2fa0a13157aa38a8f9cb049db6529aa00b4d71abc4d928"
      url: "https://pub.dev"
    source: hosted
    version: "4.5.4"
  intl:
    dependency: "direct main"
    description:
      name: intl
      sha256: "3df61194eb431efc39c4ceba583b95633a403f46c9fd341e550ce0bfa50e9aa5"
      url: "https://pub.dev"
    source: hosted
    version: "0.20.2"
  json_annotation:
    dependency: transitive
    description:
      name: json_annotation
      sha256: "1ce844379ca14835a50d2f019a3099f419082cfdd231cd86a142af94dd5c6bb1"
      url: "https://pub.dev"
    source: hosted
    version: "4.9.0"
  leak_tracker:
    dependency: transitive
    description:
      name: leak_tracker
      sha256: "6bb818ecbdffe216e81182c2f0714a2e62b593f4a4f13098713ff1685dfb6ab0"
      url: "https://pub.dev"
    source: hosted
    version: "10.0.9"
  leak_tracker_flutter_testing:
    dependency: transitive
    description:
      name: leak_tracker_flutter_testing
      sha256: f8b613e7e6a13ec79cfdc0e97638fddb3ab848452eff057653abd3edba760573
      url: "https://pub.dev"
    source: hosted
    version: "3.0.9"
  leak_tracker_testing:
    dependency: transitive
    description:
      name: leak_tracker_testing
      sha256: "6ba465d5d76e67ddf503e1161d1f4a6bc42306f9d66ca1e8f079a47290fb06d3"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.1"
  lints:
    dependency: transitive
    description:
      name: lints
      sha256: c35bb79562d980e9a453fc715854e1ed39e24e7d0297a880ef54e17f9874a9d7
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  logging:
    dependency: transitive
    description:
      name: logging
      sha256: c8245ada5f1717ed44271ed1c26b8ce85ca3228fd2ffdb75468ab01979309d61
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  lucide_icons:
    dependency: "direct main"
    description:
      name: lucide_icons
      sha256: ad24d0fd65707e48add30bebada7d90bff2a1bba0a72d6e9b19d44246b0e83c4
      url: "https://pub.dev"
    source: hosted
    version: "0.257.0"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: dc58c723c3c24bf8d3e2d3ad3f2f9d7bd9cf43ec6feaa64181775e60190153f2
      url: "https://pub.dev"
    source: hosted
    version: "0.12.17"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      sha256: f7142bb1154231d7ea5f96bc7bde4bda2a0945d2806bb11670e30b850d56bdec
      url: "https://pub.dev"
    source: hosted
    version: "0.11.1"
  material_design_icons_flutter:
    dependency: "direct main"
    description:
      name: material_design_icons_flutter
      sha256: "6f986b7a51f3ad4c00e33c5c84e8de1bdd140489bbcdc8b66fc1283dad4dea5a"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.7296"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: e3641ec5d63ebf0d9b41bd43201a66e3fc79a65db5f61fc181f04cd27aab950c
      url: "https://pub.dev"
    source: hosted
    version: "1.16.0"
  mockito:
    dependency: "direct dev"
    description:
      name: mockito
      sha256: "4546eac99e8967ea91bae633d2ca7698181d008e95fa4627330cf903d573277a"
      url: "https://pub.dev"
    source: hosted
    version: "5.4.6"
  nested:
    dependency: transitive
    description:
      name: nested
      sha256: "03bac4c528c64c95c722ec99280375a6f2fc708eec17c7b3f07253b626cd2a20"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  package_config:
    dependency: transitive
    description:
      name: package_config
      sha256: f096c55ebb7deb7e384101542bfba8c52696c1b56fca2eb62827989ef2353bbc
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  path:
    dependency: transitive
    description:
      name: path
      sha256: "75cca69d1490965be98c73ceaea117e8a04dd21217b37b292c9ddbec0d955bc5"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.1"
  petitparser:
    dependency: transitive
    description:
      name: petitparser
      sha256: "07c8f0b1913bcde1ff0d26e57ace2f3012ccbf2b204e070290dad3bb22797646"
      url: "https://pub.dev"
    source: hosted
    version: "6.1.0"
  plugin_platform_interface:
    dependency: transitive
    description:
      name: plugin_platform_interface
      sha256: "4820fbfdb9478b1ebae27888254d445073732dae3d6ea81f0b7e06d5dedc3f02"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.8"
  posix:
    dependency: transitive
    description:
      name: posix
      sha256: f0d7856b6ca1887cfa6d1d394056a296ae33489db914e365e2044fdada449e62
      url: "https://pub.dev"
    source: hosted
    version: "6.0.2"
  provider:
    dependency: "direct main"
    description:
      name: provider
      sha256: "4abbd070a04e9ddc287673bf5a030c7ca8b685ff70218720abab8b092f53dd84"
      url: "https://pub.dev"
    source: hosted
    version: "6.1.5"
  pub_semver:
    dependency: transitive
    description:
      name: pub_semver
      sha256: "5bfcf68ca79ef689f8990d1160781b4bad40a3bd5e5218ad4076ddb7f4081585"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  source_gen:
    dependency: transitive
    description:
      name: source_gen
      sha256: "35c8150ece9e8c8d263337a265153c3329667640850b9304861faea59fc98f6b"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "254ee5351d6cb365c859e20ee823c3bb479bf4a293c22d17a9f1bf144ce86f7c"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.1"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "8b27215b45d22309b5cddda1aa2b19bdfec9df0e765f2de506401c071d38d1b1"
      url: "https://pub.dev"
    source: hosted
    version: "1.12.1"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: "969e04c80b8bcdf826f8f16579c7b14d780458bd97f56d107d3950fdbeef059d"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "921cd31725b72fe181906c6a94d987c78e3b98c2e205b397ea399d4054872b43"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: "7f554798625ea768a7518313e58f83891c7f5024f88e46e7182a4558850a4b8e"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.2"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: fb31f383e2ee25fbbfe06b40fe21e1e458d14080e3c67e7ba0acfde4df4e0bbd
      url: "https://pub.dev"
    source: hosted
    version: "0.7.4"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: f9049c039ebfeb4cf7a7104a675823cd72dba8297f264b6637062516699fa006
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      sha256: "80b3257d1492ce4d091729e3a67a60407d227c27241d6927be0130c98e741803"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: ddfa8d30d89985b96407efce8acbdd124701f96741f2d981ca860662f1c0dc02
      url: "https://pub.dev"
    source: hosted
    version: "15.0.0"
  watcher:
    dependency: transitive
    description:
      name: watcher
      sha256: "69da27e49efa56a15f8afe8f4438c4ec02eff0a117df1b22ea4aad194fe1c104"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  web:
    dependency: transitive
    description:
      name: web
      sha256: "868d88a33d8a87b18ffc05f9f030ba328ffefba92d6c127917a2ba740f9cfe4a"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  xml:
    dependency: transitive
    description:
      name: xml
      sha256: b015a8ad1c488f66851d762d3090a21c600e479dc75e68328c52774040cf9226
      url: "https://pub.dev"
    source: hosted
    version: "6.5.0"
  yaml:
    dependency: transitive
    description:
      name: yaml
      sha256: b9da305ac7c39faa3f030eccd175340f968459dae4af175130b3fc47e40d76ce
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
sdks:
  dart: ">=3.7.0 <4.0.0"
  flutter: ">=3.27.4"

--- END OF FILE pubspec.lock ---

--- START OF FILE pubspec.yaml ---
name: arcane
description: "A Flutter version of the Task Dominion application."
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

version: 1.0.3+3 # Incremented version

environment:
  sdk: '>=3.3.0 <4.0.0'


dependencies:
  flutter:
    sdk: flutter

  # Firebase
  firebase_core: ^3.13.1
  firebase_core_platform_interface: ^5.4.0
  firebase_auth: ^5.5.4
  cloud_firestore: ^5.6.8

  # State Management
  provider: ^6.1.2

  # AI
  google_generative_ai: ^0.4.0 

  # UI & Utilities
  cupertino_icons: ^1.0.6
  intl: ^0.20.2 # For date formatting
  fl_chart: ^1.0.0 # For charts
  material_design_icons_flutter: ^7.0.7296 # For extra icons
  collection: ^1.18.0
  lucide_icons: ^0.257.0
  flutter_colorpicker: ^1.1.0 # For task color selection


dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0
  mockito: ^5.4.4 
  change_app_package_name: ^1.1.0 
  flutter_launcher_icons: ^0.13.1

flutter_launcher_icons:
  android: true
  ios: true
  image_path: "assets/fonts/icons/new_ic.png" # Path to your single PNG icon
  adaptive_icon_background: "#000000" # Or "assets/icon/background.png"
  adaptive_icon_foreground: "assets/fonts/icons/icon.png"
  min_sdk_android: 21 # Minimum Android SDK version supported (usually default is fine)
  web:
    generate: true
    image_path: "assets/fonts/icons/icon.png"
    background_color: "#000000"
    theme_color: "#000000"
  windows:
    generate: true
    image_path: "assets/fonts/icons/icon.png"
    icon_size: 48 # Or other supported sizes (48 to 256)
  macos:
    generate: true
    image_path: "assets/fonts/icons/icon.png"



flutter:
  uses-material-design: true

  assets: []
  #   - assets/images/valorant-bg-example.png # Example if adding a background image

  fonts:
    - family: RobotoCondensed
      fonts:
        - asset: assets/fonts/RobotoCondensed-Regular.ttf
        - asset: assets/fonts/RobotoCondensed-Bold.ttf
          weight: 700
    - family: OpenSans
      fonts:
        - asset: assets/fonts/OpenSans-Regular.ttf
        - asset: assets/fonts/OpenSans-SemiBold.ttf
          weight: 600
    # Note: For true Valorant fonts like "Tungsten" or "DIN Next LT Pro",
    # you would need to acquire the font files (ensure licensing) and declare them here.
    # Example:
    # - family: Tungsten
    #   fonts:
    #     - asset: assets/fonts/Tungsten-Bold.ttf # (if you had this file)
    #       weight: 700

--- END OF FILE pubspec.yaml ---

--- START OF FILE README.md ---
# arcane

A Flutter version of the Task Dominion application.

## Getting Started

This project is a starting point for a Flutter application.

A few resources to get you started if this is your first Flutter project:

- [Lab: Write your first Flutter app](https://docs.flutter.dev/get-started/codelab)
- [Cookbook: Useful Flutter samples](https://docs.flutter.dev/cookbook)

For help getting started with Flutter development, view the
[online documentation](https://docs.flutter.dev/), which offers tutorials,
samples, guidance on mobile development, and a full API reference.

## Firebase Setup

This project uses Firebase. To configure it:
1. Make sure you have the FlutterFire CLI installed: `flutter`
2. Run `flutterfire configure` in the project root and select your Firebase project. This will generate `lib/firebase_options.dart`.

## API Keys

AI features require API keys. Create a file `lib/src/config/api_keys.dart` with your Gemini API keys:
```dart
// lib/src/config/api_keys.dart
// IMPORTANT: Add this file to your .gitignore
const List<String> GEMINI_API_KEYS = ['YOUR_GEMINI_API_KEY_1_HERE'];
const String GEMINI_MODEL_NAME = 'gemini-1.5-flash-latest'; // Or your preferred model
```
Ensure this file is added to your `.gitignore`.

--- END OF FILE README.md ---

--- START OF FILE .github/workflows/android-release.yml ---
name: Flutter Android Release Build & Upload

on:
  push:
    branches:
      - main # Triggers the workflow on pushes to the 'main' branch.
            # You can list other branches here, e.g., ['main', 'develop']
            # Or remove 'branches' entirely to run on all pushes to any branch.

permissions:
  contents: write # Required to create/edit GitHub Releases and upload assets

jobs:
  build_apk_and_upload:
    runs-on: ubuntu-latest # Use the latest Ubuntu runner

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4 # Checks out your repository code

      - name: Set up Java
        uses: actions/setup-java@v4 # Sets up Java Development Kit (JDK)
        with:
          distribution: 'temurin' # Recommended distribution for Java
          java-version: '17'      # Flutter typically requires Java 17 or newer

      - name: Set up Flutter SDK
        uses: subosito/flutter-action@v2 # Action to set up Flutter SDK
        with:
          flutter-version: '3.32' # Specify the Flutter version.
                                  # Note: Verify if '3.32' is a valid Flutter release version.
                                  # Flutter versions usually follow major.minor.patch (e.g., 3.19.6, 3.22.0).
                                  # If not found, this step might fail or use a different version.
          channel: 'stable'       # Use the stable Flutter channel

      - name: Get Flutter Dependencies
        run: flutter pub get # Fetches all the dependencies listed in pubspec.yaml

      - name: Build Android Release APK
        run: flutter build apk --release # Builds the Android application in release mode
        # The output APK will typically be found at build/app/outputs/apk/release/app-release.apk

      - name: Upload APK to GitHub Release
        uses: softprops/action-gh-release@v1 # Action to create or update a GitHub Release
        with:
          files: build/app/outputs/apk/release/app-release.apk # Path to the generated APK file
          tag_name: ${{ github.ref_name }} # Uses the branch name or tag name that triggered the workflow
          name: Build ${{ github.ref_name }} - ${{ github.run_number }} # Sets the name of the GitHub Release
          body: |
            Automated build for branch `${{ github.ref_name }}`.
            This release includes the Android APK.
            Triggered by commit: ${{ github.sha }}
          draft: false # Set to true if you want to create a draft release first
          prerelease: false # Set to true if this is a pre-release version
          token: ${{ secrets.GITHUB_TOKEN }} # GitHub automatically provides this token for authentication

--- END OF FILE .github/workflows/android-release.yml ---

--- START OF FILE .idx/dev.nix ---
# To learn more about how to use Nix to configure your environment
# see: https://firebase.google.com/docs/studio/customize-workspace
{ pkgs, ... }: {
  # Which nixpkgs channel to use.
  channel = "stable-24.05"; # or "unstable"
  # Use https://search.nixos.org/packages to find packages
  packages = [
    pkgs.flutter # Add Flutter SDK
    pkgs.jdk17   # For Android development
    pkgs.unzip   # General utility
    pkgs.python3
    # For Android SDK command line tools if not managed by Flutter/Android Studio
    # pkgs.android-tools 
  ];
  # Sets environment variables in the workspace
  env = {
     # Example: If Android SDK is installed via Nix and not auto-detected by Flutter
     # ANDROID_SDK_ROOT = "${pkgs.android-sdk}/libexec/android-sdk";
  };
  idx = {
    # Search for the extensions you want on https://open-vsx.org/ and use "publisher.id"
    extensions = [
      "Dart-Code.flutter"
      "Dart-Code.dart-code"
    ];
    workspace = {
      # Runs when a workspace is first created with this `dev.nix` file
      onCreate = {
        # Optional: Run flutter doctor to check setup
        flutter-doctor = "flutter doctor";
        flutter-setup1 = "cd ..;wget https://storage.googleapis.com/flutter_infra_release/releases/stable/linux/flutter_linux_3.32.0-stable.tar.xz && tar -xJvf ./flutter_linux_3.32.0-stable.tar.xz ";
      };
      # To run something each time the workspace is (re)started, use the `onStart` hook
    };
    # Enable previews and customize configuration
    previews = {
      enable = true;
      previews = {
        web = {
          command = ["/home/user/flutter/bin/flutter" "run" "--machine" "-d" "web-server" "--web-hostname" "0.0.0.0" "--web-port" "$PORT"];
          manager = "flutter";
        };
        # Android preview might require more setup for emulators within Project IDX
      #  android = {
      #      command = ["/home/user/flutter/bin/flutter" "run" "--machine" "-d" "android" "-d" "localhost:5555"];
      #      manager = "flutter";
      #    };
       };
    };
  };
}

--- END OF FILE .idx/dev.nix ---

--- START OF FILE lib/firebase_options.dart ---
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for ios - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyC1VzXpHEKVCNfXZAHQ1eWJQo1ruzO1-oY',
    appId: '1:1059901273076:web:86c0ab680c91dc5f843fa1',
    messagingSenderId: '1059901273076',
    projectId: 'task-dominion',
    authDomain: 'task-dominion.firebaseapp.com',
    databaseURL: 'https://task-dominion-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'task-dominion.firebasestorage.app',
    measurementId: 'G-TZTWWCQMCY',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyBeZsAoZiV38vUrdzbZP4wBGbOCBGluAZg',
    appId: '1:1059901273076:android:bdeb039da1e16ab1843fa1',
    messagingSenderId: '1059901273076',
    projectId: 'task-dominion',
    databaseURL: 'https://task-dominion-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'task-dominion.firebasestorage.app',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyC1VzXpHEKVCNfXZAHQ1eWJQo1ruzO1-oY',
    appId: '1:1059901273076:web:86c0ab680c91dc5f843fa1',
    messagingSenderId: '1059901273076',
    projectId: 'task-dominion',
    authDomain: 'task-dominion.firebaseapp.com',
    databaseURL: 'https://task-dominion-default-rtdb.asia-southeast1.firebasedatabase.app',
    storageBucket: 'task-dominion.firebasestorage.app',
    measurementId: 'G-TZTWWCQMCY',
  );
}

--- END OF FILE lib/firebase_options.dart ---

--- START OF FILE lib/main.dart ---
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:arcane/src/app.dart';
import 'package:arcane/firebase_options.dart'; // Auto-generated by FlutterFire
import 'package:arcane/src/providers/game_provider.dart';
import 'package:provider/provider.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(
    ChangeNotifierProvider(
      create: (context) => GameProvider(),
      child: const MyApp(),
    ),
  );
}

--- END OF FILE lib/main.dart ---

--- START OF FILE lib/src/app.dart ---
import 'package:flutter/material.dart';
import 'package:arcane/src/screens/home_screen.dart';
import 'package:arcane/src/screens/login_screen.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:provider/provider.dart';

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  @override
  Widget build(BuildContext context) {
    // Watch the GameProvider for changes.
    // When the GameProvider notifies its listeners (e.g., selected task changes),
    // this build method will be re-executed.
    final gameProvider = context.watch<GameProvider>();

    // Determine the current accent color based on the selected task.
    // If no task is selected, default to AppTheme.fhAccentTealFixed.
    final Color currentTaskColor =
        gameProvider.getSelectedTask()?.taskColor ?? AppTheme.fhAccentTealFixed;

    print(
        "[MyApp] Building MaterialApp with theme based on color: $currentTaskColor"); // DEBUG

    return MaterialApp(
      title: 'Task Dominion',
      // The theme data is now dynamically generated in the build method.
      // Any change to `currentTaskColor` (which comes from `gameProvider`)
      // will cause this `MaterialApp` to rebuild with the new theme.
      theme: AppTheme.getThemeData(primaryAccent: currentTaskColor),
      debugShowCheckedModeBanner: false,
      home: Consumer<GameProvider>(
        builder: (context, gameProvider, child) {
          print(
              "[MyApp Consumer] AuthLoading: ${gameProvider.authLoading}, CurrentUser: ${gameProvider.currentUser?.uid}, DataLoadingAfterLogin: ${gameProvider.isDataLoadingAfterLogin}"); // DEBUG

          // Show a loading indicator if authentication is in progress or
          // if a user is logged in but data is still loading.
          if (gameProvider.authLoading ||
              (gameProvider.currentUser != null &&
                  gameProvider.isDataLoadingAfterLogin)) {
            print("[MyApp Consumer] Showing loading indicator"); // DEBUG
            return const Scaffold(
              body: Center(child: CircularProgressIndicator()),
            );
          }
          // If no user is logged in, show the LoginScreen.
          if (gameProvider.currentUser == null) {
            print("[MyApp Consumer] Showing LoginScreen"); // DEBUG
            return const LoginScreen();
          }
          // Otherwise, show the HomeScreen for authenticated users.
          print("[MyApp Consumer] Showing HomeScreen"); // DEBUG
          return const HomeScreen();
        },
      ),
    );
  }
}

--- END OF FILE lib/src/app.dart ---

--- START OF FILE lib/src/config/api_keys.dart ---
// lib/src/config/api_keys.dart
// IMPORTANT: Add this file to your .gitignore
// ignore_for_file: constant_identifier_names
const List<String> geminiApiKeys = ['AIzaSyAjyofndMStYX6AT_C8CIBj-GZZeObA0PQ','AIzaSyAu9swfNci4KFg63TjnxoV9zCfwXz9wuuA','AIzaSyB97ORZRyH0Ke154I8WjvhD5G-WUTIuDd4','AIzaSyB97ORZRyH0Ke154I8WjvhD5G-WUTIuDd4','AIzaSyB97ORZRyH0Ke154I8WjvhD5G-WUTIuDd4'];

const String geminiModelName = 'gemini-2.0-flash'; // Updated to consistent model name
--- END OF FILE lib/src/config/api_keys.dart ---

--- START OF FILE lib/src/models/game_models.dart ---
// lib/src/models/game_models.dart
// import 'package:arcane/src/utils/constants.dart'; // No longer needed here for constants
import 'package:collection/collection.dart'; // For firstWhereOrNull
import 'package:flutter/material.dart'; // For Color
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:arcane/src/theme/app_theme.dart'; // For MdiIcons

class MainTask {
  String id;
  String name;
  String description;
  String theme;
  String colorHex; // e.g., "FF64FFDA"
  int streak;
  int dailyTimeSpent;
  String? lastWorkedDate;
  List<SubTask> subTasks;

  MainTask({
    required this.id,
    required this.name,
    required this.description,
    required this.theme,
    this.colorHex = "FF00F8F8", // Default to a vibrant cyan
    this.streak = 0,
    this.dailyTimeSpent = 0,
    this.lastWorkedDate,
    List<SubTask>? subTasks,
  }) : subTasks = subTasks ?? [];

  // Factory from MainTaskTemplate (which is now in this file)
  factory MainTask.fromTemplate(MainTaskTemplate template) {
    return MainTask(
      id: template.id,
      name: template.name,
      description: template.description,
      theme: template.theme,
      colorHex: template.colorHex,
    );
  }

  factory MainTask.fromJson(Map<String, dynamic> json) {
    return MainTask(
      id: json['id'] as String,
      name: json['name'] as String,
      description: json['description'] as String,
      theme: json['theme'] as String,
      colorHex: json['colorHex'] as String? ?? "FF00F8F8",
      streak: json['streak'] as int? ?? 0,
      dailyTimeSpent: json['dailyTimeSpent'] as int? ?? 0,
      lastWorkedDate: json['lastWorkedDate'] as String?,
      subTasks: (json['subTasks'] as List<dynamic>?)
              ?.map(
                  (stJson) => SubTask.fromJson(stJson as Map<String, dynamic>))
              .toList() ??
          [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'theme': theme,
      'colorHex': colorHex,
      'streak': streak,
      'dailyTimeSpent': dailyTimeSpent,
      'lastWorkedDate': lastWorkedDate,
      'subTasks': subTasks.map((st) => st.toJson()).toList(),
    };
  }

  Color get taskColor {
    try {
      return Color(int.parse("0x$colorHex"));
    } catch (e) {
      return AppTheme.fhAccentTealFixed; // Fallback color
    }
  }
}

class SubTask {
  String id;
  String name;
  bool completed;
  int currentTimeSpent; // Storing as minutes
  String? completedDate;
  bool isCountable;
  int targetCount;
  int currentCount;
  List<SubSubTask> subSubTasks;

  SubTask({
    required this.id,
    required this.name,
    this.completed = false,
    this.currentTimeSpent = 0,
    this.completedDate,
    this.isCountable = false,
    this.targetCount = 0,
    this.currentCount = 0,
    List<SubSubTask>? subSubTasks,
  }) : subSubTasks = subSubTasks ?? [];

  factory SubTask.fromJson(Map<String, dynamic> json) {
    return SubTask(
      id: json['id'] as String,
      name: json['name'] as String,
      completed: json['completed'] as bool? ?? false,
      currentTimeSpent: json['currentTimeSpent'] as int? ?? 0,
      completedDate: json['completedDate'] as String?,
      isCountable: json['isCountable'] as bool? ?? false,
      targetCount: json['targetCount'] as int? ?? 0,
      currentCount: json['currentCount'] as int? ?? 0,
      subSubTasks: (json['subSubTasks'] as List<dynamic>?)
              ?.map((sssJson) =>
                  SubSubTask.fromJson(sssJson as Map<String, dynamic>))
              .toList() ??
          [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'completed': completed,
      'currentTimeSpent': currentTimeSpent,
      'completedDate': completedDate,
      'isCountable': isCountable,
      'targetCount': targetCount,
      'currentCount': currentCount,
      'subSubTasks': subSubTasks.map((sss) => sss.toJson()).toList(),
    };
  }
}

class SubSubTask {
  String id;
  String name;
  bool completed;
  bool isCountable;
  int targetCount;
  int currentCount;
  String? completionTimestamp; // NEW: For logging time of completion

  SubSubTask({
    required this.id,
    required this.name,
    this.completed = false,
    this.isCountable = false,
    this.targetCount = 0,
    this.currentCount = 0,
    this.completionTimestamp, // NEW
  });

  factory SubSubTask.fromJson(Map<String, dynamic> json) {
    return SubSubTask(
      id: json['id'] as String,
      name: json['name'] as String,
      completed: json['completed'] as bool? ?? false,
      isCountable: json['isCountable'] as bool? ?? false,
      targetCount: json['targetCount'] as int? ?? 0,
      currentCount: json['currentCount'] as int? ?? 0,
      completionTimestamp: json['completionTimestamp'] as String?, // NEW
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'completed': completed,
      'isCountable': isCountable,
      'targetCount': targetCount,
      'currentCount': currentCount,
      'completionTimestamp': completionTimestamp, // NEW
    };
  }
}

class OwnedArtifact {
  String uniqueId;
  String templateId;
  int currentLevel;
  int? uses;

  OwnedArtifact({
    required this.uniqueId,
    required this.templateId,
    required this.currentLevel,
    this.uses,
  });

  factory OwnedArtifact.fromJson(Map<String, dynamic> json) {
    return OwnedArtifact(
      uniqueId: json['uniqueId'] as String,
      templateId: json['templateId'] as String,
      currentLevel: json['currentLevel'] as int,
      uses: json['uses'] as int?,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'uniqueId': uniqueId,
      'templateId': templateId,
      'currentLevel': currentLevel,
      'uses': uses,
    };
  }
}

class CurrentGame {
  EnemyTemplate? enemy;
  double playerCurrentHp;
  List<String> log;
  String? currentPlaceKey;

  CurrentGame({
    this.enemy,
    required this.playerCurrentHp,
    List<String>? log,
    this.currentPlaceKey,
  }) : log = log ?? [];

  factory CurrentGame.fromJson(
      Map<String, dynamic> json, List<EnemyTemplate> allEnemyTemplates) {
    EnemyTemplate? currentEnemy;
    if (json['enemy'] != null) {
      final enemyData = json['enemy'] as Map<String, dynamic>;
      currentEnemy =
          allEnemyTemplates.firstWhereOrNull((t) => t.id == enemyData['id']) ??
              EnemyTemplate.fromJson(enemyData);
    }
    return CurrentGame(
      enemy: currentEnemy,
      playerCurrentHp: (json['playerCurrentHp'] as num).toDouble(),
      log: (json['log'] as List<dynamic>?)
              ?.map((entry) => entry as String)
              .toList() ??
          [],
      currentPlaceKey: json['currentPlaceKey'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'enemy': enemy?.toJson(),
      'playerCurrentHp': playerCurrentHp,
      'log': log,
      'currentPlaceKey': currentPlaceKey,
    };
  }
}

class GameSettings {
  bool descriptionsVisible;
  bool dailyAutoGenerateContent; // Renamed from autoGenerateContent
  int wakeupTimeHour;
  int wakeupTimeMinute;

  GameSettings({
    this.descriptionsVisible = true,
    this.dailyAutoGenerateContent = true, // Renamed
    this.wakeupTimeHour = 7,
    this.wakeupTimeMinute = 0,
  });

  factory GameSettings.fromJson(Map<String, dynamic> json) {
    return GameSettings(
      descriptionsVisible: json['descriptionsVisible'] as bool? ?? true,
      dailyAutoGenerateContent: json['dailyAutoGenerateContent'] as bool? ??
          json['autoGenerateContent'] as bool? ??
          true, // Handle legacy name
      wakeupTimeHour: json['wakeupTimeHour'] as int? ?? 7,
      wakeupTimeMinute: json['wakeupTimeMinute'] as int? ?? 0,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'descriptionsVisible': descriptionsVisible,
      'dailyAutoGenerateContent': dailyAutoGenerateContent, // Renamed
      'wakeupTimeHour': wakeupTimeHour,
      'wakeupTimeMinute': wakeupTimeMinute,
    };
  }
}

class ActiveTimerInfo {
  DateTime startTime;
  double accumulatedDisplayTime; // In seconds
  bool isRunning;
  String type;
  String mainTaskId;

  ActiveTimerInfo({
    required this.startTime,
    this.accumulatedDisplayTime = 0,
    required this.isRunning,
    required this.type,
    required this.mainTaskId,
  });

  factory ActiveTimerInfo.fromJson(Map<String, dynamic> json) {
    return ActiveTimerInfo(
      startTime: DateTime.parse(json['startTime'] as String),
      accumulatedDisplayTime:
          (json['accumulatedDisplayTime'] as num? ?? 0).toDouble(),
      isRunning: json['isRunning'] as bool? ?? false,
      type: json['type'] as String? ?? 'subtask',
      mainTaskId: json['mainTaskId'] as String? ?? '',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'startTime': startTime.toIso8601String(),
      'accumulatedDisplayTime': accumulatedDisplayTime,
      'isRunning': isRunning,
      'type': type,
      'mainTaskId': mainTaskId,
    };
  }
}

class PlayerStat {
  final String name;
  final String description;
  final String icon; // Can be an emoji or an MDI icon name (e.g., "mdi-sword")
  double value;
  double base;

  PlayerStat({
    required this.name,
    required this.description,
    required this.icon,
    required this.value,
    required this.base,
  });

  factory PlayerStat.fromJson(Map<String, dynamic> json) {
    double parseNumToDouble(dynamic val, double defaultValue) {
      if (val == null) return defaultValue;
      if (val is num) return val.toDouble();
      if (val is String) return double.tryParse(val) ?? defaultValue;
      return defaultValue;
    }

    String parseString(dynamic val, String defaultValue) {
      if (val == null) return defaultValue;
      if (val is String) return val;
      return val.toString();
    }

    return PlayerStat(
      name: parseString(json['name'], 'Unknown Stat'),
      description: parseString(json['description'], 'No description.'),
      icon: parseString(
          json['icon'],
          MdiIcons.helpCircleOutline.codePoint
              .toString()), // Use MDI icon as string default
      value: parseNumToDouble(json['value'], 0.0),
      base: parseNumToDouble(json['base'], 0.0),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'description': description,
      'icon': icon,
      'value': value,
      'base': base,
    };
  }
}

class ArtifactTemplate {
  final String id;
  final String name;
  final String type;
  final String? theme;
  final String description;
  final int cost;
  final String icon; // Can be an emoji or an MDI icon name
  final int? baseAtt;
  final int? baseRunic;
  final int? baseDef;
  final int? baseHealth;
  final int? baseLuck;
  final int? baseCooldown;
  final double? bonusXPMod;
  final Map<String, int>? upgradeBonus;
  final int? maxLevel;
  final String? effectType;
  final int? effectValue;
  final int? uses;

  ArtifactTemplate({
    required this.id,
    required this.name,
    required this.type,
    this.theme,
    required this.description,
    required this.cost,
    required this.icon,
    this.baseAtt,
    this.baseRunic,
    this.baseDef,
    this.baseHealth,
    this.baseLuck,
    this.baseCooldown,
    this.bonusXPMod,
    this.upgradeBonus,
    this.maxLevel,
    this.effectType,
    this.effectValue,
    this.uses,
  });

  factory ArtifactTemplate.fromJson(Map<String, dynamic> json) {
    Map<String, int>? parsedUpgradeBonus;
    if (json['upgradeBonus'] != null && json['upgradeBonus'] is Map) {
      parsedUpgradeBonus = {};
      try {
        (json['upgradeBonus'] as Map<String, dynamic>).forEach((key, value) {
          if (value is num) {
            parsedUpgradeBonus![key] = value.toInt();
          } else if (value is String) {
            parsedUpgradeBonus![key] = int.tryParse(value) ?? 0;
          }
        });
      } catch (e) {/* ... */}
    }
    int? parseInt(dynamic val) {
      if (val == null) return null;
      if (val is int) return val;
      if (val is double) return val.toInt();
      if (val is String) return int.tryParse(val);
      return null;
    }

    double? parseDouble(dynamic val) {
      if (val == null) return null;
      if (val is double) return val;
      if (val is int) return val.toDouble();
      if (val is String) return double.tryParse(val);
      return null;
    }

    return ArtifactTemplate(
      id: json['id'] as String? ??
          'unknown_id_${DateTime.now().millisecondsSinceEpoch}',
      name: json['name'] as String? ?? 'Unknown Artifact',
      type: json['type'] as String? ?? 'unknown',
      theme: json['theme'] as String?,
      description: json['description'] as String? ?? 'No description.',
      cost: parseInt(json['cost']) ?? 0,
      icon: json['icon'] as String? ??
          MdiIcons.treasureChest.codePoint
              .toString(), // Default to MDI icon string
      baseAtt: parseInt(json['baseAtt']),
      baseRunic: parseInt(json['baseRunic']),
      baseDef: parseInt(json['baseDef']),
      baseHealth: parseInt(json['baseHealth']),
      baseLuck: parseInt(json['baseLuck']),
      baseCooldown: parseInt(json['baseCooldown']),
      bonusXPMod: parseDouble(json['bonusXPMod']),
      upgradeBonus: parsedUpgradeBonus,
      maxLevel: parseInt(json['maxLevel']),
      effectType: json['effectType'] as String?,
      effectValue: parseInt(json['effectValue']),
      uses: parseInt(json['uses']),
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'type': type,
      'theme': theme,
      'description': description,
      'cost': cost,
      'icon': icon,
      'baseAtt': baseAtt,
      'baseRunic': baseRunic,
      'baseDef': baseDef,
      'baseHealth': baseHealth,
      'baseLuck': baseLuck,
      'baseCooldown': baseCooldown,
      'bonusXPMod': bonusXPMod,
      'upgradeBonus': upgradeBonus,
      'maxLevel': maxLevel,
      'effectType': effectType,
      'effectValue': effectValue,
      'uses': uses,
    };
  }
}

class EnemyTemplate {
  final String id;
  final String name;
  final String? theme;
  final String? locationKey;
  final int minPlayerLevel;
  final int health;
  final int attack;
  final int defense;
  int hp;
  final int coinReward;
  final int xpReward;
  final String description;

  EnemyTemplate({
    required this.id,
    required this.name,
    this.theme,
    this.locationKey,
    required this.minPlayerLevel,
    required this.health,
    required this.attack,
    required this.defense,
    int? hp,
    required this.coinReward,
    required this.xpReward,
    required this.description,
  }) : hp = hp ?? health;

  factory EnemyTemplate.fromJson(Map<String, dynamic> json) {
    int? parseInt(dynamic val) {
      if (val == null) return null;
      if (val is int) return val;
      if (val is double) return val.toInt();
      if (val is String) return int.tryParse(val);
      return null;
    }

    final maxHealth = parseInt(json['health']) ?? 10;
    return EnemyTemplate(
      id: json['id'] as String? ??
          'unknown_enemy_${DateTime.now().millisecondsSinceEpoch}',
      name: json['name'] as String? ?? 'Nameless Foe',
      theme: json['theme'] as String?,
      locationKey: json['locationKey'] as String?,
      minPlayerLevel: parseInt(json['minPlayerLevel']) ?? 1,
      health: maxHealth,
      hp: parseInt(json['hp']) ?? maxHealth,
      attack: parseInt(json['attack']) ?? 1,
      defense: parseInt(json['defense']) ?? 0,
      coinReward: parseInt(json['coinReward']) ?? 0,
      xpReward: parseInt(json['xpReward']) ?? 0,
      description: json['description'] as String? ?? 'A mysterious enemy.',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'theme': theme,
      'locationKey': locationKey,
      'minPlayerLevel': minPlayerLevel,
      'health': health,
      'hp': hp,
      'attack': attack,
      'defense': defense,
      'coinReward': coinReward,
      'xpReward': xpReward,
      'description': description,
    };
  }
}

class Rune {
  String id;
  String name;
  String description;
  String icon;
  String type;
  String effectType;
  double effectValue;
  double? effectDuration;
  String? targetStat;
  int cost;
  int? requiredLevel;

  Rune({
    required this.id,
    required this.name,
    required this.description,
    required this.icon,
    required this.type,
    required this.effectType,
    required this.effectValue,
    this.effectDuration,
    this.targetStat,
    required this.cost,
    this.requiredLevel,
  });

  factory Rune.fromJson(Map<String, dynamic> json) {
    return Rune(
      id: json['id'] as String,
      name: json['name'] as String,
      description: json['description'] as String,
      icon: json['icon'] as String,
      type: json['type'] as String,
      effectType: json['effectType'] as String,
      effectValue: (json['effectValue'] as num).toDouble(),
      effectDuration: (json['effectDuration'] as num?)?.toDouble(),
      targetStat: json['targetStat'] as String?,
      cost: json['cost'] as int,
      requiredLevel: json['requiredLevel'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'icon': icon,
      'type': type,
      'effectType': effectType,
      'effectValue': effectValue,
      'effectDuration': effectDuration,
      'targetStat': targetStat,
      'cost': cost,
      'requiredLevel': requiredLevel,
    };
  }
}

class OwnedRune {
  String uniqueId;
  String runeId;
  bool isActive;

  OwnedRune({
    required this.uniqueId,
    required this.runeId,
    this.isActive = false,
  });

  factory OwnedRune.fromJson(Map<String, dynamic> json) {
    return OwnedRune(
      uniqueId: json['uniqueId'] as String,
      runeId: json['runeId'] as String,
      isActive: json['isActive'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'uniqueId': uniqueId,
      'runeId': runeId,
      'isActive': isActive,
    };
  }
}

// Moved from constants.dart
class MainTaskTemplate {
  final String id;
  final String name;
  final String description;
  final String theme;
  final String colorHex;

  MainTaskTemplate({
    required this.id,
    required this.name,
    required this.description,
    required this.theme,
    this.colorHex = "FF00F8F8", // Default Cyan
  });
}

// Moved from constants.dart
class GameLocation {
  final String id; // Changed key to id for consistency
  final String name;
  final String description;
  final int minPlayerLevelToUnlock;
  final String iconEmoji; // Using specific field for emoji
  final String? associatedTheme;
  final String?
      bossEnemyIdToUnlockNextLocation; // ID of an enemy in this location
  bool isCleared; // Added field for tracking if location is cleared

  GameLocation({
    required this.id,
    required this.name,
    required this.description,
    this.minPlayerLevelToUnlock = 1,
    required this.iconEmoji,
    this.associatedTheme,
    this.bossEnemyIdToUnlockNextLocation,
    this.isCleared = false, // Default to not cleared
  });

  factory GameLocation.fromJson(Map<String, dynamic> json) {
    return GameLocation(
      id: json['id'] as String? ??
          'loc_${DateTime.now().millisecondsSinceEpoch}',
      name: json['name'] as String? ?? 'Unknown Area',
      description: json['description'] as String? ?? 'A mysterious place.',
      minPlayerLevelToUnlock: json['minPlayerLevelToUnlock'] as int? ?? 1,
      iconEmoji: json['iconEmoji'] as String? ?? '❓',
      associatedTheme: json['associatedTheme'] as String?,
      bossEnemyIdToUnlockNextLocation:
          json['bossEnemyIdToUnlockNextLocation'] as String?,
      isCleared: json['isCleared'] as bool? ?? false, // Load isCleared status
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'minPlayerLevelToUnlock': minPlayerLevelToUnlock,
      'iconEmoji': iconEmoji,
      'associatedTheme': associatedTheme,
      'bossEnemyIdToUnlockNextLocation': bossEnemyIdToUnlockNextLocation,
      'isCleared': isCleared, // Save isCleared status
    };
  }
}

// Park Management Models
class DinosaurSpecies {
  final String id;
  final String name;
  final String description;
  final String diet; // "carnivore" or "herbivore"
  final int incubationCostDollars; // Park currency (Dollars)
  final int fossilExcavationEnergyCost; // Player energy
  final int baseRating; // Contribution to park rating
  final double comfortThreshold; // Min comfort % to be happy
  final int socialNeedsMin; // Min number of same species
  final int socialNeedsMax; // Max number of same species
  final int enclosureSizeNeeds; // Arbitrary units (e.g., squares)
  final String icon; // Emoji or MDI icon name
  final int minPlayerLevelToUnlock;

  DinosaurSpecies({
    required this.id,
    required this.name,
    required this.description,
    required this.diet,
    required this.incubationCostDollars,
    required this.fossilExcavationEnergyCost,
    required this.baseRating,
    required this.comfortThreshold,
    required this.socialNeedsMin,
    required this.socialNeedsMax,
    required this.enclosureSizeNeeds,
    required this.icon,
    this.minPlayerLevelToUnlock = 1,
  });

  factory DinosaurSpecies.fromJson(Map<String, dynamic> json) {
    return DinosaurSpecies(
      id: json['id'] as String,
      name: json['name'] as String,
      description: json['description'] as String,
      diet: json['diet'] as String,
      incubationCostDollars: json['incubationCostDollars'] as int? ??
          json['incubationCost'] as int, // Handle legacy 'incubationCost'
      fossilExcavationEnergyCost:
          json['fossilExcavationEnergyCost'] as int? ??
              json['fossilExcavationCost']
                  as int, // Handle legacy 'fossilExcavationCost'
      baseRating: json['baseRating'] as int,
      comfortThreshold: (json['comfortThreshold'] as num).toDouble(),
      socialNeedsMin: json['socialNeedsMin'] as int,
      socialNeedsMax: json['socialNeedsMax'] as int,
      enclosureSizeNeeds: json['enclosureSizeNeeds'] as int,
      icon: json['icon'] as String,
      minPlayerLevelToUnlock: json['minPlayerLevelToUnlock'] as int? ?? 1,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'diet': diet,
      'incubationCostDollars': incubationCostDollars,
      'fossilExcavationEnergyCost': fossilExcavationEnergyCost,
      'baseRating': baseRating,
      'comfortThreshold': comfortThreshold,
      'socialNeedsMin': socialNeedsMin,
      'socialNeedsMax': socialNeedsMax,
      'enclosureSizeNeeds': enclosureSizeNeeds,
      'icon': icon,
      'minPlayerLevelToUnlock': minPlayerLevelToUnlock,
    };
  }
}

class BuildingTemplate {
  final String id;
  final String name;
  final String type; // e.g., "enclosure", "hatchery", "fossil_center", "food_station", "visitor_center", "power_plant"
  final int costDollars; // Park currency (Dollars)
  final String icon; // MDI icon name
  final int? capacity; // e.g., number of dinos for enclosure, incubation slots for hatchery
  final int? operationalCostPerMinuteDollars; // Park currency
  final int? incomePerMinuteDollars; // Park currency (for visitor centers, etc.)
  final int? parkRatingBoost;
  final int? sizeX; // Grid size X
  final int? sizeY; // Grid size Y
  final int? powerRequired; // Power units this building consumes when operational
  final int? powerOutput; // Power units this building generates (for power plants)

  BuildingTemplate({
    required this.id,
    required this.name,
    required this.type,
    required this.costDollars,
    required this.icon,
    this.capacity,
    this.operationalCostPerMinuteDollars,
    this.incomePerMinuteDollars,
    this.parkRatingBoost,
    this.sizeX,
    this.sizeY,
    this.powerRequired,
    this.powerOutput,
  });

  factory BuildingTemplate.fromJson(Map<String, dynamic> json) {
    return BuildingTemplate(
      id: json['id'] as String,
      name: json['name'] as String,
      type: json['type'] as String,
      costDollars: json['costDollars'] as int? ??
          json['cost'] as int, // Handle legacy 'cost'
      icon: json['icon'] as String,
      capacity: json['capacity'] as int?,
      operationalCostPerMinuteDollars:
          json['operationalCostPerMinuteDollars'] as int? ??
              json['operationalCostPerMinute'] as int?,
      incomePerMinuteDollars: json['incomePerMinuteDollars'] as int? ??
          json['incomePerMinute'] as int?,
      parkRatingBoost: json['parkRatingBoost'] as int?,
      sizeX: json['sizeX'] as int?,
      sizeY: json['sizeY'] as int?,
      powerRequired: json['powerRequired'] as int?,
      powerOutput: json['powerOutput'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'type': type,
      'costDollars': costDollars,
      'icon': icon,
      'capacity': capacity,
      'operationalCostPerMinuteDollars': operationalCostPerMinuteDollars,
      'incomePerMinuteDollars': incomePerMinuteDollars,
      'parkRatingBoost': parkRatingBoost,
      'sizeX': sizeX,
      'sizeY': sizeY,
      'powerRequired': powerRequired,
      'powerOutput': powerOutput,
    };
  }
}

class OwnedBuilding {
  final String uniqueId;
  final String templateId;
  // GridPosition position; // Placeholder for later grid system
  List<String> dinosaurUniqueIds; // For enclosures
  int? currentFoodLevel; // For food stations (0-100)
  bool isOperational;

  OwnedBuilding({
    required this.uniqueId,
    required this.templateId,
    // required this.position,
    List<String>? dinosaurUniqueIds,
    this.currentFoodLevel,
    this.isOperational = true,
  }) : dinosaurUniqueIds = dinosaurUniqueIds ?? [];

  factory OwnedBuilding.fromJson(Map<String, dynamic> json) {
    return OwnedBuilding(
      uniqueId: json['uniqueId'] as String,
      templateId: json['templateId'] as String,
      // position: GridPosition.fromJson(json['position']),
      dinosaurUniqueIds: (json['dinosaurUniqueIds'] as List<dynamic>?)
              ?.map((id) => id as String)
              .toList() ??
          [],
      currentFoodLevel: json['currentFoodLevel'] as int?,
      isOperational: json['isOperational'] as bool? ?? true,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'uniqueId': uniqueId,
      'templateId': templateId,
      // 'position': position.toJson(),
      'dinosaurUniqueIds': dinosaurUniqueIds,
      'currentFoodLevel': currentFoodLevel,
      'isOperational': isOperational,
    };
  }
}

class OwnedDinosaur {
  final String uniqueId;
  final String speciesId;
  String name; // Can be nicknamed by player
  double currentHealth; // 0-100
  double currentComfort; // 0-100
  double currentFood; // 0-100 (satiation)
  int age; // In game days/minutes

  OwnedDinosaur({
    required this.uniqueId,
    required this.speciesId,
    required this.name,
    this.currentHealth = 100.0,
    this.currentComfort = 75.0,
    this.currentFood = 75.0,
    this.age = 0,
  });

  factory OwnedDinosaur.fromJson(Map<String, dynamic> json) {
    return OwnedDinosaur(
      uniqueId: json['uniqueId'] as String,
      speciesId: json['speciesId'] as String,
      name: json['name'] as String,
      currentHealth: (json['currentHealth'] as num? ?? 100.0).toDouble(),
      currentComfort: (json['currentComfort'] as num? ?? 75.0).toDouble(),
      currentFood: (json['currentFood'] as num? ?? 75.0).toDouble(),
      age: json['age'] as int? ?? 0,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'uniqueId': uniqueId,
      'speciesId': speciesId,
      'name': name,
      'currentHealth': currentHealth,
      'currentComfort': currentComfort,
      'currentFood': currentFood,
      'age': age,
    };
  }
}

class FossilRecord {
  final String speciesId;
  double excavationProgress; // 0.0 to 100.0
  bool isGenomeComplete;

  FossilRecord({
    required this.speciesId,
    this.excavationProgress = 0.0,
    this.isGenomeComplete = false,
  });

  factory FossilRecord.fromJson(Map<String, dynamic> json) {
    return FossilRecord(
      speciesId: json['speciesId'] as String,
      excavationProgress:
          (json['excavationProgress'] as num? ?? 0.0).toDouble(),
      isGenomeComplete: json['isGenomeComplete'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'speciesId': speciesId,
      'excavationProgress': excavationProgress,
      'isGenomeComplete': isGenomeComplete,
    };
  }
}

class ParkManager {
  int parkRating;
  double parkDollars; // New currency for park
  double parkEnergy; // Player energy for park operations
  double maxParkEnergy;
  int incomePerMinuteDollars; // Total from all income-generating buildings (Dollars)
  int operationalCostPerMinuteDollars; // Total from all buildings (Dollars)
  int currentPowerGenerated;
  int currentPowerConsumed;

  ParkManager({
    this.parkRating = 0,
    this.parkDollars = 50000, // Starting park dollars
    this.parkEnergy = 100.0, // Starting park energy, linked to player energy
    this.maxParkEnergy = 100.0,
    this.incomePerMinuteDollars = 0,
    this.operationalCostPerMinuteDollars = 0,
    this.currentPowerGenerated = 0,
    this.currentPowerConsumed = 0,
  });

  factory ParkManager.fromJson(Map<String, dynamic> json) {
    return ParkManager(
      parkRating: json['parkRating'] as int? ?? 0,
      parkDollars: (json['parkDollars'] as num? ?? 50000.0).toDouble(),
      parkEnergy: (json['parkEnergy'] as num? ?? 100.0).toDouble(),
      maxParkEnergy: (json['maxParkEnergy'] as num? ?? 100.0).toDouble(),
      incomePerMinuteDollars: json['incomePerMinuteDollars'] as int? ??
          json['incomePerMinute'] as int? ??
          0,
      operationalCostPerMinuteDollars:
          json['operationalCostPerMinuteDollars'] as int? ??
              json['operationalCostPerMinute'] as int? ??
              0,
      currentPowerGenerated: json['currentPowerGenerated'] as int? ?? 0,
      currentPowerConsumed: json['currentPowerConsumed'] as int? ?? 0,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'parkRating': parkRating,
      'parkDollars': parkDollars,
      'parkEnergy': parkEnergy,
      'maxParkEnergy': maxParkEnergy,
      'incomePerMinuteDollars': incomePerMinuteDollars,
      'operationalCostPerMinuteDollars': operationalCostPerMinuteDollars,
      'currentPowerGenerated': currentPowerGenerated,
      'currentPowerConsumed': currentPowerConsumed,
    };
  }
}

class EmotionLog {
  final DateTime timestamp;
  final int rating; // 1-5

  EmotionLog({required this.timestamp, required this.rating});

  factory EmotionLog.fromJson(Map<String, dynamic> json) {
    return EmotionLog(
      timestamp: DateTime.parse(json['timestamp'] as String),
      rating: json['rating'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'timestamp': timestamp.toIso8601String(),
      'rating': rating,
    };
  }
}

// Chatbot models
enum MessageSender { user, bot }

class ChatbotMessage {
  final String id;
  final String text;
  final MessageSender sender;
  final DateTime timestamp;

  ChatbotMessage({
    required this.id,
    required this.text,
    required this.sender,
    required this.timestamp,
  });

  factory ChatbotMessage.fromJson(Map<String, dynamic> json) {
    return ChatbotMessage(
      id: json['id'] as String,
      text: json['text'] as String,
      sender: MessageSender.values
          .firstWhere((e) => e.toString() == json['sender'] as String),
      timestamp: DateTime.parse(json['timestamp'] as String),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'text': text,
      'sender': sender.toString(),
      'timestamp': timestamp.toIso8601String(),
    };
  }
}


class ChatbotMemory {
  List<ChatbotMessage> conversationHistory;
  List<String> userRememberedItems; // Items explicitly told to remember

  ChatbotMemory({
    List<ChatbotMessage>? conversationHistory,
    List<String>? userRememberedItems,
  })  : conversationHistory = conversationHistory ?? [],
        userRememberedItems = userRememberedItems ?? [];

  factory ChatbotMemory.fromJson(Map<String, dynamic> json) {
    return ChatbotMemory(
      conversationHistory: (json['conversationHistory'] as List<dynamic>?)
              ?.map((msgJson) =>
                  ChatbotMessage.fromJson(msgJson as Map<String, dynamic>))
              .toList() ??
          [],
      userRememberedItems: (json['userRememberedItems'] as List<dynamic>?)
              ?.map((item) => item as String)
              .toList() ??
          [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'conversationHistory':
          conversationHistory.map((msg) => msg.toJson()).toList(),
      'userRememberedItems': userRememberedItems,
    };
  }
}
--- END OF FILE lib/src/models/game_models.dart ---

--- START OF FILE lib/src/providers/game_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:arcane/src/services/firebase_service.dart' as fb_service;
import 'package:arcane/src/services/storage_service.dart';
import 'package:arcane/src/utils/constants.dart';
import 'package:arcane/src/utils/helpers.dart' as helper;
import 'package:firebase_auth/firebase_auth.dart';
import 'package:intl/intl.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:collection/collection.dart';
import 'dart:async';
import 'dart:convert'; // For jsonEncode
import 'package:flutter/material.dart'; // For TimeOfDay

import 'package:arcane/src/models/game_models.dart';

import 'actions/task_actions.dart';
import 'actions/item_actions.dart';
import 'actions/combat_actions.dart';
import 'actions/ai_generation_actions.dart';
import 'actions/timer_actions.dart';
import 'actions/park_actions.dart';
import 'package:arcane/src/services/ai_service.dart'; // For chatbot AI service

class GameProvider with ChangeNotifier {
  final StorageService _storageService = StorageService();
  final AIService _aiService = AIService(); // For chatbot
  Timer? _periodicUiTimer;
  Timer? _autoSaveTimer;
  Timer? _parkUpdateTimer; // For park income/costs

  User? _currentUser;
  User? get currentUser => _currentUser;
  bool _authLoading = true;
  bool get authLoading => _authLoading;
  bool _isDataLoadingAfterLogin = false;
  bool get isDataLoadingAfterLogin => _isDataLoadingAfterLogin;
  bool _isUsernameMissing = false;
  bool get isUsernameMissing => _isUsernameMissing;

  String? _lastLoginDate;
  double _coins = 100;
  double _xp = 0;
  int _playerLevel = 1;
  double _playerEnergy = baseMaxPlayerEnergy;
  List<MainTask> _mainTasks =
      initialMainTaskTemplates.map((t) => MainTask.fromTemplate(t)).toList();
  Map<String, dynamic> _completedByDay = {};
  List<OwnedArtifact> _artifacts = [];
  List<ArtifactTemplate> _artifactTemplatesList = [];
  List<EnemyTemplate> _enemyTemplatesList = [];
  List<GameLocation> _gameLocationsList = []; // New list for game locations
  List<Rune> _runeTemplatesList = [];
  List<OwnedRune> _ownedRunes = [];

  Map<String, PlayerStat> _playerGameStats = {
    ...Map.from(basePlayerGameStats.map((key, value) => MapEntry(
        key,
        PlayerStat(
            name: value.name,
            description: value.description,
            icon: value.icon,
            value: value.value,
            base: value.base)))),
  };
  void _ensureBonusXpModStat() {
    if (!_playerGameStats.containsKey('bonusXPMod')) {
      _playerGameStats['bonusXPMod'] = PlayerStat(
          name: 'XP CALC MOD', // Display name for the UI
          value: 0,
          base: 0,
          description: 'Internal XP modifier from gear.',
          icon: 'mdi-percent-outline'); // Using MDI string
    }
  }

  Map<String, String?> _equippedItems = {
    'weapon': null,
    'armor': null,
    'talisman': null
  };
  Map<String, String?> _equippedRunes = {
    'rune_slot_1': null,
    'rune_slot_2': null
  };

  List<String> _defeatedEnemyIds = [];
  List<String> _clearedLocationIds = []; // To track cleared locations
  List<String> get clearedLocationIds => _clearedLocationIds;

  CurrentGame _currentGame = CurrentGame(
      playerCurrentHp: basePlayerGameStats['vitality']!.value,
      currentPlaceKey: initialGameLocations.isNotEmpty
          ? initialGameLocations.first.id
          : null);
  GameSettings _settings = GameSettings();
  String _currentView = 'task-details';
  String? _selectedTaskId = initialMainTaskTemplates.isNotEmpty
      ? initialMainTaskTemplates[0].id
      : null;
  int _apiKeyIndex = 0;
  Map<String, ActiveTimerInfo> _activeTimers = {};

  bool _hasUnsavedChanges = false;
  bool _isManuallySaving = false;
  bool get isManuallySaving => _isManuallySaving;
  bool _isManuallyLoading = false;
  bool get isManuallyLoading => _isManuallyLoading;
  DateTime? _lastSuccessfulSaveTimestamp;
  DateTime? get lastSuccessfulSaveTimestamp => _lastSuccessfulSaveTimestamp;

  bool _isGeneratingGlobalContent = false;
  bool get isGeneratingContent => _isGeneratingGlobalContent;
  bool _isGeneratingSubquestsForTask = false;
  bool get isGeneratingSubquests => _isGeneratingSubquestsForTask;

  double _aiGenerationProgress = 0.0;
  double get aiGenerationProgress => _aiGenerationProgress;
  String _aiGenerationStatusMessage = "";
  String get aiGenerationStatusMessage => _aiGenerationStatusMessage;

  // Park Management State
  List<DinosaurSpecies> _dinosaurSpeciesList = [];
  List<BuildingTemplate> _buildingTemplatesList = [];
  List<OwnedBuilding> _ownedBuildings = [];
  List<OwnedDinosaur> _ownedDinosaurs = [];
  List<FossilRecord> _fossilRecords = [];
  ParkManager _parkManager = ParkManager();

  List<DinosaurSpecies> get dinosaurSpeciesList => _dinosaurSpeciesList;
  List<BuildingTemplate> get buildingTemplatesList => _buildingTemplatesList;
  List<OwnedBuilding> get ownedBuildings => _ownedBuildings;
  List<OwnedDinosaur> get ownedDinosaurs => _ownedDinosaurs;
  List<FossilRecord> get fossilRecords => _fossilRecords;
  ParkManager get parkManager => _parkManager;
  ParkActions get parkActions => _parkActions;

  String? get lastLoginDate => _lastLoginDate;
  double get coins => _coins;
  double get xp => _xp;
  int get playerLevel => _playerLevel;
  double get playerEnergy => _playerEnergy;
  List<MainTask> get mainTasks => _mainTasks;
  Map<String, dynamic> get completedByDay => _completedByDay;
  List<OwnedArtifact> get artifacts => _artifacts;
  List<ArtifactTemplate> get artifactTemplatesList => _artifactTemplatesList;
  List<EnemyTemplate> get enemyTemplatesList => _enemyTemplatesList;
  List<GameLocation> get gameLocationsList =>
      _gameLocationsList; // Getter for locations
  List<Rune> get runeTemplatesList => _runeTemplatesList;
  List<OwnedRune> get ownedRunes => _ownedRunes;

  Map<String, PlayerStat> get playerGameStats => _playerGameStats;
  Map<String, String?> get equippedItems => _equippedItems;
  Map<String, String?> get equippedRunes => _equippedRunes;

  List<String> get defeatedEnemyIds => _defeatedEnemyIds;
  CurrentGame get currentGame => _currentGame;
  GameSettings get settings => _settings;
  String get currentView => _currentView;
  String? get selectedTaskId => _selectedTaskId;
  int get apiKeyIndex => _apiKeyIndex;
  Map<String, ActiveTimerInfo> get activeTimers => _activeTimers;

  double get calculatedMaxEnergy =>
      baseMaxPlayerEnergy + (_playerLevel - 1) * playerEnergyPerLevelVitality;
  double get xpNeededForNextLevel =>
      helper.xpToNext(_playerLevel, xpPerLevelBase, xpLevelMultiplier);
  double get currentLevelXPStart =>
      helper.xpForLevel(_playerLevel, xpPerLevelBase, xpLevelMultiplier);
  double get currentLevelXPProgress => _xp - currentLevelXPStart;
  double get xpProgressPercent => xpNeededForNextLevel > 0
      ? (currentLevelXPProgress / xpNeededForNextLevel).clamp(0.0, 1.0) * 100
      : 0;

  TimeOfDay get wakeupTime =>
      TimeOfDay(hour: _settings.wakeupTimeHour, minute: _settings.wakeupTimeMinute);

  // Chatbot State
  ChatbotMemory _chatbotMemory = ChatbotMemory();
  ChatbotMemory get chatbotMemory => _chatbotMemory;
  bool _isChatbotMemoryInitialized = false;

  late final TaskActions _taskActions;
  late final ItemActions _itemActions;
  late final CombatActions _combatActions;
  late final AIGenerationActions _aiGenerationActions;
  late final TimerActions _timerActions;
  late final ParkActions _parkActions;

  GameProvider() {
    print("[GameProvider] Constructor called. Initializing actions first...");
    // Initialize actions first to prevent LateInitializationError from async callbacks
    _taskActions = TaskActions(this);
    _itemActions = ItemActions(this);
    _combatActions = CombatActions(this);
    _aiGenerationActions = AIGenerationActions(this);
    _timerActions = TimerActions(this);
    _parkActions = ParkActions(this);

    print("[GameProvider] Actions initialized. Ensuring bonusXPModStat...");
    _ensureBonusXpModStat();

    print("[GameProvider] Initializing core systems and listeners...");
    _initialize(); // Now call initialize, which sets up listeners

    _periodicUiTimer?.cancel();
    _periodicUiTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_activeTimers.values.any((info) => info.isRunning)) {
        notifyListeners();
      }
    });

    _parkUpdateTimer?.cancel();
    _parkUpdateTimer = Timer.periodic(const Duration(minutes: 1), (timer) {
      _parkActions
          .updateAllDinosaursStatus(); // Periodically update dinosaur needs
      _parkActions
          .recalculateParkStats(); // This also calls _updateBuildingOperationalStatusBasedOnPower and updates income/costs
    });
    print("[GameProvider] Initialization complete.");
  }

  @override
  void dispose() {
    print("[GameProvider] dispose called.");
    _periodicUiTimer?.cancel();
    _autoSaveTimer?.cancel();
    _parkUpdateTimer?.cancel();
    super.dispose();
  }

  Future<void> _initialize() async {
    // Made async
    fb_service.authStateChanges.listen(_onAuthStateChanged);
    _autoSaveTimer?.cancel();
    _autoSaveTimer = Timer.periodic(const Duration(minutes: 1), (timer) {
      if (_hasUnsavedChanges &&
          _currentUser != null &&
          !_isManuallySaving &&
          !_isManuallyLoading) {
        print("[GameProvider] Auto-saving changes...");
        _performActualSave();
      }
    });
  }

  Future<void> _onAuthStateChanged(User? user) async {
    print("[GameProvider] _onAuthStateChanged triggered. User: ${user?.uid}");
    if (_authLoading &&
        _currentUser != null &&
        user != null &&
        _currentUser!.uid == user.uid) {
      print("[GameProvider] Auth state unchanged for same user, returning.");
      return;
    }

    _authLoading = true;
    notifyListeners();

    if (user != null) {
      print("[GameProvider] User signed in: ${user.uid}. Loading data...");
      _currentUser = user;
      _isDataLoadingAfterLogin = true;
      notifyListeners();

      final data = await _storageService.getUserData(user.uid);
      if (data != null) {
        print("[GameProvider] User data found, loading state.");
        _loadStateFromMap(data);
        _hasUnsavedChanges = false; // Data is in sync with cloud after load
        _handleDailyReset(); // Handle daily reset logic which includes potential content generation
      } else {
        print("[GameProvider] No user data found, resetting to initial state.");
        await _resetToInitialState(); // Make reset async if it involves async ops
        _lastLoginDate = helper.getTodayDateString(); // Set login date for new user
        _hasUnsavedChanges = true; // Mark as changed to trigger initial save
        if (settings.dailyAutoGenerateContent) {
          // Use new setting name
          print("[GameProvider] Initial content generation for new user.");
          // Don't await this if it blocks UI too much, let it run in background
          _aiGenerationActions
              .generateGameContent(_playerLevel,
                  isManual: false, isInitial: true, contentType: "all")
              .catchError((e) {
            print("Error during initial content generation: $e");
          }).whenComplete(() => _performActualSave()); // Save after initial content is generated
        } else {
          await _performActualSave(); // Save immediately if no initial content generation
        }
        _handleDailyReset(); // Call daily reset even for new user to set up daily state
      }
      _isChatbotMemoryInitialized = false; // Reset flag on new login/data load
      initializeChatbotMemory(); // Initialize chatbot memory after data load

      if (_currentUser?.displayName == null ||
          _currentUser!.displayName!.trim().isEmpty) {
        print("[GameProvider] Username is missing for current user.");
        _isUsernameMissing = true;
      } else {
        _isUsernameMissing = false;
      }
      _isDataLoadingAfterLogin = false;
    } else {
      print("[GameProvider] User signed out or null. Resetting state.");
      _currentUser = null;
      await _resetToInitialState(); // Make reset async
      _isDataLoadingAfterLogin = false;
      _hasUnsavedChanges = false;
      _isChatbotMemoryInitialized = false;
    }

    _authLoading = false;
    notifyListeners();
    print(
        "[GameProvider] _onAuthStateChanged finished. AuthLoading: $_authLoading, IsDataLoadingAfterLogin: $_isDataLoadingAfterLogin");
  }

  Map<String, dynamic> _gameStateToMap() {
    return {
      'lastLoginDate': _lastLoginDate,
      'coins': _coins,
      'xp': _xp,
      'playerLevel': _playerLevel,
      'playerEnergy': _playerEnergy,
      'mainTasks': _mainTasks.map((mt) => mt.toJson()).toList(),
      'completedByDay': _completedByDay,
      'artifacts': _artifacts.map((a) => a.toJson()).toList(),
      'artifactTemplatesList':
          _artifactTemplatesList.map((at) => at.toJson()).toList(),
      'enemyTemplatesList':
          _enemyTemplatesList.map((et) => et.toJson()).toList(),
      'gameLocationsList': _gameLocationsList
          .map((gl) => gl.toJson())
          .toList(), // Save locations
      'runeTemplatesList': _runeTemplatesList.map((rt) => rt.toJson()).toList(),
      'ownedRunes': _ownedRunes.map((or) => or.toJson()).toList(),
      'playerGameStats':
          _playerGameStats.map((key, stat) => MapEntry(key, stat.toJson())),
      'equippedItems': _equippedItems,
      'equippedRunes': _equippedRunes,
      'defeatedEnemyIds': _defeatedEnemyIds,
      'clearedLocationIds': _clearedLocationIds, // Save cleared locations
      'currentGame': _currentGame.toJson(),
      'settings': settings.toJson(),
      'currentView': _currentView,
      'selectedTaskId': _selectedTaskId,
      'apiKeyIndex': _apiKeyIndex,
      'activeTimers':
          _activeTimers.map((key, value) => MapEntry(key, value.toJson())),
      'lastSuccessfulSaveTimestamp':
          _lastSuccessfulSaveTimestamp?.toIso8601String(),
      // Park Management Data
      'dinosaurSpeciesList':
          _dinosaurSpeciesList.map((ds) => ds.toJson()).toList(),
      'buildingTemplatesList':
          _buildingTemplatesList.map((bt) => bt.toJson()).toList(),
      'ownedBuildings': _ownedBuildings.map((ob) => ob.toJson()).toList(),
      'ownedDinosaurs': _ownedDinosaurs.map((od) => od.toJson()).toList(),
      'fossilRecords': _fossilRecords.map((fr) => fr.toJson()).toList(),
      'parkManager': _parkManager.toJson(),
      // Chatbot Data
      'chatbotMemory': _chatbotMemory.toJson(),
    };
  }

  void _loadStateFromMap(Map<String, dynamic> data) {
    print("[GameProvider] Loading state from map: ${data.keys.toList()}");
    _lastLoginDate = data['lastLoginDate'] as String?;
    _coins = (data['coins'] as num? ?? 100).toDouble();
    _xp = (data['xp'] as num? ?? 0).toDouble();
    _playerLevel = data['playerLevel'] as int? ?? 1;
    _playerEnergy =
        (data['playerEnergy'] as num? ?? baseMaxPlayerEnergy).toDouble();

    _mainTasks = (data['mainTasks'] as List<dynamic>?)
            ?.map((mtJson) => MainTask.fromJson(mtJson as Map<String, dynamic>))
            .toList() ??
        initialMainTaskTemplates.map((t) => MainTask.fromTemplate(t)).toList();

    _completedByDay = data['completedByDay'] as Map<String, dynamic>? ?? {};
    _completedByDay.forEach((date, dayDataMap) {
      if (dayDataMap is Map<String, dynamic>) {
        dayDataMap.putIfAbsent('taskTimes', () => <String, int>{});
        dayDataMap.putIfAbsent(
            'subtasksCompleted', () => <Map<String, dynamic>>[]);
        dayDataMap.putIfAbsent(
            'checkpointsCompleted', () => <Map<String, dynamic>>[]);
        dayDataMap.putIfAbsent(
            'emotionLogs', () => <Map<String, dynamic>>[]); // Initialize emotionLogs
      }
    });

    _artifacts = (data['artifacts'] as List<dynamic>?)
            ?.map((aJson) =>
                OwnedArtifact.fromJson(aJson as Map<String, dynamic>))
            .toList() ??
        [];

    _artifactTemplatesList = (data['artifactTemplatesList'] as List<dynamic>?)
            ?.map((atJson) =>
                ArtifactTemplate.fromJson(atJson as Map<String, dynamic>))
            .toList() ??
        initialArtifactTemplates; // Use initial if not present

    _enemyTemplatesList = (data['enemyTemplatesList'] as List<dynamic>?)
            ?.map((etJson) =>
                EnemyTemplate.fromJson(etJson as Map<String, dynamic>))
            .toList() ??
        initialEnemyTemplates; // Use initial if not present

    _gameLocationsList = (data['gameLocationsList'] as List<dynamic>?)
            ?.map((glJson) =>
                GameLocation.fromJson(glJson as Map<String, dynamic>))
            .toList() ??
        initialGameLocations; // Use initial if not present

    _runeTemplatesList = (data['runeTemplatesList'] as List<dynamic>?)
            ?.map((rtJson) => Rune.fromJson(rtJson as Map<String, dynamic>))
            .toList() ??
        [];
    _ownedRunes = (data['ownedRunes'] as List<dynamic>?)
            ?.map(
                (orJson) => OwnedRune.fromJson(orJson as Map<String, dynamic>))
            .toList() ??
        [];

    final statsData = data['playerGameStats'] as Map<String, dynamic>?;
    _playerGameStats = {
      ...Map.from(basePlayerGameStats.map((key, value) => MapEntry(
          key,
          PlayerStat(
              name: value.name,
              description: value.description,
              icon: value.icon,
              value: value.value,
              base: value.base)))),
    };
    _ensureBonusXpModStat();

    if (statsData != null) {
      statsData.forEach((String key, dynamic statJsonValue) {
        if (_playerGameStats.containsKey(key) &&
            statJsonValue is Map<String, dynamic>) {
          _playerGameStats[key] = PlayerStat.fromJson(statJsonValue);
        } else if (!_playerGameStats.containsKey(key) &&
            statJsonValue is Map<String, dynamic> &&
            key == 'bonusXPMod') {
          _playerGameStats[key] = PlayerStat.fromJson(statJsonValue);
        }
      });
    }

    _equippedItems = Map<String, String?>.from(
        data['equippedItems'] as Map<dynamic, dynamic>? ??
            {'weapon': null, 'armor': null, 'talisman': null});
    _equippedRunes = Map<String, String?>.from(
        data['equippedRunes'] as Map<dynamic, dynamic>? ??
            {'rune_slot_1': null, 'rune_slot_2': null});
    _defeatedEnemyIds = (data['defeatedEnemyIds'] as List<dynamic>?)
            ?.map((id) => id as String)
            .toList() ??
        [];
    _clearedLocationIds = (data['clearedLocationIds'] as List<dynamic>?)
            ?.map((id) => id as String)
            .toList() ??
        []; // Load cleared locations

    _currentGame = data['currentGame'] != null
        ? CurrentGame.fromJson(
            data['currentGame'] as Map<String, dynamic>, _enemyTemplatesList)
        : CurrentGame(
            playerCurrentHp: _playerGameStats['vitality']!.value,
            currentPlaceKey: _gameLocationsList.isNotEmpty
                ? _gameLocationsList.first.id
                : null);

    // Ensure currentPlaceKey is valid
    if (_currentGame.currentPlaceKey == null && _gameLocationsList.isNotEmpty) {
      _currentGame.currentPlaceKey = _gameLocationsList.first.id;
    } else if (_currentGame.currentPlaceKey != null &&
        !_gameLocationsList
            .any((loc) => loc.id == _currentGame.currentPlaceKey)) {
      _currentGame.currentPlaceKey =
          _gameLocationsList.isNotEmpty ? _gameLocationsList.first.id : null;
    }

    _settings = data['settings'] != null
        ? GameSettings.fromJson(data['settings'] as Map<String, dynamic>)
        : GameSettings();

    _currentView = data['currentView'] as String? ?? 'task-details';
    _selectedTaskId = data['selectedTaskId'] as String? ??
        (_mainTasks.isNotEmpty ? _mainTasks[0].id : null);
    _apiKeyIndex = data['apiKeyIndex'] as int? ?? 0;

    _activeTimers = (data['activeTimers'] as Map<String, dynamic>?)?.map(
            (key, value) => MapEntry(key,
                ActiveTimerInfo.fromJson(value as Map<String, dynamic>))) ??
        {};

    final timestampString = data['lastSuccessfulSaveTimestamp'] as String?;
    _lastSuccessfulSaveTimestamp =
        timestampString != null ? DateTime.tryParse(timestampString) : null;

    // Park Management Data Loading
    _dinosaurSpeciesList = (data['dinosaurSpeciesList'] as List<dynamic>?)
            ?.map((dsJson) =>
                DinosaurSpecies.fromJson(dsJson as Map<String, dynamic>))
            .toList() ??
        initialDinosaurSpecies;
    _buildingTemplatesList = (data['buildingTemplatesList'] as List<dynamic>?)
            ?.map((btJson) =>
                BuildingTemplate.fromJson(btJson as Map<String, dynamic>))
            .toList() ??
        initialBuildingTemplates;
    _ownedBuildings = (data['ownedBuildings'] as List<dynamic>?)
            ?.map((obJson) =>
                OwnedBuilding.fromJson(obJson as Map<String, dynamic>))
            .toList() ??
        [];
    _ownedDinosaurs = (data['ownedDinosaurs'] as List<dynamic>?)
            ?.map((odJson) =>
                OwnedDinosaur.fromJson(odJson as Map<String, dynamic>))
            .toList() ??
        [];
    _fossilRecords = (data['fossilRecords'] as List<dynamic>?)
            ?.map((frJson) =>
                FossilRecord.fromJson(frJson as Map<String, dynamic>))
            .toList() ??
        [];
    // Ensure fossil records list matches species list
    if (_fossilRecords.length != _dinosaurSpeciesList.length) {
      _fossilRecords = _dinosaurSpeciesList
          .map((species) => _fossilRecords.firstWhere(
              (fr) => fr.speciesId == species.id,
              orElse: () => FossilRecord(speciesId: species.id)))
          .toList();
    }

    _parkManager = data['parkManager'] != null
        ? ParkManager.fromJson(data['parkManager'] as Map<String, dynamic>)
        : ParkManager();

    // Chatbot data loading
    _chatbotMemory = data['chatbotMemory'] != null
        ? ChatbotMemory.fromJson(data['chatbotMemory'] as Map<String, dynamic>)
        : ChatbotMemory();
    _isChatbotMemoryInitialized = true; // Mark as initialized after loading

    _recalculatePlayerLevel();
    _updatePlayerStatsFromItemsAndRunes();
    _parkActions.recalculateParkStats(); // Recalculate park stats after loading
    print(
        "[GameProvider] State loaded. Current XP: $_xp, Level: $_playerLevel");
  }

  Future<void> _resetToInitialState() async {
    // Make async
    print("[GameProvider] Resetting to initial state.");
    _lastLoginDate = null;
    _coins = 100;
    _xp = 0;
    _playerLevel = 1;
    _playerEnergy = baseMaxPlayerEnergy;
    _mainTasks =
        initialMainTaskTemplates.map((t) => MainTask.fromTemplate(t)).toList();
    _completedByDay = {};
    _artifacts = [];

    // Potentially load these from assets async if they become large
    _artifactTemplatesList = List.from(initialArtifactTemplates);
    _enemyTemplatesList = List.from(initialEnemyTemplates);
    _gameLocationsList = List.from(initialGameLocations);

    _runeTemplatesList = [];
    _ownedRunes = [];
    _playerGameStats = {
      ...Map.from(basePlayerGameStats.map((key, value) => MapEntry(
          key,
          PlayerStat(
              name: value.name,
              description: value.description,
              icon: value.icon,
              value: value.value,
              base: value.base)))),
    };
    _ensureBonusXpModStat();
    _equippedItems = {'weapon': null, 'armor': null, 'talisman': null};
    _equippedRunes = {'rune_slot_1': null, 'rune_slot_2': null};
    _defeatedEnemyIds = [];
    _clearedLocationIds = []; // Reset cleared locations
    _currentGame = CurrentGame(
        playerCurrentHp: _playerGameStats['vitality']!.value,
        currentPlaceKey:
            _gameLocationsList.isNotEmpty ? _gameLocationsList.first.id : null);
    _settings = GameSettings();
    _currentView = 'task-details';
    _selectedTaskId = _mainTasks.isNotEmpty ? _mainTasks[0].id : null;
    _apiKeyIndex = 0;
    _activeTimers = {};
    _isUsernameMissing = false;
    _lastSuccessfulSaveTimestamp = null;

    // Park Management Reset
    _dinosaurSpeciesList = List.from(initialDinosaurSpecies);
    _buildingTemplatesList = List.from(initialBuildingTemplates);
    _ownedBuildings = [];
    _ownedDinosaurs = [];
    _fossilRecords = _dinosaurSpeciesList
        .map((species) => FossilRecord(speciesId: species.id))
        .toList();
    _parkManager = ParkManager(
        parkDollars: 50000,
        parkEnergy: _playerEnergy,
        maxParkEnergy:
            calculatedMaxEnergy); // Start with some dollars and link park energy to player energy
    // Chatbot Reset
    _chatbotMemory = ChatbotMemory();
    _isChatbotMemoryInitialized = true;

    _hasUnsavedChanges = true;

    final rustySword = _artifactTemplatesList
        .firstWhereOrNull((art) => art.id == "art_rusty_sword");
    if (rustySword != null) {
      _artifacts.add(OwnedArtifact(
          uniqueId: "owned_${rustySword.id}_init",
          templateId: rustySword.id,
          currentLevel: 1));
      _equippedItems['weapon'] = "owned_${rustySword.id}_init";
    }
    final leatherJerkin = _artifactTemplatesList
        .firstWhereOrNull((art) => art.id == "art_leather_jerkin");
    if (leatherJerkin != null) {
      _artifacts.add(OwnedArtifact(
          uniqueId: "owned_${leatherJerkin.id}_init",
          templateId: leatherJerkin.id,
          currentLevel: 1));
      _equippedItems['armor'] = "owned_${leatherJerkin.id}_init";
    }
    _updatePlayerStatsFromItemsAndRunes();
    _parkActions.recalculateParkStats(); // Recalculate park stats after reset
    print("[GameProvider] Initial state reset complete.");
  }

  Future<void> _performActualSave() async {
    if (_currentUser != null) {
      print(
          "[GameProvider] Performing actual save to Firestore for user ${_currentUser!.uid}");
      final success = await _storageService.setUserData(_currentUser!.uid,
          _gameStateToMap()); // Changed to setUserData for full overwrite
      if (success) {
        _lastSuccessfulSaveTimestamp = DateTime.now();
        _hasUnsavedChanges = false;
        notifyListeners(); // To update UI with new save timestamp if displayed
        print(
            "[GameProvider] Save successful. Timestamp: $_lastSuccessfulSaveTimestamp");
      } else {
        print("[GameProvider] Save FAILED.");
        // Optionally, add a log to the game's UI log about save failure
        setProviderState(
            currentGame: CurrentGame(
              enemy: _currentGame.enemy,
              playerCurrentHp: _currentGame.playerCurrentHp,
              log: [
                ..._currentGame.log,
                "<span style=\"color:${AppTheme.fhAccentRed.value.toRadixString(16).substring(2)};\">Critical Error: Failed to save game data to cloud!</span>"
              ],
              currentPlaceKey: _currentGame.currentPlaceKey,
            ),
            doPersist: false, // Don't try to re-save immediately
            doNotify: true);
      }
    } else {
      print("[GameProvider] Cannot save, no current user.");
    }
  }

  Future<void> manuallySaveToCloud() async {
    if (_currentUser == null) throw Exception("Not logged in. Cannot save.");
    print("[GameProvider] Manually saving to cloud...");
    _isManuallySaving = true;
    notifyListeners();
    try {
      await _performActualSave();
    } finally {
      _isManuallySaving = false;
      notifyListeners();
      print("[GameProvider] Manual save finished.");
    }
  }

  Future<void> manuallyLoadFromCloud() async {
    if (_currentUser == null) throw Exception("Not logged in. Cannot load.");
    print("[GameProvider] Manually loading from cloud...");
    _isManuallyLoading = true;
    notifyListeners();
    try {
      final data = await _storageService.getUserData(_currentUser!.uid);
      if (data != null) {
        _loadStateFromMap(data);
        _handleDailyReset(); // Call daily reset after loading data
        // No specific auto-generation here; daily reset handles it if enabled.
        if (_currentUser?.displayName == null ||
            _currentUser!.displayName!.trim().isEmpty) {
          _isUsernameMissing = true;
        } else {
          _isUsernameMissing = false;
        }
        _hasUnsavedChanges = false; // Data is now in sync with cloud
        _isChatbotMemoryInitialized = false; // Ensure chatbot memory is re-initialized
        initializeChatbotMemory();
      } else {
        throw Exception("No data found on cloud.");
      }
    } finally {
      _isManuallyLoading = false;
      notifyListeners();
      print("[GameProvider] Manual load finished.");
    }
  }

  Future<void> loginUser(String email, String password) async {
    print("[GameProvider] Attempting login for email: $email");
    await fb_service.signInWithEmail(email, password);
  }

  Future<void> signupUser(
      String email, String password, String username) async {
    print(
        "[GameProvider] Attempting signup for email: $email, username: $username");
    _authLoading = true;
    notifyListeners();
    try {
      UserCredential userCredential =
          await fb_service.firebaseAuthInstance.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );
      _currentUser = userCredential.user;
      if (_currentUser != null) {
        print(
            "[GameProvider] Signup successful, user UID: ${_currentUser!.uid}. Updating display name.");
        await _currentUser!.updateDisplayName(username);
        await _currentUser!.reload();
        _currentUser =
            fb_service.firebaseAuthInstance.currentUser; // Refresh user object

        await _resetToInitialState(); // Make reset async
        _lastLoginDate = helper.getTodayDateString();
        _hasUnsavedChanges = true; // Mark for initial save
        // Trigger initial content generation if daily auto-gen is on
        if (settings.dailyAutoGenerateContent) {
          print(
              "[GameProvider] Initial content generation for new user after signup.");
          _aiGenerationActions
              .generateGameContent(_playerLevel,
                  isManual: false, isInitial: true, contentType: "all")
              .catchError((e) {
            print("Error during signup initial content generation: $e");
          }).whenComplete(() => _performActualSave());
        } else {
          await _performActualSave();
        }
        _isChatbotMemoryInitialized =
            false; // Ensure chatbot memory is re-initialized
        initializeChatbotMemory();

        _handleDailyReset();
        _isDataLoadingAfterLogin = false;
        _isUsernameMissing = false;
        print(
            "[GameProvider] Signup and initial setup complete for user: $username");
      } else {
        throw Exception("Signup successful but user object is null.");
      }
    } catch (e) {
      _currentUser = null;
      print("[GameProvider] Signup failed: $e");
      rethrow;
    } finally {
      _authLoading = false;
      notifyListeners();
    }
  }

  Future<void> logoutUser() async {
    print("[GameProvider] Logging out user...");
    if (_hasUnsavedChanges && _currentUser != null) {
      print("[GameProvider] Saving unsaved changes before logout.");
      await _performActualSave();
    }
    try {
      await fb_service.signOut();
      print("[GameProvider] User signed out successfully.");
    } catch (e) {
      print("[GameProvider] Error during sign out: $e");
      rethrow;
    }
  }

  Future<void> changePasswordHandler(String newPassword) async {
    if (_currentUser != null) {
      print(
          "[GameProvider] Attempting to change password for user ${_currentUser!.uid}");
      await fb_service.changePassword(newPassword);
      _hasUnsavedChanges = true;
      notifyListeners();
      print("[GameProvider] Password change successful (client-side).");
    } else {
      throw Exception("No user is currently signed in.");
    }
  }

  Future<void> updateUserDisplayName(String newUsername) async {
    if (_currentUser != null) {
      print(
          "[GameProvider] Updating display name to '$newUsername' for user ${_currentUser!.uid}");
      await _currentUser!.updateDisplayName(newUsername);
      await _currentUser!.reload();
      _currentUser = fb_service.firebaseAuthInstance.currentUser;

      _isUsernameMissing = false;
      _hasUnsavedChanges = true;
      notifyListeners();
      await _performActualSave();
      print("[GameProvider] Display name updated and saved.");
    }
  }

  void setCurrentView(String view) {
    if (_currentView != view) {
      print(
          "[GameProvider] Setting current view from '$_currentView' to '$view'");
      _currentView = view;
      _hasUnsavedChanges = true;
      notifyListeners();
    }
  }

  void setSelectedTaskId(String? taskId) {
    if (_selectedTaskId != taskId) {
      print(
          "[GameProvider] Setting selected task ID from '$_selectedTaskId' to '$taskId'");
      _selectedTaskId = taskId;
      _hasUnsavedChanges = true;
      notifyListeners();
    }
  }

  void setSettings(GameSettings newSettings) {
    _settings = newSettings;
    _hasUnsavedChanges = true;
    notifyListeners();
    print(
        "[GameProvider] Settings updated. DescriptionsVisible: ${newSettings.descriptionsVisible}, DailyAutoGenerate: ${newSettings.dailyAutoGenerateContent}, Wakeup: ${newSettings.wakeupTimeHour}:${newSettings.wakeupTimeMinute}");
  }

  String romanize(int num) => num.toString(); // Changed to common numbering

  MainTask? getSelectedTask() {
    if (_selectedTaskId == null) {
      return _mainTasks.firstOrNull;
    }
    return _mainTasks.firstWhereOrNull((t) => t.id == _selectedTaskId) ??
        _mainTasks.firstOrNull;
  }

  void _recalculatePlayerLevel() {
    int newLevel = 1;
    double xpAtStartOfLvl = 0;
    while (true) {
      final double xpNeeded =
          helper.xpToNext(newLevel, xpPerLevelBase, xpLevelMultiplier);
      if (_xp >= xpAtStartOfLvl + xpNeeded) {
        xpAtStartOfLvl += xpNeeded;
        newLevel++;
      } else {
        break;
      }
    }
    if (_playerLevel != newLevel) {
      final oldLevel = _playerLevel;
      _playerLevel = newLevel;
      print(
          "[GameProvider] Player level changed from $oldLevel to $_playerLevel. XP: $_xp");
      if (_playerLevel > oldLevel) {
        _handleLevelUpEffect();
      } else {
        _hasUnsavedChanges = true;
        notifyListeners();
      }
    }
  }

  void _handleLevelUpEffect() {
    if (_currentUser == null) return;
    print(
        "[GameProvider] Player leveled up to $_playerLevel! Handling effects.");

    const double strengthIncreasePerLevel = 0.5;
    const double defenseIncreasePerLevel = 0.3;
    const double runicIncreasePerLevel = 0.25;

    _playerGameStats['vitality']!.base = basePlayerGameStats['vitality']!.base +
        ((_playerLevel - 1) * playerEnergyPerLevelVitality);
    _playerGameStats['strength']!.base = basePlayerGameStats['strength']!.base +
        ((_playerLevel - 1) * strengthIncreasePerLevel).roundToDouble();
    _playerGameStats['defense']!.base = basePlayerGameStats['defense']!.base +
        ((_playerLevel - 1) * defenseIncreasePerLevel).roundToDouble();
    _playerGameStats['runic']!.base = basePlayerGameStats['runic']!.base +
        ((_playerLevel - 1) * runicIncreasePerLevel).roundToDouble();

    _updatePlayerStatsFromItemsAndRunes();

    _playerEnergy = calculatedMaxEnergy;
    _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;

    _currentGame.log = [
      ..._currentGame.log,
      "<span style=\"color:#${(getSelectedTask()?.taskColor ?? AppTheme.fhAccentTealFixed).value.toRadixString(16).substring(2)}\">You feel a surge of power! Level up to $_playerLevel.</span>"
    ];

    _hasUnsavedChanges = true;
    notifyListeners();
  }

  String _generateSummaryForOlderDays() {
    if (_completedByDay.isEmpty) {
        return "No activity logged before the last 7 days.";
    }
    
    List<String> olderDaysSummaryLines = ["Summary of activity older than 7 days:"];
    int olderDaysActivityCount = 0;
    DateTime today = DateTime.now();

    // Sort dates to process older ones first for the summary
    List<String> sortedDates = _completedByDay.keys.toList()..sort();

    for (String dateString in sortedDates) {
        DateTime date = DateTime.parse(dateString);
        if (today.difference(date).inDays >= 7) {
            final dayData = _completedByDay[dateString] as Map<String, dynamic>;
            final taskTimes = dayData['taskTimes'] as Map<String, dynamic>? ?? {};
            int dailyTotalMinutes = taskTimes.values.fold(0, (sum, time) => sum + (time as int));
            int dailySubtasks = (dayData['subtasksCompleted'] as List?)?.length ?? 0;
            int dailyCheckpoints = (dayData['checkpointsCompleted'] as List?)?.length ?? 0;
            int dailyEmotions = (dayData['emotionLogs'] as List?)?.length ?? 0;

            if (dailyTotalMinutes > 0 || dailySubtasks > 0 || dailyCheckpoints > 0 || dailyEmotions > 0) {
                olderDaysActivityCount++;
                String activityLine = "On $dateString: ${dailyTotalMinutes}m logged";
                if (dailySubtasks > 0) activityLine += ", $dailySubtasks sub-quests completed";
                if (dailyCheckpoints > 0) activityLine += ", $dailyCheckpoints checkpoints cleared";
                if (dailyEmotions > 0) activityLine += ", $dailyEmotions emotion logs";
                activityLine += ".";
                olderDaysSummaryLines.add(activityLine);
            }
        }
    }

    if (olderDaysActivityCount == 0) {
        return "No significant activity logged before the last 7 days.";
    }
    
    // Limit the summary length if it's too long
    if (olderDaysSummaryLines.length > 21) { // 1 title line + 20 entries
        return olderDaysSummaryLines.sublist(0, 21).join("\n") + "\n... (older entries truncated)";
    }
    return olderDaysSummaryLines.join("\n");
}


  Future<void> _handleDailyReset() async {
    if (_currentUser == null) return;
    final today = helper.getTodayDateString();
    bool hasResetRun = false;

    if (_lastLoginDate != today) {
      print(
          "[GameProvider] Daily reset triggered. Last login: $_lastLoginDate, Today: $today");
      hasResetRun = true;
      _mainTasks = _mainTasks.map((task) {
        int newStreak = task.streak;
        if (_lastLoginDate != null) {
          final yesterday = DateTime.now().subtract(const Duration(days: 1));
          final yesterdayStr = DateFormat('yyyy-MM-dd').format(yesterday);
          if (task.dailyTimeSpent < dailyTaskGoalMinutes &&
              task.lastWorkedDate != null &&
              task.lastWorkedDate != today &&
              task.lastWorkedDate != yesterdayStr) {
            newStreak = 0;
            print(
                "[GameProvider] Task '${task.name}' streak reset due to inactivity.");
          }
        }
        return MainTask(
          id: task.id,
          name: task.name,
          description: task.description,
          theme: task.theme,
          colorHex: task.colorHex,
          streak: newStreak,
          dailyTimeSpent: 0,
          lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks,
        );
      }).toList();

      _playerEnergy = calculatedMaxEnergy;
      _defeatedEnemyIds = []; // Reset defeated enemies for the day
      _clearedLocationIds = []; // Reset cleared locations for the day
      _lastLoginDate = today;
      _hasUnsavedChanges = true; // Mark changes for saving
      scheduleEmotionReminders(); // Re-schedule reminders for the new day
      print(
          "[GameProvider] Daily reset applied. Player energy restored. Streaks updated.");
    }

    if (settings.dailyAutoGenerateContent &&
        hasResetRun) { // Only run auto-gen if a daily reset actually occurred
      print("[GameProvider] Daily auto-generation triggered.");
      String? currentLocationId = _currentGame.currentPlaceKey;
      bool currentRealmPacified = false;

      if (currentLocationId != null) {
        final enemiesInLocation = _enemyTemplatesList
            .where((e) => e.locationKey == currentLocationId)
            .toList();
        if (enemiesInLocation.isNotEmpty &&
            enemiesInLocation.every((e) => _defeatedEnemyIds.contains(e.id))) {
          currentRealmPacified = true;
          print("[GameProvider] Current realm '$currentLocationId' is pacified.");
        }
      }

      if (currentLocationId == null || currentRealmPacified) {
        if (currentLocationId != null && currentRealmPacified) {
          _gameLocationsList.removeWhere((loc) => loc.id == currentLocationId);
          _clearedLocationIds.removeWhere((id) => id == currentLocationId);
          _currentGame.log.add(
              "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">Realm '$currentLocationId' pacified and archived.</span>");
          print("[GameProvider] Pacified realm '$currentLocationId' removed.");
        }

        print(
            "[GameProvider] Generating a new realm due to daily reset or pacified current realm.");
        await _aiGenerationActions.generateGameContent(_playerLevel,
            isManual: false,
            isInitial: false,
            contentType: "locations",
            numLocationsToGenerate:
                1); // generate 1 new location

        // Select the newly generated or first available realm
        if (_gameLocationsList.isNotEmpty) {
          currentLocationId = _gameLocationsList
                  .where((loc) => !_clearedLocationIds.contains(loc.id))
                  .firstOrNull
                  ?.id ??
              _gameLocationsList.first.id;
        } else {
          currentLocationId = null; // No locations available
        }
        _currentGame.currentPlaceKey = currentLocationId;
        _hasUnsavedChanges = true; // Mark changes for saving
      }

      if (currentLocationId != null) {
        print("[GameProvider] Generating new enemies for realm '$currentLocationId'.");
        await _aiGenerationActions.generateGameContent(_playerLevel,
            isManual: false,
            isInitial: false,
            contentType: "enemies",
            numEnemiesToGenerate: 3,
            specificLocationKeyForEnemies:
                currentLocationId); // generate 3 enemies for current/new location
      } else {
        print(
            "[GameProvider] No active realm to populate with new threats after daily reset.");
        _currentGame.log.add(
            "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">No active realm available for new threats.</span>");
      }
    }
    if (hasResetRun) {
      // If a daily reset happened, chatbot memory does not need specific update here as full context is passed during send.
      notifyListeners(); // Notify at the end if any reset or generation happened
    }
  }

  void _updatePlayerStatsFromItemsAndRunes() {
    final Map<String, PlayerStat> newStats = {
      ...Map.from(basePlayerGameStats.map((key, bs) => MapEntry(
          key,
          PlayerStat(
              name: bs.name,
              base: bs.base,
              value: bs.base,
              description: bs.description,
              icon: bs.icon)))),
    };
    _ensureBonusXpModStat();
    if (!newStats.containsKey('bonusXPMod')) {
      newStats['bonusXPMod'] = PlayerStat(
          name: 'XP CALC MOD',
          value: 0,
          base: 0,
          description: 'Internal XP modifier from gear.',
          icon: 'mdi-percent-outline');
    }

    const double strengthIncreasePerLevel = 0.5;
    const double defenseIncreasePerLevel = 0.3;
    const double runicIncreasePerLevel = 0.25;

    newStats['vitality']!.base = basePlayerGameStats['vitality']!.base +
        ((_playerLevel - 1) * playerEnergyPerLevelVitality);
    newStats['strength']!.base = basePlayerGameStats['strength']!.base +
        ((_playerLevel - 1) * strengthIncreasePerLevel).roundToDouble();
    newStats['defense']!.base = basePlayerGameStats['defense']!.base +
        ((_playerLevel - 1) * defenseIncreasePerLevel).roundToDouble();
    newStats['runic']!.base = basePlayerGameStats['runic']!.base +
        ((_playerLevel - 1) * runicIncreasePerLevel).roundToDouble();

    newStats.forEach((key, stat) {
      stat.value = stat.base;
    });

    _equippedItems.forEach((slot, uniqueId) {
      if (uniqueId != null) {
        final owned =
            _artifacts.firstWhereOrNull((art) => art.uniqueId == uniqueId);
        if (owned != null) {
          final template = _artifactTemplatesList
              .firstWhereOrNull((t) => t.id == owned.templateId);
          if (template != null && template.type != 'powerup') {
            final effective = _itemActions.getArtifactEffectiveStats(owned);
            newStats['strength']!.value += effective.baseAtt ?? 0;
            newStats['defense']!.value += effective.baseDef ?? 0;
            newStats['vitality']!.value += effective.baseHealth ?? 0;
            newStats['runic']!.value += effective.baseRunic ?? 0;
            newStats['luck']!.value += effective.baseLuck?.toDouble() ?? 0;
            newStats['cooldown']!.value +=
                effective.baseCooldown?.toDouble() ?? 0;
            newStats['bonusXPMod']!.value += effective.bonusXPMod ?? 0.0;
          }
        }
      }
    });

    _equippedRunes.forEach((slot, uniqueOwnedRuneId) {
      if (uniqueOwnedRuneId != null) {
        final ownedRune = _ownedRunes
            .firstWhereOrNull((or) => or.uniqueId == uniqueOwnedRuneId);
        if (ownedRune != null) {
          final runeTemplate = _runeTemplatesList
              .firstWhereOrNull((rt) => rt.id == ownedRune.runeId);
          if (runeTemplate != null && runeTemplate.type.contains("passive")) {
            if (runeTemplate.effectType == 'stat_boost' &&
                runeTemplate.targetStat != null &&
                newStats.containsKey(runeTemplate.targetStat!)) {
              newStats[runeTemplate.targetStat!]!.value +=
                  runeTemplate.effectValue;
            }
          }
        }
      }
    });

    newStats['luck']!.value =
        newStats['luck']!.value.clamp(0, double.infinity).toDouble();
    newStats['bonusXPMod']!.value =
        newStats['bonusXPMod']!.value.clamp(0, double.infinity).toDouble();

    _playerGameStats = newStats;

    if (_currentGame.playerCurrentHp > _playerGameStats['vitality']!.value) {
      _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;
    } else if (_currentGame.enemy == null &&
        _currentGame.playerCurrentHp < _playerGameStats['vitality']!.value) {
      _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;
    }
    print(
        "[GameProvider] Player stats updated. Vitality: ${_playerGameStats['vitality']!.value}, Strength: ${_playerGameStats['strength']!.value}");
  }

  bool isLocationUnlocked(String locationId) {
    final location =
        _gameLocationsList.firstWhereOrNull((loc) => loc.id == locationId);
    if (location == null) {
      print(
          "[GameProvider] isLocationUnlocked: Location ID '$locationId' not found.");
      return false;
    }

    if (_playerLevel < location.minPlayerLevelToUnlock) {
      return false;
    }
    return true;
  }

  Future<void> clearAllGameData() async {
    if (_currentUser == null) return;
    print(
        "[GameProvider] Clearing all game data for user ${_currentUser!.uid}");
    await _storageService.deleteUserData(_currentUser!.uid);
    await _resetToInitialState(); // Make reset async
    // After reset, if daily auto-gen is on, an initial populate will happen.
    if (settings.dailyAutoGenerateContent) {
      print("[GameProvider] Generating initial content after data purge.");
      await _aiGenerationActions.generateGameContent(_playerLevel,
          isManual: false, isInitial: true, contentType: "all");
    }
    await _performActualSave(); // Save the reset (and potentially newly generated) state.
    notifyListeners();
    print("[GameProvider] All game data cleared and reset.");
  }

  Future<void> resetPlayerLevelAndProgress() async {
    if (_currentUser == null) return;
    print("[GameProvider] Resetting player level and progress.");
    _playerLevel = 1;
    _xp = 0;
    _playerGameStats = {
      ...Map.from(basePlayerGameStats.map((key, value) => MapEntry(
          key,
          PlayerStat(
              name: value.name,
              description: value.description,
              icon: value.icon,
              value: value.value,
              base: value.base)))),
    };
    _ensureBonusXpModStat();
    _updatePlayerStatsFromItemsAndRunes();
    _playerEnergy = calculatedMaxEnergy;
    _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;
    _defeatedEnemyIds = [];
    // No specific content generation here as daily reset handles it.
    _currentGame.log = [
      ..._currentGame.log,
      "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">Player level and progress have been reset.</span>"
    ];
    _hasUnsavedChanges = true;
    notifyListeners();
    print("[GameProvider] Player level and progress reset complete.");
  }

  void clearAllArtifactsAndTemplates() {
    if (_currentUser == null) return;
    print("[GameProvider] Clearing all owned artifacts and templates.");
    setProviderState(
      artifacts: [], // Clear owned artifacts
      artifactTemplatesList: [], // Clear artifact templates
      equippedItems: {
        'weapon': null,
        'armor': null,
        'talisman': null
      }, // Unequip all
      currentGame: CurrentGame(
        enemy: _currentGame.enemy,
        playerCurrentHp: _currentGame.playerCurrentHp,
        log: [
          ..._currentGame.log,
          "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">All artifacts and blueprints purged.</span>"
        ],
        currentPlaceKey: _currentGame.currentPlaceKey,
      ),
    );
  }

  Future<void> removeAllGameLocations() async {
    if (_currentUser == null) return;
    print("[GameProvider] Removing all game locations (realms).");
    setProviderState(
      gameLocationsList: [],
      clearedLocationIds: [],
      defeatedEnemyIds: [], // Also clear defeated enemies as realms are gone
      currentGame: CurrentGame(
        enemy: null, // No active enemy if no realms
        playerCurrentHp: _currentGame.playerCurrentHp,
        log: [
          ..._currentGame.log,
          "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">All combat realms decommissioned. The Arena is now empty.</span>"
        ],
        currentPlaceKey: null, // No current place
      ),
    );
  }

  Future<void> clearDiscoverablePowerUps() async {
    if (_currentUser == null) return;
    print("[GameProvider] Clearing discoverable power-ups.");
    final List<String> ownedPowerUpTemplateIds = _artifacts
        .where((owned) {
          final template = _artifactTemplatesList
              .firstWhereOrNull((t) => t.id == owned.templateId);
          return template != null && template.type == 'powerup';
        })
        .map((owned) => owned.templateId)
        .toSet()
        .toList();

    final List<ArtifactTemplate> newArtifactTemplates =
        _artifactTemplatesList.where((template) {
      return template.type != 'powerup' ||
          ownedPowerUpTemplateIds.contains(template.id);
    }).toList();

    setProviderState(
        artifactTemplatesList: newArtifactTemplates,
        currentGame: CurrentGame(
          enemy: _currentGame.enemy,
          playerCurrentHp: _currentGame.playerCurrentHp,
          log: [
            ..._currentGame.log,
            "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">Discoverable power-up schematics purged. Owned items remain.</span>"
          ],
          currentPlaceKey: _currentGame.currentPlaceKey,
        ));
  }

  Future<void> removeAllEnemyTemplates() async {
    if (_currentUser == null) return;
    print("[GameProvider] Removing all enemy templates.");
    setProviderState(
        enemyTemplatesList: [],
        currentGame: CurrentGame(
          enemy: _currentGame.enemy,
          playerCurrentHp: _currentGame.playerCurrentHp,
          log: [
            ..._currentGame.log,
            "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">All enemy intelligence wiped from the database.</span>"
          ],
          currentPlaceKey: _currentGame.currentPlaceKey,
        ));
  }

  void deleteGameLocation(String locationId) {
    final newLocations =
        _gameLocationsList.where((loc) => loc.id != locationId).toList();
    final newClearedIds =
        _clearedLocationIds.where((id) => id != locationId).toList();
    String? newCurrentPlaceKey = _currentGame.currentPlaceKey;
    if (newCurrentPlaceKey == locationId) {
      newCurrentPlaceKey =
          newLocations.isNotEmpty ? newLocations.first.id : null;
    }

    setProviderState(
        gameLocationsList: newLocations,
        clearedLocationIds: newClearedIds,
        currentGame: CurrentGame(
          enemy: _currentGame.currentPlaceKey == locationId
              ? null
              : _currentGame.enemy, // Clear enemy if it was in deleted location
          playerCurrentHp: _currentGame.playerCurrentHp,
          log: [
            ..._currentGame.log,
            "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">Realm '${_gameLocationsList.firstWhereOrNull((l) => l.id == locationId)?.name ?? locationId}' has been destabilized and removed.</span>"
          ],
          currentPlaceKey: newCurrentPlaceKey,
        ));
  }

  void markLocationAsCleared(String locationId) {
    final newLocations = _gameLocationsList.map((loc) {
      if (loc.id == locationId) {
        return GameLocation(
          id: loc.id,
          name: loc.name,
          description: loc.description,
          minPlayerLevelToUnlock: loc.minPlayerLevelToUnlock,
          iconEmoji: loc.iconEmoji,
          associatedTheme: loc.associatedTheme,
          bossEnemyIdToUnlockNextLocation: loc.bossEnemyIdToUnlockNextLocation,
          isCleared: true, // Mark as cleared
        );
      }
      return loc;
    }).toList();

    final newClearedLocationIds = List<String>.from(_clearedLocationIds)
      ..add(locationId);

    setProviderState(
        gameLocationsList: newLocations,
        clearedLocationIds: newClearedLocationIds,
        currentGame: CurrentGame(
          enemy: _currentGame.enemy, // Keep current enemy if any
          playerCurrentHp: currentGame.playerCurrentHp,
          log: [
            ...currentGame.log,
            "<span style=\"color:${AppTheme.fhAccentGreen.value.toRadixString(16).substring(2)};\">Zone '${_gameLocationsList.firstWhereOrNull((loc) => loc.id == locationId)?.name ?? locationId}' has been pacified!</span>"
          ],
          currentPlaceKey: currentGame.currentPlaceKey,
        ));
  }

  // Emotion Logging
  List<EmotionLog> getEmotionLogsForDate(String date) {
    final dayData = _completedByDay[date] as Map<String, dynamic>?;
    if (dayData == null || dayData['emotionLogs'] == null) {
      return [];
    }
    return (dayData['emotionLogs'] as List<dynamic>)
        .map((logJson) => EmotionLog.fromJson(logJson as Map<String, dynamic>))
        .toList()
      ..sort((a, b) => a.timestamp.compareTo(b.timestamp));
  }

  void logEmotion(String date, int rating, [DateTime? customTimestamp]) {
    final timestamp = customTimestamp ?? DateTime.now();
    final emotionLog = EmotionLog(timestamp: timestamp, rating: rating);

    final newCompletedByDay = Map<String, dynamic>.from(_completedByDay);
    final dayData = Map<String, dynamic>.from(newCompletedByDay[date] ??
        {
          'taskTimes': <String, int>{},
          'subtasksCompleted': <Map<String, dynamic>>[],
          'checkpointsCompleted': <Map<String, dynamic>>[],
          'emotionLogs': <Map<String, dynamic>>[]
        });

    final emotionLogsList =
        List<Map<String, dynamic>>.from(dayData['emotionLogs'] as List? ?? []);

    if (emotionLogsList.length >= 10) {
      // emotionLogsList is already sorted by timestamp in getEmotionLogsForDate, and new logs are added to keep sort
      emotionLogsList.removeAt(0); // Remove the oldest
    }
    emotionLogsList.add(emotionLog.toJson());
    // Ensure it remains sorted after adding
    emotionLogsList.sort(
        (a, b) => (a['timestamp'] as String).compareTo(b['timestamp'] as String));

    dayData['emotionLogs'] = emotionLogsList;
    newCompletedByDay[date] = dayData;

    setProviderState(completedByDay: newCompletedByDay);
    _currentGame.log.add(
        "<span style='color:${AppTheme.fhAccentPurple.value.toRadixString(16).substring(2)};'>Emotion logged: $rating/5 for $date.</span>");
    notifyListeners(); // Ensure UI updates for new log
  }

  void deleteLatestEmotionLog(String date) {
    final currentLogs = getEmotionLogsForDate(date);
    if (currentLogs.isEmpty) return;

    final newCompletedByDay = Map<String, dynamic>.from(_completedByDay);
    final dayData = Map<String, dynamic>.from(newCompletedByDay[date] ?? {});
    final emotionLogsList =
        List<Map<String, dynamic>>.from(dayData['emotionLogs'] as List? ?? []);

    if (emotionLogsList.isNotEmpty) {
      emotionLogsList.removeLast(); // Assumes logs are always sorted, last one is latest
    }

    dayData['emotionLogs'] = emotionLogsList;
    newCompletedByDay[date] = dayData;

    setProviderState(completedByDay: newCompletedByDay);
    _currentGame.log.add(
        "<span style='color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)};'>Latest emotion log for $date deleted.</span>");
    notifyListeners(); // Ensure UI updates
  }

  void setWakeupTime(TimeOfDay newTime) {
    _settings.wakeupTimeHour = newTime.hour;
    _settings.wakeupTimeMinute = newTime.minute;
    setSettings(_settings); // This will notify and mark for save
    scheduleEmotionReminders(); // Re-schedule on change
  }

  List<DateTime> calculateNotificationTimes() {
    final now = DateTime.now();
    final wakeupDateTime = DateTime(
        now.year, now.month, now.day, wakeupTime.hour, wakeupTime.minute);
    const int loggingDurationMinutes = 16 * 60;
    const int numberOfLogs = 10;
    final int intervalMinutes =
        (loggingDurationMinutes / (numberOfLogs - 1)).floor();

    List<DateTime> times = [];
    DateTime currentTime = wakeupDateTime;

    for (int i = 0; i < numberOfLogs; i++) {
      times.add(currentTime);
      currentTime = currentTime.add(Duration(minutes: intervalMinutes));
    }
    // Filter times that are in the past relative to 'now' for today's reminders.
    // For future days, all 10 times would be valid.
    if (now.day == wakeupDateTime.day) {
      return times.where((t) => t.isAfter(now)).toList();
    }
    return times; // For future days, return all calculated times
  }

  void scheduleEmotionReminders() {
    // Placeholder for actual notification scheduling
    // This would involve using a plugin like flutter_local_notifications
    // E.g., flutterLocalNotificationsPlugin.cancelAll();
    // List<DateTime> notificationTimes = calculateNotificationTimes();
    // for (var time in notificationTimes) {
    //   if (time.isAfter(DateTime.now())) {
    //     flutterLocalNotificationsPlugin.zonedSchedule(...);
    //   }
    // }
    if (kDebugMode) {
      print(
          "[GameProvider] Conceptual: Would schedule notifications for: ${calculateNotificationTimes().map((t) => DateFormat('HH:mm').format(t)).join(', ')}");
    }
  }

  Future<void> resetParkData() async {
    if (_currentUser == null) return;
    print("[GameProvider] Resetting park data for user ${_currentUser!.uid}");

    setProviderState(
        ownedBuildings: [],
        ownedDinosaurs: [],
        fossilRecords: _dinosaurSpeciesList
            .map((species) => FossilRecord(speciesId: species.id))
            .toList(),
        parkManager: ParkManager(
          parkDollars: 50000,
          parkEnergy: _playerEnergy,
          maxParkEnergy: calculatedMaxEnergy,
        ),
        currentGame: CurrentGame(
          enemy: _currentGame.enemy,
          playerCurrentHp: _currentGame.playerCurrentHp,
          log: [
            ..._currentGame.log,
            "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">Jurassic Park systems reset. All assets and progress within the park have been purged.</span>"
          ],
          currentPlaceKey: _currentGame.currentPlaceKey,
        ),
        doPersist: false, // Save will be handled by _performActualSave
        doNotify: false // Notify will be handled by _performActualSave
        );

    await _performActualSave(); // Persist the reset park state
    notifyListeners(); // Notify listeners after save
    print("[GameProvider] Park data reset and saved.");
  }


  void initializeChatbotMemory() {
    if (_isChatbotMemoryInitialized) return;
    
    if (_chatbotMemory.conversationHistory.isEmpty) {
       _chatbotMemory.conversationHistory.add(ChatbotMessage(
          id: 'init_${DateTime.now().millisecondsSinceEpoch}',
          text: "Hello! I am Arcane Advisor. How can I assist you with your mission logs or goals today?",
          sender: MessageSender.bot,
          timestamp: DateTime.now()));
    }
    _isChatbotMemoryInitialized = true;
    print("[GameProvider] Chatbot memory initialized/refreshed.");
    notifyListeners();
  }

  Future<void> sendMessageToChatbot(String userMessageText) async {
    if (!_isChatbotMemoryInitialized) initializeChatbotMemory();

    final userMessage = ChatbotMessage(
        id: 'user_${DateTime.now().millisecondsSinceEpoch}',
        text: userMessageText,
        sender: MessageSender.user,
        timestamp: DateTime.now());

    _chatbotMemory.conversationHistory.add(userMessage);
    if (_chatbotMemory.conversationHistory.length > 20) { // Keep history limited
      _chatbotMemory.conversationHistory.removeAt(0);
    }

    // Handle "Remember" command
    if (userMessageText.toLowerCase().startsWith("remember:")) {
      final itemToRemember = userMessageText.substring("remember:".length).trim();
      if (itemToRemember.isNotEmpty) {
        _chatbotMemory.userRememberedItems.add(itemToRemember);
        if(_chatbotMemory.userRememberedItems.length > 10) { // Limit remembered items
            _chatbotMemory.userRememberedItems.removeAt(0);
        }
        final botResponse = ChatbotMessage(
            id: 'bot_${DateTime.now().millisecondsSinceEpoch}',
            text: "Okay, I will remember: \"$itemToRemember\"",
            sender: MessageSender.bot,
            timestamp: DateTime.now());
        _chatbotMemory.conversationHistory.add(botResponse);
        setProviderState(chatbotMemory: _chatbotMemory); // Persist memory
        return;
      }
    }
     if (userMessageText.toLowerCase().startsWith("forget last") || userMessageText.toLowerCase().startsWith("forget everything")) {
        bool forgetEverything = userMessageText.toLowerCase().startsWith("forget everything");
        String responseText;
        if (forgetEverything) {
            _chatbotMemory.userRememberedItems.clear();
            responseText = "Okay, I've cleared all previously remembered items.";
        } else if (_chatbotMemory.userRememberedItems.isNotEmpty) {
            String forgottenItem = _chatbotMemory.userRememberedItems.removeLast();
            responseText = "Okay, I've forgotten: \"$forgottenItem\"";
        } else {
            responseText = "I don't have any specific items I was asked to remember right now.";
        }
         final botResponse = ChatbotMessage(
            id: 'bot_${DateTime.now().millisecondsSinceEpoch}',
            text: responseText,
            sender: MessageSender.bot,
            timestamp: DateTime.now());
        _chatbotMemory.conversationHistory.add(botResponse);
        setProviderState(chatbotMemory: _chatbotMemory); // Persist memory
        return;
    }


    notifyListeners(); // Show user message immediately

    // Prepare context for AI
    Map<String, dynamic> completedByDayLast7DaysData = {};
    DateTime today = DateTime.now();

    _completedByDay.forEach((dateString, data) {
      DateTime date = DateTime.parse(dateString);
      if (today.difference(date).inDays < 7) {
        completedByDayLast7DaysData[dateString] = data;
      }
    });
    String completedByDayJsonForAI = jsonEncode(completedByDayLast7DaysData);
    String olderDaysSummaryForAI = _generateSummaryForOlderDays();


    try {
      final botResponseText = await _aiService.getChatbotResponse(
        memory: _chatbotMemory, // Contains conversation history and user remembered items
        userMessage: userMessageText,
        completedByDayJsonLast7Days: completedByDayJsonForAI, // NEW
        olderDaysSummary: olderDaysSummaryForAI, // NEW
        currentApiKeyIndex: _apiKeyIndex,
        onNewApiKeyIndex: (newIndex) => _apiKeyIndex = newIndex,
        onLog: (logMsg) => _currentGame.log.add(logMsg),
      );
      final botMessage = ChatbotMessage(
          id: 'bot_${DateTime.now().millisecondsSinceEpoch}',
          text: botResponseText,
          sender: MessageSender.bot,
          timestamp: DateTime.now());
      _chatbotMemory.conversationHistory.add(botMessage);
    } catch (e) {
      final errorMessage = ChatbotMessage(
          id: 'error_${DateTime.now().millisecondsSinceEpoch}',
          text: "I'm having trouble connecting right now. Please try again later.",
          sender: MessageSender.bot,
          timestamp: DateTime.now());
      _chatbotMemory.conversationHistory.add(errorMessage);
    }
    
    setProviderState(chatbotMemory: _chatbotMemory); // Persist memory including bot response
  }


  // Delegated methods
  Future<void> generateGameContent(int level,
          {bool isManual = false,
          bool isInitial = false,
          String contentType = "all",
          int numLocationsToGenerate = 0, // Added for specific requests
          int numEnemiesToGenerate = 0, // Added
          String? specificLocationKeyForEnemies // Added
          }) =>
      _aiGenerationActions.generateGameContent(level,
          isManual: isManual,
          isInitial: isInitial,
          contentType: contentType,
          numLocationsToGenerate: numLocationsToGenerate,
          numEnemiesToGenerate: numEnemiesToGenerate,
          specificLocationKeyForEnemies: specificLocationKeyForEnemies);

  void addMainTask(
          {required String name,
          required String description,
          required String theme,
          required String colorHex}) =>
      _taskActions.addMainTask(
          name: name,
          description: description,
          theme: theme,
          colorHex: colorHex);
  void editMainTask(String taskId,
          {required String name,
          required String description,
          required String theme,
          required String colorHex}) =>
      _taskActions.editMainTask(taskId,
          name: name,
          description: description,
          theme: theme,
          colorHex: colorHex);
  void logToDailySummary(String type, Map<String, dynamic> data) =>
      _taskActions.logToDailySummary(type, data);
  String addSubtask(String mainTaskId, Map<String, dynamic> subtaskData) =>
      _taskActions.addSubtask(mainTaskId, subtaskData);
  void updateSubtask(
          String mainTaskId, String subtaskId, Map<String, dynamic> updates) =>
      _taskActions.updateSubtask(mainTaskId, subtaskId, updates);
  bool completeSubtask(String mainTaskId, String subtaskId) =>
      _taskActions.completeSubtask(mainTaskId, subtaskId);
  void deleteSubtask(String mainTaskId, String subtaskId) =>
      _taskActions.deleteSubtask(mainTaskId, subtaskId);
  void duplicateCompletedSubtask(String mainTaskId, String subtaskId) =>
      _taskActions.duplicateCompletedSubtask(mainTaskId, subtaskId);
  void addSubSubtask(String mainTaskId, String parentSubtaskId,
          Map<String, dynamic> subSubtaskData) =>
      _taskActions.addSubSubtask(mainTaskId, parentSubtaskId, subSubtaskData);
  void updateSubSubtask(String mainTaskId, String parentSubtaskId,
          String subSubtaskId, Map<String, dynamic> updates) =>
      _taskActions.updateSubSubtask(
          mainTaskId, parentSubtaskId, subSubtaskId, updates);
  void completeSubSubtask(
          String mainTaskId, String parentSubtaskId, String subSubtaskId) =>
      _taskActions.completeSubSubtask(
          mainTaskId, parentSubtaskId, subSubtaskId);
  void deleteSubSubtask(
          String mainTaskId, String parentSubtaskId, String subSubtaskId) =>
      _taskActions.deleteSubSubtask(mainTaskId, parentSubtaskId, subSubtaskId);

  OwnedArtifact? getArtifactByUniqueId(String uniqueId) =>
      _itemActions.getArtifactByUniqueId(uniqueId);
  ArtifactTemplate? getArtifactTemplateById(String templateId) =>
      _itemActions.getArtifactTemplateById(templateId);
  ArtifactTemplate getArtifactEffectiveStats(OwnedArtifact ownedArtifact) =>
      _itemActions.getArtifactEffectiveStats(ownedArtifact);
  void buyArtifact(String templateId) => _itemActions.buyArtifact(templateId);
  bool upgradeArtifact(String uniqueId) =>
      _itemActions.upgradeArtifact(uniqueId);
  bool sellArtifact(String uniqueId) => _itemActions.sellArtifact(uniqueId);
  void equipArtifact(String uniqueId) => _itemActions.equipArtifact(uniqueId);
  void unequipArtifact(String slot) => _itemActions.unequipArtifact(slot);
  void acquireRune(String runeId) {
    print("[GameProvider] Placeholder: Acquire Rune $runeId");
    notifyListeners();
  }

  void equipRune(String ownedRuneUniqueId, String slot) {
    print("[GameProvider] Placeholder: Equip Rune $ownedRuneUniqueId to $slot");
    _updatePlayerStatsFromItemsAndRunes();
    notifyListeners();
  }

  void unequipRune(String slot) {
    print("[GameProvider] Placeholder: Unequip Rune from $slot");
    _updatePlayerStatsFromItemsAndRunes();
    notifyListeners();
  }

  void startGame(String enemyId) => _combatActions.startGame(enemyId);
  void handleFight() => _combatActions.handleFight();
  void usePowerUp(String uniqueId) => _combatActions.usePowerUp(uniqueId);
  void forfeitMatch() => _combatActions.forfeitMatch();
  void checkAndClearLocationIfAllEnemiesDefeated(String locationId) =>
      _combatActions.checkAndClearLocationIfAllEnemiesDefeated(locationId);

  Future<void> triggerAISubquestGeneration(MainTask mainTask,
          String generationMode, String userInput, int numSubquests) =>
      _aiGenerationActions.triggerAISubquestGeneration(
          mainTask, generationMode, userInput, numSubquests);

  void startTimer(String id, String type, String mainTaskId) =>
      _timerActions.startTimer(id, type, mainTaskId);
  void pauseTimer(String id) => _timerActions.pauseTimer(id);
  void logTimerAndReset(String id) => _timerActions.logTimerAndReset(id);

  // Park Actions Delegation
  bool canAffordBuilding(BuildingTemplate buildingTemplate) =>
      _parkActions.canAffordBuilding(buildingTemplate);
  void buyAndPlaceBuilding(String buildingTemplateId) =>
      _parkActions.buyAndPlaceBuilding(buildingTemplateId);
  void sellBuilding(String ownedBuildingUniqueId) =>
      _parkActions.sellBuilding(ownedBuildingUniqueId);
  void excavateFossil(String speciesId) =>
      _parkActions.excavateFossil(speciesId);
  void incubateDinosaur(String speciesId) =>
      _parkActions.incubateDinosaur(speciesId);
  void addDinosaurToEnclosure(
          String dinosaurUniqueId, String enclosureUniqueId) =>
      _parkActions.addDinosaurToEnclosure(dinosaurUniqueId, enclosureUniqueId);
  void feedDinosaursInEnclosure(String enclosureUniqueId, int amount) =>
      _parkActions.feedDinosaursInEnclosure(enclosureUniqueId, amount);
  void toggleBuildingOperationalStatus(String ownedBuildingUniqueId) =>
      _parkActions.toggleBuildingOperationalStatus(ownedBuildingUniqueId);
  void skipOneMinute() =>
      _parkActions.skipOneMinute(); // New skip minute method

  void setProviderState({
    String? lastLoginDate,
    double? coins,
    double? xp,
    double? playerEnergy,
    List<MainTask>? mainTasks,
    Map<String, dynamic>? completedByDay,
    List<OwnedArtifact>? artifacts,
    List<ArtifactTemplate>? artifactTemplatesList,
    List<EnemyTemplate>? enemyTemplatesList,
    List<GameLocation>? gameLocationsList,
    List<Rune>? runeTemplatesList,
    List<OwnedRune>? ownedRunes,
    Map<String, PlayerStat>? playerGameStats,
    Map<String, String?>? equippedItems,
    Map<String, String?>? equippedRunes,
    List<String>? defeatedEnemyIds,
    List<String>? clearedLocationIds, // Add for setProviderState
    CurrentGame? currentGame,
    Map<String, ActiveTimerInfo>? activeTimers,
    DateTime? lastSuccessfulSaveTimestamp,
    bool? isUsernameMissing,
    // Park Management
    List<DinosaurSpecies>? dinosaurSpeciesList,
    List<BuildingTemplate>? buildingTemplatesList,
    List<OwnedBuilding>? ownedBuildings,
    List<OwnedDinosaur>? ownedDinosaurs,
    List<FossilRecord>? fossilRecords,
    ParkManager? parkManager,
    // Chatbot
    ChatbotMemory? chatbotMemory,
    bool doNotify = true,
    bool doPersist = true,
  }) {
    bool changed = false;
    int oldLevel = _playerLevel;

    if (lastLoginDate != null && _lastLoginDate != lastLoginDate) {
      _lastLoginDate = lastLoginDate;
      changed = true;
    }
    if (coins != null && _coins != coins) {
      _coins = coins;
      changed = true;
    }

    if (xp != null && _xp != xp) {
      _xp = xp;
      _recalculatePlayerLevel();
      changed = true;
    }

    if (playerEnergy != null && _playerEnergy != playerEnergy) {
      _playerEnergy = playerEnergy.clamp(0, calculatedMaxEnergy);
      changed = true;
    }

    // For lists and maps, ensure a change is detected if the reference changes or content changes
    if (mainTasks != null && !listEquals(_mainTasks, mainTasks)) {
      _mainTasks =
          List.from(mainTasks); // Create new list to ensure change detection
      changed = true;
    }
    if (completedByDay != null && !mapEquals(_completedByDay, completedByDay)) {
      _completedByDay = Map.from(completedByDay);
      changed = true;
    }

    bool itemsOrRunesOrEquippedChanged = false;
    if (artifacts != null && !listEquals(_artifacts, artifacts)) {
      _artifacts = List.from(artifacts);
      itemsOrRunesOrEquippedChanged = true;
      changed = true;
    }
    if (artifactTemplatesList != null &&
        !listEquals(_artifactTemplatesList, artifactTemplatesList)) {
      _artifactTemplatesList = List.from(artifactTemplatesList);
      changed = true;
    }
    if (enemyTemplatesList != null &&
        !listEquals(_enemyTemplatesList, enemyTemplatesList)) {
      _enemyTemplatesList = List.from(enemyTemplatesList);
      changed = true;
    }
    if (gameLocationsList != null &&
        !listEquals(_gameLocationsList, gameLocationsList)) {
      _gameLocationsList = List.from(gameLocationsList);
      changed = true;
    }
    if (clearedLocationIds != null &&
        !listEquals(_clearedLocationIds, clearedLocationIds)) {
      _clearedLocationIds = List.from(clearedLocationIds);
      changed = true;
    }
    if (runeTemplatesList != null &&
        !listEquals(_runeTemplatesList, runeTemplatesList)) {
      _runeTemplatesList = List.from(runeTemplatesList);
      changed = true;
    }
    if (ownedRunes != null && !listEquals(_ownedRunes, ownedRunes)) {
      _ownedRunes = List.from(ownedRunes);
      itemsOrRunesOrEquippedChanged = true;
      changed = true;
    }

    if (playerGameStats != null &&
        !mapEquals(_playerGameStats, playerGameStats)) {
      playerGameStats.forEach((key, newStat) {
        if (_playerGameStats.containsKey(key)) {
          _playerGameStats[key]!.base = newStat.base;
          _playerGameStats[key]!.value =
              newStat.value; // Ensure value is also updated
        } else {
          _playerGameStats[key] = newStat;
        }
      });
      _ensureBonusXpModStat();
      itemsOrRunesOrEquippedChanged = true;
      changed = true;
    }

    if (equippedItems != null && !mapEquals(_equippedItems, equippedItems)) {
      _equippedItems = Map.from(equippedItems);
      itemsOrRunesOrEquippedChanged = true;
      changed = true;
    }
    if (equippedRunes != null && !mapEquals(_equippedRunes, equippedRunes)) {
      _equippedRunes = Map.from(equippedRunes);
      itemsOrRunesOrEquippedChanged = true;
      changed = true;
    }

    if (itemsOrRunesOrEquippedChanged || oldLevel != _playerLevel) {
      _updatePlayerStatsFromItemsAndRunes();
    }

    if (defeatedEnemyIds != null &&
        !listEquals(_defeatedEnemyIds, defeatedEnemyIds)) {
      _defeatedEnemyIds = List.from(defeatedEnemyIds);
      changed = true;
    }
    if (currentGame != null && _currentGame != currentGame) {
      // This comparison might need to be deeper
      _currentGame = currentGame; // Assume currentGame is a new instance
      if (_playerGameStats['vitality'] != null &&
          _currentGame.playerCurrentHp > _playerGameStats['vitality']!.value) {
        _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;
      }
      changed = true;
    }
    if (activeTimers != null && !mapEquals(_activeTimers, activeTimers)) {
      _activeTimers = Map.from(activeTimers);
      changed = true;
    }
    if (lastSuccessfulSaveTimestamp != null &&
        _lastSuccessfulSaveTimestamp != lastSuccessfulSaveTimestamp) {
      _lastSuccessfulSaveTimestamp = lastSuccessfulSaveTimestamp;
      changed = true;
    }
    if (isUsernameMissing != null && _isUsernameMissing != isUsernameMissing) {
      _isUsernameMissing = isUsernameMissing;
      changed = true;
    }

    // Park Management State Updates
    if (dinosaurSpeciesList != null &&
        !listEquals(_dinosaurSpeciesList, dinosaurSpeciesList)) {
      _dinosaurSpeciesList = List.from(dinosaurSpeciesList);
      changed = true;
    }
    if (buildingTemplatesList != null &&
        !listEquals(_buildingTemplatesList, buildingTemplatesList)) {
      _buildingTemplatesList = List.from(buildingTemplatesList);
      changed = true;
    }
    if (ownedBuildings != null &&
        !listEquals(_ownedBuildings, ownedBuildings)) {
      _ownedBuildings = List.from(ownedBuildings);
      changed = true;
    }
    if (ownedDinosaurs != null &&
        !listEquals(_ownedDinosaurs, ownedDinosaurs)) {
      _ownedDinosaurs = List.from(ownedDinosaurs);
      changed = true;
    }
    if (fossilRecords != null && !listEquals(_fossilRecords, fossilRecords)) {
      _fossilRecords = List.from(fossilRecords);
      changed = true;
    }
    if (parkManager != null && _parkManager != parkManager) {
      // Simple comparison, might need deep compare if ParkManager becomes complex
      _parkManager = parkManager;
      // When ParkManager state is updated, ensure player energy is consistent if used for park ops
      if (_parkManager.parkEnergy != _playerEnergy ||
          _parkManager.maxParkEnergy != calculatedMaxEnergy) {
        _parkManager.parkEnergy = _playerEnergy;
        _parkManager.maxParkEnergy = calculatedMaxEnergy;
      }
      changed = true;
    }
    // Chatbot state update
    if (chatbotMemory != null && _chatbotMemory != chatbotMemory) {
      _chatbotMemory = chatbotMemory;
      changed = true;
    }

    if (changed) {
      if (kDebugMode && doNotify) {
        print(
            "[GameProvider] setProviderState detected changes, will notify. Persist: $doPersist.");
      }
      if (doPersist) _hasUnsavedChanges = true;
      if (doNotify) notifyListeners();
    }
  }

  void setProviderAIGlobalLoading(bool isLoading,
      {double progress = 0.0, String statusMessage = ""}) {
    bool changed = false;
    if (_isGeneratingGlobalContent != isLoading) {
      _isGeneratingGlobalContent = isLoading;
      changed = true;
    }
    if (_aiGenerationProgress != progress) {
      _aiGenerationProgress = progress;
      changed = true;
    }
    if (_aiGenerationStatusMessage != statusMessage) {
      _aiGenerationStatusMessage = statusMessage;
      changed = true;
    }
    if (changed) {
      print(
          "[GameProvider] AI Global Loading set to: $isLoading, Progress: $progress, Message: $statusMessage");
      notifyListeners();
    }
  }

  void setProviderAISubquestLoading(bool isLoading) {
    if (_isGeneratingSubquestsForTask != isLoading) {
      _isGeneratingSubquestsForTask = isLoading;
      print("[GameProvider] AI Subquest Loading set to: $isLoading");
      notifyListeners();
    }
  }

  void setProviderApiKeyIndex(int index) {
    if (_apiKeyIndex != index) {
      _apiKeyIndex = index;
      print("[GameProvider] API Key Index set to: $index");
      // No need to notify listeners for this internal state unless UI depends on it directly
    }
  }
}
--- END OF FILE lib/src/providers/game_provider.dart ---

--- START OF FILE lib/src/providers/actions/ai_generation_actions.dart ---
// lib/src/providers/actions/ai_generation_actions.dart
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/services/ai_service.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:flutter/foundation.dart'; // For kDebugMode
import 'package:collection/collection.dart'; // For whereNotNull
import 'dart:math' as math_random;

class AIGenerationActions {
  final GameProvider _provider;
  final AIService _aiService = AIService();
  final math_random.Random _random = math_random.Random();



  AIGenerationActions(this._provider);

  // Helper to generate a unique ID
  String _generateUniqueId(String type, String name, String? theme, int level) {
    final namePart = name.replaceAll(RegExp(r'\s+'), '_').toLowerCase();
    final themePart = theme ?? 'general';
    return 'gen_${type}_${themePart}_${namePart}_lvl${level}_${_random.nextInt(100000)}';
  }

  // --- Programmatic Stat Generation ---
  Map<String, dynamic> _generateEnemyStats(
      String id, String name, String? theme, String description, int level, String specificLocationKey) {
    
    return {
      'id': id,
      'name': name,
      'theme': theme,
      'locationKey': specificLocationKey, // Use the provided specific location key
      'minPlayerLevel': level,
      'health': (40 + level * 10) + _random.nextInt(20 + level * 5),
      'attack': (7 + level * 1.5).toInt() + _random.nextInt(3 + level ~/ 2),
      'defense': (2 + level * 0.5).toInt() + _random.nextInt(2 + level ~/ 3),
      'coinReward': (15 + level * 4) + _random.nextInt(20 + level * 4),
      'xpReward': (25 + level * 6) + _random.nextInt(30 + level * 6),
      'description': description,
    };
  }

  Map<String, dynamic> _generateArtifactStats(String id, String name,
      String? theme, String description, String icon, String type, int level) {
    int cost = (30 + level * 10) + _random.nextInt(100 + level * 15);
    Map<String, dynamic> stats = {
      'id': id,
      'name': name,
      'type': type, // weapon, armor, talisman
      'theme': theme,
      'description': description,
      'cost': cost,
      'icon': icon,
      'maxLevel': _random.nextInt(3) + 2, // Max level 2, 3, or 4
    };

    if (type == 'weapon') {
      stats['baseAtt'] = (level * 0.2 + 1).toInt() + _random.nextInt(level ~/ 4 + 1);
      stats['baseRunic'] = (level * 0.15 + (_random.nextBool() ? 1 : 0)).toInt() + _random.nextInt(level ~/ 5 + 1);
      stats['upgradeBonus'] = {"att": 1 + _random.nextInt(level ~/ 8 + 1)};
    } else if (type == 'armor') {
      stats['baseDef'] = (level * 0.18 + 1).toInt() + _random.nextInt(level ~/ 5 + 1);
      stats['baseHealth'] = (level * 1.2 + 3).toInt() + _random.nextInt(level * 1 + 4);
      stats['upgradeBonus'] = {"def": 1 + _random.nextInt(level ~/ 8 + 1), "health": 2 + _random.nextInt(level ~/ 4 + 1)};
    } else if (type == 'talisman') {
      stats['baseLuck'] = _random.nextInt(level ~/ 2 + 2) + 1; // e.g., max 1 + 1 = 2 at L1, 1+3 = 4 at L5
      stats['baseCooldown'] = _random.nextInt(level ~/ 2 + 1);
      stats['bonusXPMod'] = _random.nextDouble() * 0.02; // Max 2%
      stats['upgradeBonus'] = _random.nextBool() ? {"luck": 1} : {"cooldown": 1};
       if (_random.nextDouble() < 0.2) { // 20% chance for talisman to also have a small baseAtt or baseRunic
        if(_random.nextBool()){
          stats['baseAtt'] = (level * 0.1).toInt() + 1;
        } else {
          stats['baseRunic'] = (level * 0.1).toInt() + 1;
        }
      }
    }
    // Ensure all numeric stat fields are present, defaulting to 0 or null
    for (var key in ['baseAtt', 'baseRunic', 'baseDef', 'baseHealth', 'baseLuck', 'baseCooldown']) {
        stats.putIfAbsent(key, () => 0);
    }
    stats.putIfAbsent('bonusXPMod', () => 0.0);


    return stats;
  }

  Map<String, dynamic> _generatePowerupStats(
      String id, String name, String? theme, String description, String icon, int level) {
    String effectType = _random.nextBool() ? 'direct_damage' : 'heal_player';
    int effectValue;
    if (effectType == 'direct_damage') {
      effectValue = (level * 3 + 10) + _random.nextInt(level * 2 + 10);
    } else {
      effectValue = (level * 2 + 8) + _random.nextInt(level * 2 + 8);
    }
    return {
      'id': id,
      'name': name,
      'type': 'powerup',
      'theme': theme,
      'description': description,
      'cost': (15 + level * 5) + _random.nextInt(30 + level * 5),
      'icon': icon,
      'effectType': effectType,
      'effectValue': effectValue,
      'uses': 1,
    };
  }

 Map<String, dynamic> _generateLocationStats(
      String id, String name, String description, String iconEmoji, String? theme, int level) {
    String? bossId;
    // If there are enemies, try to pick one as a boss. Prioritize by level and theme if possible.
    // This now needs to consider that enemies might not be generated *yet* if this location is generated first.
    // So, bossId might often be null initially and set later, or chosen from existing enemies if appropriate.
    final potentialBosses = _provider.enemyTemplatesList
            .where((e) => (e.theme == theme || theme == null) && e.minPlayerLevel >= level && e.minPlayerLevel <= level + 2)
            .toList();
    if (potentialBosses.isNotEmpty) {
        bossId = potentialBosses[_random.nextInt(potentialBosses.length)].id;
    }
    // If no suitable existing boss, it will remain null. GameProvider can later assign a newly generated enemy as boss.

    return {
      'id': id,
      'name': name,
      'description': description,
      'minPlayerLevelToUnlock': level + _random.nextInt(2), // Lvl or Lvl+1
      'iconEmoji': iconEmoji,
      'associatedTheme': theme,
      'bossEnemyIdToUnlockNextLocation': bossId, // Can be null
    };
  }


  Future<void> generateGameContent(int levelForContent,
      {bool isManual = false,
      bool isInitial = false,
      String contentType = "all",
      int numLocationsToGenerate = 0,
      int numEnemiesToGenerate = 0,
      String? specificLocationKeyForEnemies,
      }) async {
    try {
      if (_provider.isGeneratingContent && !isManual && !isInitial) {
        print("[AIActions] generateGameContent skipped, already in progress for $contentType.");
        return;
      }
      _provider.setProviderAIGlobalLoading(true,
          progress: 0.0,
          statusMessage: "Initializing AI protocol for names/icons generation ($contentType)...");

      List<String?> activeThemes = _provider.mainTasks.map((t) => t.theme).toSet().toList();
      if (activeThemes.isEmpty) activeThemes.add(null); // Ensure at least general theme for generation requests

      // Build request for AI
      List<Map<String, dynamic>> aiRequestedItems = [];
      int actualNumLocations = numLocationsToGenerate > 0 ? numLocationsToGenerate : ((contentType == "all" || contentType == "locations") ? (isInitial ? 2 : 1) : 0);
      int actualNumEnemies = numEnemiesToGenerate > 0 ? numEnemiesToGenerate : ((contentType == "all" || contentType == "enemies") ? (isInitial ? 2 : 1) : 0); // Total enemies, not per theme for simplicity here
      int numArtifactsPerSubtypePerTheme = (contentType == "all" || contentType == "artifacts") ? (isInitial ? 1 : 1) : 0;
      int numPowerupsPerTheme = (contentType == "all" || contentType == "artifacts") ? (isInitial ? 1 : 0) : 0;


      if (actualNumLocations > 0) {
         for (int i = 0; i < actualNumLocations; i++) {
            aiRequestedItems.add({"itemCategory": "location", "themeHint": activeThemes[_random.nextInt(activeThemes.length)]});
         }
      }
      if (actualNumEnemies > 0) {
        for (int i = 0; i < actualNumEnemies; i++) {
          // If specificLocationKeyForEnemies is provided, we need its theme.
          // Otherwise, pick a random theme from activeThemes.
          String? themeForEnemy;
          if (specificLocationKeyForEnemies != null) {
            final loc = _provider.gameLocationsList.firstWhereOrNull((l) => l.id == specificLocationKeyForEnemies);
            themeForEnemy = loc?.associatedTheme; // Could be null if loc theme is null
          } else {
            themeForEnemy = activeThemes[_random.nextInt(activeThemes.length)];
          }
          aiRequestedItems.add({"itemCategory": "enemy", "themeHint": themeForEnemy});
        }
      }
      if (numArtifactsPerSubtypePerTheme > 0) {
        for (var theme in activeThemes) {
          for (int i = 0; i < numArtifactsPerSubtypePerTheme; i++) {
            aiRequestedItems.add({"itemCategory": "artifact_weapon", "themeHint": theme});
            aiRequestedItems.add({"itemCategory": "artifact_armor", "themeHint": theme});
            aiRequestedItems.add({"itemCategory": "artifact_talisman", "themeHint": theme});
          }
        }
      }
      if (numPowerupsPerTheme > 0) {
        for (var theme in activeThemes) {
          for (int i = 0; i < numPowerupsPerTheme; i++) {
            aiRequestedItems.add({"itemCategory": "powerup", "themeHint": theme});
          }
        }
      }
      
      if (aiRequestedItems.isEmpty) {
         _provider.setProviderAIGlobalLoading(false, progress: 1.0, statusMessage: "No items requested for AI generation for $contentType.");
         return;
      }

      final String prompt = """
Generate creative game content. For each item in the 'requestedItems' list, provide a name, a short evocative description, a theme (from the 'themeHint' or null if 'themeHint' is null/general), and a single relevant emoji icon (for artifacts, powerups, locations).
The 'itemCategory' specifies the type of item.
Return a single JSON object with one key: "generatedItems". "generatedItems" should be an array of objects, each corresponding to a requested item.
Each object in "generatedItems" MUST have:
- "itemCategory": string (must match the category from the request)
- "name": string (creative and fitting the category and theme)
- "description": string (short, max 80 chars)
- "theme": string or null (must match or be consistent with the 'themeHint' from the request)
- "icon": string (single emoji, applicable for itemCategory 'location', 'artifact_weapon', 'artifact_armor', 'artifact_talisman', 'powerup'. For 'enemy', this can be a simple descriptive emoji or null.)

Example Request:
{ "requestedItems": [ {"itemCategory": "location", "themeHint": "nature"}, {"itemCategory": "enemy", "themeHint": "nature"} ] }

Example Response:
{
  "generatedItems": [
    { "itemCategory": "location", "name": "Verdant Grove", "description": "A lush, ancient forest.", "theme": "nature", "icon": "🌳" },
    { "itemCategory": "enemy", "name": "Grove Spider", "description": "A large, camouflaged arachnid.", "theme": "nature", "icon": "🕷️" }
  ]
}
Do NOT generate stats, costs, levels, or IDs. Only name, description, theme, and icon (where applicable).
Ensure the 'theme' in your response is the same as the 'themeHint' provided for that item, or null if the 'themeHint' was null.
Existing content IDs to avoid duplicating names for (informational only, focus on unique names):
Locations: ${_provider.gameLocationsList.map((e) => e.name).join(', ')}
Enemies: ${_provider.enemyTemplatesList.map((e) => e.name).join(', ')}
Artifacts: ${_provider.artifactTemplatesList.map((e) => e.name).join(', ')}

Request:
${({"requestedItems": aiRequestedItems})}
""";
      _provider.setProviderAIGlobalLoading(true, progress: 0.2, statusMessage: "Contacting AI for names & icons ($contentType)...");
      

      final Map<String, dynamic> aiResponse = await _aiService.makeAICall(
        prompt: prompt,
        currentApiKeyIndex: _provider.apiKeyIndex,
        onNewApiKeyIndex: _provider.setProviderApiKeyIndex,
        onLog: (log) {
          print("[AI Service Log - Content Type: $contentType]: $log");
          _logToGame(log);
        },
      );
       _provider.setProviderAIGlobalLoading(true, progress: 0.5, statusMessage: "AI response received. Processing $contentType items...");

      final List<Map<String, dynamic>> generatedAiItems =
          (aiResponse['generatedItems'] as List?)?.map((item) => item as Map<String, dynamic>).toList() ?? [];

      List<EnemyTemplate> newEnemies = [];
      List<ArtifactTemplate> newArtifacts = [];
      List<GameLocation> newLocations = [];

      for (var aiItem in generatedAiItems) {
        final String itemCategory = aiItem['itemCategory'] as String? ?? 'unknown';
        final String itemName = aiItem['name'] as String? ?? 'Unnamed';
        final String itemDescription = aiItem['description'] as String? ?? 'No description.';
        final String? itemTheme = aiItem['theme'] as String?; // Can be null
        final String itemIcon = aiItem['icon'] as String? ?? '❓';

        if (itemName == 'Unnamed' || _nameExists(itemName, itemCategory)) {
            print("[AIActions] Skipping item due to 'Unnamed' or duplicate name: $itemName (Category: $itemCategory)");
            continue; // Skip if name is default or already exists for that category
        }


        if (itemCategory == 'location') {
          final id = _generateUniqueId('loc', itemName, itemTheme, levelForContent);
          newLocations.add(GameLocation.fromJson(_generateLocationStats(id, itemName, itemDescription, itemIcon, itemTheme, levelForContent)));
        } else if (itemCategory == 'enemy') {
          final id = _generateUniqueId('enemy', itemName, itemTheme, levelForContent);
          final String locKeyForEnemy = specificLocationKeyForEnemies ?? 
                                        _provider.gameLocationsList.firstWhereOrNull((l) => l.associatedTheme == itemTheme)?.id ?? 
                                        _provider.gameLocationsList.firstOrNull?.id ?? 
                                        "default_zone_error";
          newEnemies.add(EnemyTemplate.fromJson(_generateEnemyStats(id, itemName, itemTheme, itemDescription, levelForContent, locKeyForEnemy)));
        } else if (itemCategory.startsWith('artifact_')) {
          final type = itemCategory.split('_')[1]; // weapon, armor, talisman
          final id = _generateUniqueId('art', itemName, itemTheme, levelForContent);
          newArtifacts.add(ArtifactTemplate.fromJson(_generateArtifactStats(id, itemName, itemTheme, itemDescription, itemIcon, type, levelForContent)));
        } else if (itemCategory == 'powerup') {
          final id = _generateUniqueId('pwp', itemName, itemTheme, levelForContent);
          newArtifacts.add(ArtifactTemplate.fromJson(_generatePowerupStats(id, itemName, itemTheme, itemDescription, itemIcon, levelForContent)));
        }
      }
      _provider.setProviderAIGlobalLoading(true, progress: 0.8, statusMessage: "Finalizing generated $contentType content...");

      if (newLocations.isNotEmpty) {
        _provider.setProviderState(gameLocationsList: [..._provider.gameLocationsList, ...newLocations], doPersist: false);
      }
      if (newEnemies.isNotEmpty) {
        _provider.setProviderState(enemyTemplatesList: [..._provider.enemyTemplatesList, ...newEnemies], doPersist: false);
      }
      if (newArtifacts.isNotEmpty) {
        _provider.setProviderState(artifactTemplatesList: [..._provider.artifactTemplatesList, ...newArtifacts], doPersist: false);
      }
      
      if (newLocations.isNotEmpty || newEnemies.isNotEmpty || newArtifacts.isNotEmpty) {
         _logToGame("<span style=\"color:${AppTheme.fhAccentGreen.value.toRadixString(16).substring(2)};\">AI has infused the world with new $contentType elements for level $levelForContent.</span>");
         _provider.setProviderState(doPersist: true, doNotify: true); // Trigger a single save and notify
      } else {
         _logToGame("<span style=\"color:var(--fh-accent-orange);\">AI generation for $contentType (L$levelForContent) did not yield new unique content.</span>");
      }

    } catch (e, stackTrace) {
      final errorMessage = e.toString();
      print("[AIActions] CRITICAL ERROR in generateGameContent ($contentType): $errorMessage");
      if (kDebugMode) print("[AIActions] StackTrace for generateGameContent ($contentType) error: $stackTrace");
      _logToGame("<span style=\"color:${AppTheme.fhAccentRed.value.toRadixString(16).substring(2)};\">AI content generation for $contentType failed critically: $errorMessage</span>");
    } finally {
      _provider.setProviderAIGlobalLoading(false,
          progress: 1.0,
          statusMessage: "Content generation protocol for $contentType finished.");
    }
  }

  bool _nameExists(String name, String itemCategory) {
    if (itemCategory == 'location') {
        return _provider.gameLocationsList.any((loc) => loc.name.toLowerCase() == name.toLowerCase());
    } else if (itemCategory == 'enemy') {
        return _provider.enemyTemplatesList.any((enemy) => enemy.name.toLowerCase() == name.toLowerCase());
    } else if (itemCategory.startsWith('artifact_') || itemCategory == 'powerup') {
        return _provider.artifactTemplatesList.any((art) => art.name.toLowerCase() == name.toLowerCase());
    }
    return false;
}


  void _logToGame(String logMessage) {
    if (kDebugMode) print("[AIActions - _logToGame]: $logMessage");
    _provider.setProviderState(
        currentGame: CurrentGame(
          enemy: _provider.currentGame.enemy,
          playerCurrentHp: _provider.currentGame.playerCurrentHp,
          log: [..._provider.currentGame.log, logMessage],
          currentPlaceKey: _provider.currentGame.currentPlaceKey,
        ),
        doPersist: false, // Persisted at the end of generateGameContent or when subquests are added
        doNotify: true);
  }

  Future<void> triggerAISubquestGeneration(MainTask mainTaskForSubquests,
      String generationMode, String userInput, int numSubquests) async {
    if (_provider.isGeneratingSubquests) {
      print("[AIActions] triggerAISubquestGeneration skipped, already in progress for task '${mainTaskForSubquests.name}'.");
      return;
    }
    _provider.setProviderAISubquestLoading(true);
    print("[AIActions] Starting triggerAISubquestGeneration for task '${mainTaskForSubquests.name}'. Mode: $generationMode, User Input: '$userInput', Num Subquests: $numSubquests");

    try {
      print("[AIActions] Attempting to call _aiService.generateAISubquests for task '${mainTaskForSubquests.name}'.");
      final generatedSubquestsRaw = await _aiService.generateAISubquests(
        mainTaskName: mainTaskForSubquests.name,
        mainTaskDescription: mainTaskForSubquests.description,
        mainTaskTheme: mainTaskForSubquests.theme,
        generationMode: generationMode,
        userInput: userInput,
        numSubquests: numSubquests,
        currentApiKeyIndex: _provider.apiKeyIndex,
        onNewApiKeyIndex: (newIndex) {
          print("[AIActions] API key index updated to $newIndex during subquest gen for task '${mainTaskForSubquests.name}'.");
          _provider.setProviderApiKeyIndex(newIndex);
        },
        onLog: (log) {
          print("[AI Service Log - Subquests - Task: ${mainTaskForSubquests.name}]: $log");
          _logToGame(log);
        },
      );

      print("[AIActions] _aiService.generateAISubquests returned for task '${mainTaskForSubquests.name}'. Raw data length: ${generatedSubquestsRaw.length}");
      if (kDebugMode && generatedSubquestsRaw.isNotEmpty) {
        print("[AIActions] Raw subquest data for task '${mainTaskForSubquests.name}': $generatedSubquestsRaw");
      }

      final List<SubTask> newSubTasksForParent = [];
      for (var subquestData in generatedSubquestsRaw) {
        if (kDebugMode) print("[AIActions] Processing raw subquest data: $subquestData");
        if (subquestData is! Map<String, dynamic>) {
          print("[AIActions] Skipping invalid raw subquest data (null or not a Map): $subquestData");
          continue;
        }

        final List<Map<String, dynamic>> subSubTasksDataList =
            (subquestData['subSubTasksData'] as List<dynamic>? ?? [])
                .map((item) {
                  if (item is Map<String, dynamic>) return item;
                  print("[AIActions] Invalid sub-sub-task data item, expected Map<String, dynamic>, got ${item.runtimeType}: $item");
                  return null; 
                })
                .whereNotNull()
                .toList();

        final List<SubSubTask> currentSubSubTasks = [];
        for (int i = 0; i < subSubTasksDataList.length; i++) {
          final sssData = subSubTasksDataList[i];
          if (kDebugMode) print("[AIActions] Processing raw sub-sub-task data: $sssData");
          try {
            currentSubSubTasks.add(SubSubTask(
              id: 'ssub_${DateTime.now().millisecondsSinceEpoch}_${newSubTasksForParent.length}_$i',
              name: sssData['name'] as String? ?? 'Unnamed Sub-Sub-Task',
              isCountable: sssData['isCountable'] as bool? ?? false,
              targetCount: (sssData['isCountable'] as bool? ?? false)
                  ? (sssData['targetCount'] as int? ?? 1)
                  : 0,
            ));
          } catch (e, s) {
            print("[AIActions] Error parsing SubSubTask from data: $sssData. Error: $e. Stacktrace: $s");
          }
        }

        try {
          final newSubTask = SubTask(
            id: 'sub_${DateTime.now().millisecondsSinceEpoch}_${newSubTasksForParent.length}',
            name: subquestData['name'] as String? ?? 'Unnamed Sub-Task',
            isCountable: subquestData['isCountable'] as bool? ?? false,
            targetCount: (subquestData['isCountable'] as bool? ?? false)
                ? (subquestData['targetCount'] as int? ?? 1)
                : 0,
            subSubTasks: currentSubSubTasks,
          );
          newSubTasksForParent.add(newSubTask);
          if (kDebugMode) print("[AIActions] Created SubTask: ${newSubTask.name} with ${currentSubSubTasks.length} sub-sub-tasks.");
        } catch (e, s) {
          print("[AIActions] Error parsing SubTask from data: $subquestData. Error: $e. Stacktrace: $s");
        }
      }

      if (newSubTasksForParent.isEmpty && generatedSubquestsRaw.isNotEmpty) {
        print("[AIActions] Warning: Raw subquests were received, but no valid SubTasks could be parsed for task '${mainTaskForSubquests.name}'.");
        _logToGame("<span style=\"color:var(--fh-accent-orange);\">AI returned sub-quest data for '${mainTaskForSubquests.name}', but it could not be fully processed.</span>");
      }

      final newMainTasks = _provider.mainTasks.map((task) {
        if (task.id == mainTaskForSubquests.id) {
          return MainTask(
            id: task.id,
            name: task.name,
            description: task.description,
            theme: task.theme,
            colorHex: task.colorHex,
            streak: task.streak,
            dailyTimeSpent: task.dailyTimeSpent,
            lastWorkedDate: task.lastWorkedDate,
            subTasks: [...task.subTasks, ...newSubTasksForParent],
          );
        }
        return task;
      }).toList();

      print("[AIActions] Generated ${newSubTasksForParent.length} new valid sub-quests for task '${mainTaskForSubquests.name}'.");

      _provider.setProviderState(
          mainTasks: newMainTasks,
          currentGame: CurrentGame(
            enemy: _provider.currentGame.enemy,
            playerCurrentHp: _provider.currentGame.playerCurrentHp,
            log: [
              ..._provider.currentGame.log,
              if (newSubTasksForParent.isNotEmpty)
                "<span style=\"color:${AppTheme.fhAccentGreen.value.toRadixString(16).substring(2)};\">AI successfully generated ${newSubTasksForParent.length} new sub-quests for '${mainTaskForSubquests.name}'.</span>"
              else if (generatedSubquestsRaw.isNotEmpty) 
                "<span style=\"color:var(--fh-accent-orange);\">AI sub-quest generation for '${mainTaskForSubquests.name}' returned data, but it could not be fully processed.</span>"
              else 
                "<span style=\"color:var(--fh-accent-orange);\">AI sub-quest generation for '${mainTaskForSubquests.name}' did not yield new quests.</span>"
            ],
            currentPlaceKey: _provider.currentGame.currentPlaceKey,
          ),
          doPersist: true, 
          doNotify: true);
      print("[AIActions] Subquest state update successful for task '${mainTaskForSubquests.name}', data persisted.");
    } catch (e, stackTrace) {
      final errorMessage = e.toString();
      print("[AIActions] CRITICAL ERROR in triggerAISubquestGeneration for task '${mainTaskForSubquests.name}': $errorMessage");
      if (kDebugMode) print("[AIActions] StackTrace for triggerAISubquestGeneration error: $stackTrace");
      _logToGame("<span style=\"color:${AppTheme.fhAccentRed.value.toRadixString(16).substring(2)};\">AI sub-quest generation for '${mainTaskForSubquests.name}' failed critically: $errorMessage</span>");
    } finally {
      _provider.setProviderAISubquestLoading(false);
      print("[AIActions] Finished triggerAISubquestGeneration for task '${mainTaskForSubquests.name}'.");
    }
  }
}
--- END OF FILE lib/src/providers/actions/ai_generation_actions.dart ---

--- START OF FILE lib/src/providers/actions/combat_actions.dart ---
// lib/src/providers/actions/combat_actions.dart
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/utils/constants.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/theme/app_theme.dart'; // For colors in log
import 'dart:math';
import 'package:collection/collection.dart'; // For firstWhereOrNull

class CombatActions {
  final GameProvider _provider;

  CombatActions(this._provider);

  void startGame(String enemyId) {
    final enemyTemplate =
        _provider.enemyTemplatesList.firstWhereOrNull((e) => e.id == enemyId);
    if (enemyTemplate == null) return;

    final newGame = CurrentGame(
      enemy: EnemyTemplate(
          // Create a mutable copy for combat
          id: enemyTemplate.id,
          name: enemyTemplate.name,
          theme: enemyTemplate.theme,
          locationKey: enemyTemplate.locationKey,
          minPlayerLevel: enemyTemplate.minPlayerLevel,
          health: enemyTemplate.health,
          attack: enemyTemplate.attack,
          defense: enemyTemplate.defense,
          coinReward: enemyTemplate.coinReward,
          xpReward: enemyTemplate.xpReward,
          description: enemyTemplate.description,
          hp: enemyTemplate.health // Start with full HP
          ),
      playerCurrentHp: _provider.playerGameStats['vitality']!.value,
      log: [
        "<span style=\"font-weight:bold;\">You encounter ${enemyTemplate.name}!</span> ${enemyTemplate.description}"
      ],
      currentPlaceKey: _provider.currentGame.currentPlaceKey,
    );

    _provider.setProviderState(currentGame: newGame);
  }

  void handleFight() {
    if (_provider.currentGame.enemy == null ||
        _provider.playerEnergy < energyPerAttack) {
      if (_provider.playerEnergy < energyPerAttack &&
          _provider.currentGame.enemy != null) {
        _provider.setProviderState(
            currentGame: CurrentGame(
          enemy: _provider.currentGame.enemy,
          playerCurrentHp: _provider.currentGame.playerCurrentHp,
          log: [
            ..._provider.currentGame.log,
            "<span style=\"color:${AppTheme.fhAccentRed.value.toRadixString(16).substring(2)};\">Not enough energy!</span>"
          ],
          currentPlaceKey: _provider.currentGame.currentPlaceKey,
        ));
      }
      return;
    }

    final currentEnemy =
        _provider.currentGame.enemy!; // This is already a mutable copy
    final playerStats = _provider.playerGameStats;
    final currentLog = List<String>.from(_provider.currentGame.log);

    int playerDamage = max(
        1,
        (playerStats['strength']!.value +
                (playerStats['runic']!.value / 2).floor() -
                currentEnemy.defense)
            .toInt());
    currentEnemy.hp =
        max(0, currentEnemy.hp - playerDamage); // Mutate the current enemy's HP

    currentLog.add(
        "You hit ${currentEnemy.name} for $playerDamage damage. (${currentEnemy.name} HP: ${currentEnemy.hp})");

    final Map<String, dynamic> updatesToPersist = {
      'playerEnergy': _provider.playerEnergy - energyPerAttack,
    };

    EnemyTemplate? nextEnemyState = currentEnemy;
    String? originalLocationKey = currentEnemy.locationKey;

    if (currentEnemy.hp <= 0) {
      currentLog.add("${currentEnemy.name} defeated!");
      final double luckBonus = 1 + (playerStats['luck']!.value / 100);
      final double xpBonusFromArtifact = playerStats['bonusXPMod']?.value ?? 0;
      final double totalXPMultiplier = luckBonus * (1 + xpBonusFromArtifact);
      final int coinReward = (currentEnemy.coinReward * luckBonus).floor();
      final int xpRewardVal =
          (currentEnemy.xpReward * totalXPMultiplier).floor();
      currentLog.add("You gain $coinReward Ø and $xpRewardVal XP.");

      updatesToPersist['coins'] = _provider.coins + coinReward;
      updatesToPersist['xp'] = _provider.xp + xpRewardVal;
      updatesToPersist['defeatedEnemyIds'] = [
        ...Set<String>.from(_provider.defeatedEnemyIds)..add(currentEnemy.id)
      ].toList();
      nextEnemyState = null;
    } else {
      int enemyDamage =
          max(1, (currentEnemy.attack - playerStats['defense']!.value).toInt());
      updatesToPersist['playerCurrentHp'] =
          max(0.0, _provider.currentGame.playerCurrentHp - enemyDamage);
      currentLog.add(
          "${currentEnemy.name} hits you for $enemyDamage damage. (Your HP: ${updatesToPersist['playerCurrentHp']})");
      if (updatesToPersist['playerCurrentHp'] <= 0) {
        currentLog.add("You have been defeated! Retreat to recover.");
        nextEnemyState = null;
      }
    }

    updatesToPersist['currentGame'] = CurrentGame(
      enemy: nextEnemyState,
      playerCurrentHp: updatesToPersist['playerCurrentHp'] as double? ??
          _provider.currentGame.playerCurrentHp,
      log: currentLog,
      currentPlaceKey: _provider.currentGame.currentPlaceKey,
    );
    if (!updatesToPersist.containsKey('playerCurrentHp')) {
      (updatesToPersist['currentGame'] as CurrentGame).playerCurrentHp =
          _provider.currentGame.playerCurrentHp;
    }

    _provider.setProviderState(
        playerEnergy: updatesToPersist['playerEnergy'] as double?,
        coins: updatesToPersist['coins'] as double?,
        xp: updatesToPersist['xp'] as double?,
        defeatedEnemyIds: updatesToPersist['defeatedEnemyIds'] as List<String>?,
        currentGame: updatesToPersist['currentGame'] as CurrentGame,
        doPersist: false);

    if (nextEnemyState == null &&
        currentEnemy.hp <= 0 &&
        originalLocationKey != null) {
      checkAndClearLocationIfAllEnemiesDefeated(originalLocationKey);
    }
  }

  void usePowerUp(String uniqueId) {
    final powerUpInstance =
        _provider.artifacts.firstWhereOrNull((a) => a.uniqueId == uniqueId);
    final template = powerUpInstance != null
        ? _provider.artifactTemplatesList
            .firstWhereOrNull((t) => t.id == powerUpInstance.templateId)
        : null;

    if (template == null ||
        powerUpInstance == null ||
        template.type != 'powerup' ||
        (powerUpInstance.uses != null && powerUpInstance.uses! <= 0) ||
        _provider.currentGame.enemy == null) {
      if (_provider.currentGame.enemy == null && template != null) {
        // Added template null check
        _provider.setProviderState(
            currentGame: CurrentGame(
          enemy: _provider.currentGame.enemy,
          playerCurrentHp: _provider.currentGame.playerCurrentHp,
          log: [
            ..._provider.currentGame.log,
            "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)};\">Can only use power-ups in combat!</span>"
          ],
          currentPlaceKey: _provider.currentGame.currentPlaceKey,
        ));
      }
      return;
    }

    final currentEnemy =
        _provider.currentGame.enemy!; // This is a mutable copy from startGame
    final playerStats = _provider.playerGameStats;
    final currentLog = List<String>.from(_provider.currentGame.log);
    final Map<String, dynamic> updatesToPersist = {};

    double playerHpAfterPowerUp = _provider.currentGame.playerCurrentHp;
    EnemyTemplate? nextEnemyState = currentEnemy;
    String? originalLocationKey = currentEnemy.locationKey;

    if (template.effectType == 'direct_damage') {
      final int damage = max(
          1, (template.effectValue ?? 0) - (currentEnemy.defense / 2).floor());
      currentEnemy.hp =
          max(0, currentEnemy.hp - damage); // Mutate current enemy
      currentLog.add(
          "<span style=\"color:${AppTheme.fhAccentPurple.value.toRadixString(16).substring(2)};\">You used ${template.name}!</span> It hits ${currentEnemy.name} for $damage damage. (${currentEnemy.name} HP: ${currentEnemy.hp})");
    } else if (template.effectType == 'heal_player') {
      playerHpAfterPowerUp = min(playerStats['vitality']!.value,
          _provider.currentGame.playerCurrentHp + (template.effectValue ?? 0));
      updatesToPersist['playerCurrentHp'] = playerHpAfterPowerUp;
      currentLog.add(
          "<span style=\"color:${AppTheme.fhAccentPurple.value.toRadixString(16).substring(2)};\">You used ${template.name}!</span> You healed for ${template.effectValue} HP. (Your HP: $playerHpAfterPowerUp)");
    }

    updatesToPersist['artifacts'] = _provider.artifacts
        .map((art) {
          if (art.uniqueId == uniqueId) {
            return OwnedArtifact(
                uniqueId: art.uniqueId,
                templateId: art.templateId,
                currentLevel: art.currentLevel,
                uses: (art.uses ?? 1) - 1);
          }
          return art;
        })
        .where((art) => art.uses == null || art.uses! > 0)
        .toList();

    if (currentEnemy.hp <= 0) {
      currentLog.add("${currentEnemy.name} defeated by the power-up!");
      final double luckBonus = 1 + (playerStats['luck']!.value / 100);
      final double xpBonusFromArtifact = playerStats['bonusXPMod']?.value ?? 0;
      final double totalXPMultiplier = luckBonus * (1 + xpBonusFromArtifact);
      final int coinReward = (currentEnemy.coinReward * luckBonus).floor();
      final int xpRewardVal =
          (currentEnemy.xpReward * totalXPMultiplier).floor();
      currentLog.add("You gain $coinReward Ø and $xpRewardVal XP.");
      updatesToPersist['coins'] = _provider.coins + coinReward;
      updatesToPersist['xp'] = _provider.xp + xpRewardVal;
      updatesToPersist['defeatedEnemyIds'] = [
        ...Set<String>.from(_provider.defeatedEnemyIds)..add(currentEnemy.id)
      ].toList();
      nextEnemyState = null;
    }

    updatesToPersist['currentGame'] = CurrentGame(
      enemy: nextEnemyState,
      playerCurrentHp: updatesToPersist['playerCurrentHp'] as double? ??
          _provider.currentGame.playerCurrentHp,
      log: currentLog,
      currentPlaceKey: _provider.currentGame.currentPlaceKey,
    );
    if (!updatesToPersist.containsKey('playerCurrentHp')) {
      (updatesToPersist['currentGame'] as CurrentGame).playerCurrentHp =
          _provider.currentGame.playerCurrentHp;
    }

    _provider.setProviderState(
        artifacts: updatesToPersist['artifacts'] as List<OwnedArtifact>?,
        coins: updatesToPersist['coins'] as double?,
        xp: updatesToPersist['xp'] as double?,
        defeatedEnemyIds: updatesToPersist['defeatedEnemyIds'] as List<String>?,
        currentGame: updatesToPersist['currentGame'] as CurrentGame,
        doPersist: false);

    if (nextEnemyState == null &&
        currentEnemy.hp <= 0 &&
        originalLocationKey != null) {
      checkAndClearLocationIfAllEnemiesDefeated(originalLocationKey);
    }
  }

  void forfeitMatch() {
    if (_provider.currentGame.enemy == null) return;
    final int coinsLost = (_provider.coins * 0.10).floor();
    final double maxHp = _provider.playerGameStats['vitality']!.value;

    _provider.setProviderState(
        coins: _provider.coins - coinsLost,
        playerEnergy: 0,
        currentGame: CurrentGame(
          playerCurrentHp: maxHp,
          enemy: null,
          log: [
            ..._provider.currentGame.log,
            "<span style=\"color:${AppTheme.fhAccentRed.value.toRadixString(16).substring(2)};\">You forfeited the match!</span> Lost $coinsLost Ø and all energy."
          ],
          currentPlaceKey: _provider.currentGame.currentPlaceKey,
        ));
  }

  void checkAndClearLocationIfAllEnemiesDefeated(String locationId) {
    final location = _provider.gameLocationsList
        .firstWhereOrNull((loc) => loc.id == locationId);
    if (location == null ||
        _provider.clearedLocationIds.contains(locationId)) {
      return; // Location not found or already cleared
    }

    // Find all enemies that *belong* to this location
    final enemiesInLocation = _provider.enemyTemplatesList
        .where((enemy) => enemy.locationKey == locationId)
        .toList();

    if (enemiesInLocation.isEmpty) {
      // No enemies defined for this location, cannot be "cleared" by defeating enemies
      // Or, if it's a non-combat zone, this logic might not apply.
      // For now, if no enemies are tied to it, we don't auto-clear it this way.
      return;
    }

    // Check if all enemies *belonging to this location* are in the defeated list
    final allDefeated = enemiesInLocation
        .every((enemy) => _provider.defeatedEnemyIds.contains(enemy.id));

    if (allDefeated) {
      _provider.markLocationAsCleared(locationId);
    }
  }
}

--- END OF FILE lib/src/providers/actions/combat_actions.dart ---

--- START OF FILE lib/src/providers/actions/item_actions.dart ---
// lib/src/providers/actions/item_actions.dart
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/utils/constants.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/theme/app_theme.dart'; // For colors in log
import 'package:arcane/src/utils/helpers.dart' as helper;
import 'package:collection/collection.dart'; // For firstWhereOrNull

class ItemActions {
  final GameProvider _provider;

  ItemActions(this._provider);

  OwnedArtifact? getArtifactByUniqueId(String uniqueId) {
    return _provider.artifacts
        .firstWhereOrNull((art) => art.uniqueId == uniqueId);
  }

  ArtifactTemplate? getArtifactTemplateById(String templateId) {
    return _provider.artifactTemplatesList
        .firstWhereOrNull((tmpl) => tmpl.id == templateId);
  }

  ArtifactTemplate getArtifactEffectiveStats(OwnedArtifact ownedArtifact) {
    final template = _provider.artifactTemplatesList
        .firstWhereOrNull((t) => t.id == ownedArtifact.templateId);
    if (template == null) {
      return ArtifactTemplate(
          id: '',
          name: 'Unknown Artifact',
          type: '',
          description: '',
          cost: 0,
          icon: '❓');
    }

    final level = ownedArtifact.currentLevel;

    int currentAtt = template.baseAtt ?? 0;
    int currentRunic = template.baseRunic ?? 0;
    int currentDef = template.baseDef ?? 0;
    int currentHealth = template.baseHealth ?? 0;
    int currentLuck = template.baseLuck ?? 0;
    int currentCooldown = template.baseCooldown ?? 0;
    double currentBonusXPMod = template.bonusXPMod ?? 0.0;

    if (template.type != 'powerup' &&
        level > 1 &&
        template.upgradeBonus != null) {
      template.upgradeBonus!.forEach((key, bonusPerLevel) {
        final totalBonusForStat =
            bonusPerLevel * (level - 1); // Generic for integer bonuses
        final doubleTotalBonusForStat = bonusPerLevel.toDouble() *
            (level - 1); // Generic for double bonuses

        switch (key) {
          case 'att':
            currentAtt += totalBonusForStat;
            break;
          case 'runic':
            currentRunic += totalBonusForStat;
            break;
          case 'def':
            currentDef += totalBonusForStat;
            break;
          case 'health':
            currentHealth += totalBonusForStat;
            break;
          case 'luck':
            currentLuck += totalBonusForStat;
            break;
          case 'cooldown':
            currentCooldown += totalBonusForStat;
            break;
          // If bonusPerLevel for bonusXPMod is already a decimal (e.g., 0.01 for 1%),
          // then direct multiplication is correct.
          case 'bonusXPMod':
            currentBonusXPMod += doubleTotalBonusForStat;
            break;
        }
      });
    }

    return ArtifactTemplate(
      id: template.id,
      name: template.name,
      type: template.type,
      theme: template.theme,
      description: template.description,
      cost: template.cost,
      icon: template.icon,
      baseAtt: currentAtt,
      baseRunic: currentRunic,
      baseDef: currentDef,
      baseHealth: currentHealth,
      baseLuck: currentLuck,
      baseCooldown: currentCooldown,
      bonusXPMod: currentBonusXPMod,
      upgradeBonus: template.upgradeBonus,
      maxLevel: template.maxLevel,
      effectType: template.effectType,
      effectValue: template.effectValue,
      uses: template.type == 'powerup' ? ownedArtifact.uses : template.uses,
    );
  }

  void buyArtifact(String templateId) {
    final template = _provider.artifactTemplatesList
        .firstWhereOrNull((t) => t.id == templateId);
    if (template == null || _provider.coins < template.cost) return;

    final newArtifactInstance = OwnedArtifact(
      uniqueId:
          'artuid_${DateTime.now().millisecondsSinceEpoch}_${template.id.hashCode}',
      templateId: template.id,
      currentLevel: 1,
      uses: template.type == 'powerup' ? template.uses ?? 1 : null,
    );
    _provider.setProviderState(
      coins: _provider.coins - template.cost,
      artifacts: [..._provider.artifacts, newArtifactInstance],
    );
  }

  bool upgradeArtifact(String uniqueId) {
    final ownedArtifact =
        _provider.artifacts.firstWhereOrNull((a) => a.uniqueId == uniqueId);
    final template = ownedArtifact != null
        ? _provider.artifactTemplatesList
            .firstWhereOrNull((t) => t.id == ownedArtifact.templateId)
        : null;

    if (template == null ||
        ownedArtifact == null ||
        template.type == 'powerup' ||
        ownedArtifact.currentLevel >= (template.maxLevel ?? 1)) {
      return false;
    }

    final upgradeCost = (template.cost *
            blacksmithUpgradeCostMultiplier *
            (helper.xpLevelMultiplierPow(1.2, ownedArtifact.currentLevel - 1)))
        .floor();
    if (_provider.coins < upgradeCost) return false;

    final newArtifacts = _provider.artifacts.map((art) {
      if (art.uniqueId == uniqueId) {
        return OwnedArtifact(
            uniqueId: art.uniqueId,
            templateId: art.templateId,
            currentLevel: art.currentLevel + 1,
            uses: art.uses);
      }
      return art;
    }).toList();
    _provider.setProviderState(
        coins: _provider.coins - upgradeCost, artifacts: newArtifacts);
    return true;
  }

  bool sellArtifact(String uniqueId) {
    final artifactToSell =
        _provider.artifacts.firstWhereOrNull((a) => a.uniqueId == uniqueId);
    final template = artifactToSell != null
        ? _provider.artifactTemplatesList
            .firstWhereOrNull((t) => t.id == artifactToSell.templateId)
        : null;
    if (template == null || artifactToSell == null) return false;

    double sellMultiplier = 1.0;
    if (template.type == 'powerup' &&
        template.uses != null &&
        template.uses! > 0 &&
        artifactToSell.uses != null) {
      sellMultiplier = (artifactToSell.uses! / template.uses!);
    }
    final int sellPrice =
        (template.cost * artifactSellPercentage * sellMultiplier).floor();

    final newArtifacts =
        _provider.artifacts.where((art) => art.uniqueId != uniqueId).toList();
    Map<String, String?> newEquippedItems = Map.from(_provider.equippedItems);
    bool unequipped = false;
    newEquippedItems.forEach((slot, itemId) {
      if (itemId == uniqueId) {
        newEquippedItems[slot] = null;
        unequipped = true;
      }
    });

    final newLog = List<String>.from(_provider.currentGame.log)
      ..add(
          "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">${template.name} sold for $sellPrice Ø.</span>");

    _provider.setProviderState(
        coins: _provider.coins + sellPrice,
        artifacts: newArtifacts,
        equippedItems: unequipped ? newEquippedItems : _provider.equippedItems,
        currentGame: CurrentGame(
          enemy: _provider.currentGame.enemy,
          playerCurrentHp: _provider.currentGame.playerCurrentHp,
          log: newLog,
        ));
    return true;
  }

  void equipArtifact(String uniqueId) {
    final ownedArtifact =
        _provider.artifacts.firstWhereOrNull((a) => a.uniqueId == uniqueId);
    final template = ownedArtifact != null
        ? _provider.artifactTemplatesList
            .firstWhereOrNull((t) => t.id == ownedArtifact.templateId)
        : null;
    if (template == null || ownedArtifact == null || template.type == 'powerup') {
      return;
    }

    final newEquippedItems = Map<String, String?>.from(_provider.equippedItems);
    newEquippedItems[template.type] = uniqueId;
    _provider.setProviderState(equippedItems: newEquippedItems);
  }

  void unequipArtifact(String slot) {
    final newEquippedItems = Map<String, String?>.from(_provider.equippedItems);
    newEquippedItems[slot] = null;
    _provider.setProviderState(equippedItems: newEquippedItems);
  }
}

--- END OF FILE lib/src/providers/actions/item_actions.dart ---

--- START OF FILE lib/src/providers/actions/park_actions.dart ---
// lib/src/providers/actions/park_actions.dart
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:arcane/src/utils/constants.dart';
import 'package:collection/collection.dart'; // For firstWhereOrNull
import 'dart:math'; // For Random

class ParkActions {
  final GameProvider _provider;
  final Random _random = Random();


  ParkActions(this._provider);

  void _logToPark(String message, {bool isError = false}) {
    final color = isError ? AppTheme.fhAccentRed : AppTheme.fhAccentGreen;
    final logMessage = "<span style=\"color:${color.value.toRadixString(16).substring(2)};\">[Park] $message</span>";
    print("[ParkActions Log] $message");
    _provider.setProviderState(
        currentGame: CurrentGame(
            enemy: _provider.currentGame.enemy,
            playerCurrentHp: _provider.currentGame.playerCurrentHp,
            log: [..._provider.currentGame.log, logMessage],
            currentPlaceKey: _provider.currentGame.currentPlaceKey),
        doPersist: false,
        doNotify: true
    );
  }

  bool canAffordBuilding(BuildingTemplate buildingTemplate) {
    return _provider.parkManager.parkDollars >= buildingTemplate.costDollars;
  }

  void buyAndPlaceBuilding(String buildingTemplateId) {
    final template = _provider.buildingTemplatesList.firstWhereOrNull((t) => t.id == buildingTemplateId);
    if (template == null) {
      _logToPark("Error: Building blueprint not found.", isError: true);
      return;
    }

    if (!canAffordBuilding(template)) {
      _logToPark("Cannot afford ${template.name}. Cost: \$${template.costDollars}.", isError: true);
      return;
    }

    bool canBeOperationalInitially = true;
    if ((template.powerRequired ?? 0) > 0 && template.type != "power_plant") {
        final totalPowerGenerated = _provider.parkManager.currentPowerGenerated;
        final totalPowerConsumedByOthers = _provider.parkManager.currentPowerConsumed;

        if (totalPowerGenerated < totalPowerConsumedByOthers + (template.powerRequired ?? 0)) {
            canBeOperationalInitially = false;
            _logToPark("${template.name} constructed but offline due to insufficient power.", isError: true);
        }
    }


    final newBuilding = OwnedBuilding(
      uniqueId: 'ob_${DateTime.now().millisecondsSinceEpoch}_${template.id.hashCode}',
      templateId: template.id,
      currentFoodLevel: template.type == "food_station" ? enclosureBaseFoodCapacity : null,
      isOperational: template.type == "power_plant" ? true : canBeOperationalInitially,
    );

    final List<OwnedBuilding> updatedOwnedBuildings = [..._provider.ownedBuildings, newBuilding];
    final double newParkDollars = _provider.parkManager.parkDollars - template.costDollars;

    _provider.setProviderState(
      parkManager: _provider.parkManager..parkDollars = newParkDollars,
      ownedBuildings: updatedOwnedBuildings,
      doPersist: true,
      doNotify: true,
    );

    _logToPark("Constructed ${template.name}!");
    _recalculateParkStats(); // This will also update power status
  }

  void sellBuilding(String ownedBuildingUniqueId) {
    final ownedBuilding = _provider.ownedBuildings.firstWhereOrNull((b) => b.uniqueId == ownedBuildingUniqueId);
    if (ownedBuilding == null) {
        _logToPark("Error: Building not found in park.", isError: true);
        return;
    }
    final template = _provider.buildingTemplatesList.firstWhereOrNull((t) => t.id == ownedBuilding.templateId);
    if (template == null) {
        _logToPark("Error: Building blueprint corrupted for owned building.", isError: true);
        return;
    }

    final double sellPercentage = 0.5;
    final int sellPrice = (template.costDollars * sellPercentage).floor();

    List<OwnedBuilding> updatedOwnedBuildings = _provider.ownedBuildings.where((b) => b.uniqueId != ownedBuildingUniqueId).toList();
    final double newParkDollars = _provider.parkManager.parkDollars + sellPrice;
    List<OwnedDinosaur> updatedOwnedDinosaurs = List.from(_provider.ownedDinosaurs);

    if (template.type == "enclosure" && ownedBuilding.dinosaurUniqueIds.isNotEmpty) {
        updatedOwnedDinosaurs = _provider.ownedDinosaurs
            .where((dino) => !ownedBuilding.dinosaurUniqueIds.contains(dino.uniqueId))
            .toList();
        _logToPark("Dinosaurs from demolished ${template.name} have been released to the wild (removed from park).", isError: true);
    }

    _provider.setProviderState(
      parkManager: _provider.parkManager..parkDollars = newParkDollars,
      ownedBuildings: updatedOwnedBuildings,
      ownedDinosaurs: template.type == "enclosure" ? updatedOwnedDinosaurs : null, // Only update if it was an enclosure
      doPersist: true,
      doNotify: true,
    );
    _logToPark("Demolished ${template.name}. Recovered \$$sellPrice.");
    _recalculateParkStats();
  }

  void excavateFossil(String speciesId) {
    final species = _provider.dinosaurSpeciesList.firstWhereOrNull((s) => s.id == speciesId);
    if (species == null) {
        _logToPark("Species $speciesId not found for excavation.", isError: true);
        return;
    }
     final bool fossilCenterOperational = _provider.ownedBuildings.any((b) {
        final template = _provider.buildingTemplatesList.firstWhereOrNull((t) => t.id == b.templateId);
        return template?.type == "fossil_center" && b.isOperational;
    });
    if (!fossilCenterOperational) {
        _logToPark("Fossil Center is not operational. Cannot excavate.", isError: true);
        return;
    }

    if (_provider.playerEnergy < species.fossilExcavationEnergyCost) { // Use player energy
      _logToPark("Not enough player energy to excavate. Cost: ${species.fossilExcavationEnergyCost}⚡", isError: true);
      return;
    }
     if (_provider.playerLevel < species.minPlayerLevelToUnlock) {
      _logToPark("Player level too low to excavate ${species.name}. Requires level ${species.minPlayerLevelToUnlock}.", isError: true);
      return;
    }


    final recordIndex = _provider.fossilRecords.indexWhere((fr) => fr.speciesId == speciesId);
    if (recordIndex == -1) {
      _logToPark("Fossil record for species $speciesId not found.", isError: true);
      return;
    }
    final record = _provider.fossilRecords[recordIndex];
    if (record.isGenomeComplete) {
      _logToPark("Genome for ${record.speciesId} is already complete.", isError: false);
      return;
    }

    final double progressIncrease = 10.0 + _random.nextDouble() * 15.0; // 10-25% progress
    record.excavationProgress = (record.excavationProgress + progressIncrease).clamp(0.0, 100.0);
    if (record.excavationProgress >= 100.0) {
      record.isGenomeComplete = true;
      _logToPark("Genome for ${record.speciesId} is now 100% complete and ready for incubation!");
    } else {
      _logToPark("Fossil excavation for ${record.speciesId} progressed to ${record.excavationProgress.toStringAsFixed(1)}%.");
    }
    
    final List<FossilRecord> updatedRecords = List.from(_provider.fossilRecords);
    updatedRecords[recordIndex] = record;

    _provider.setProviderState(
      fossilRecords: updatedRecords,
      playerEnergy: _provider.playerEnergy - species.fossilExcavationEnergyCost, // Deduct player energy
      doPersist: true,
      doNotify: true
    );
  }

  void incubateDinosaur(String speciesId) {
    final species = _provider.dinosaurSpeciesList.firstWhereOrNull((s) => s.id == speciesId);
    if (species == null) {
      _logToPark("Species $speciesId not found for incubation.", isError: true);
      return;
    }
    if (_provider.playerLevel < species.minPlayerLevelToUnlock) {
        _logToPark("Player level too low to incubate ${species.name}. Requires level ${species.minPlayerLevelToUnlock}.", isError: true);
        return;
    }
    final fossilRecord = _provider.fossilRecords.firstWhereOrNull((fr) => fr.speciesId == speciesId);
    if (fossilRecord == null || !fossilRecord.isGenomeComplete) {
      _logToPark("Genome for ${species.name} is not complete. Excavate more fossils.", isError: true);
      return;
    }
    if (_provider.parkManager.parkDollars < species.incubationCostDollars) {
      _logToPark("Not enough park funds to incubate ${species.name}. Cost: \$${species.incubationCostDollars}.", isError: true);
      return;
    }
    if (_provider.playerEnergy < incubationEnergyCost) { // Use player energy
       _logToPark("Not enough player energy to incubate ${species.name}. Cost: $incubationEnergyCost⚡.", isError: true);
      return;
    }

    // Check if a hatchery is available and has capacity
    final operationalHatcheries = _provider.ownedBuildings.where((b) {
        final template = _provider.buildingTemplatesList.firstWhereOrNull((t) => t.id == b.templateId);
        return template?.type == "hatchery" && b.isOperational;
    }).toList();

    if (operationalHatcheries.isEmpty) {
        _logToPark("No operational hatchery available to incubate dinosaurs.", isError: true);
        return;
    }
    
    int totalHatcheryCapacity = operationalHatcheries.fold(0, (sum, hatchery) {
        final template = _provider.buildingTemplatesList.firstWhereOrNull((t) => t.id == hatchery.templateId);
        return sum + (template?.capacity ?? 0);
    });
    
    final incubatingDinosCount = _provider.ownedDinosaurs.where((d) => d.name.contains("(Incubating)")).length;
    if (incubatingDinosCount >= totalHatcheryCapacity) {
         _logToPark("All hatcheries are at full capacity. Wait for current incubations to finish.", isError: true);
        return;
    }


    final newDinosaur = OwnedDinosaur(
      uniqueId: 'dino_${DateTime.now().millisecondsSinceEpoch}_${species.id.hashCode}',
      speciesId: species.id,
      name: "${species.name} (Incubating)", // Indicate status
      age: 0, // Represents incubation progress
    );

    _provider.setProviderState(
      parkManager: _provider.parkManager..parkDollars -= species.incubationCostDollars,
      playerEnergy: _provider.playerEnergy - incubationEnergyCost, // Deduct player energy
      ownedDinosaurs: [..._provider.ownedDinosaurs, newDinosaur],
      doPersist: true,
      doNotify: true
    );
    _logToPark("Incubation started for a ${species.name}!");
  }

  void addDinosaurToEnclosure(String dinosaurUniqueId, String enclosureUniqueId) {
    final dinosaur = _provider.ownedDinosaurs.firstWhereOrNull((d) => d.uniqueId == dinosaurUniqueId);
    final enclosure = _provider.ownedBuildings.firstWhereOrNull((b) => b.uniqueId == enclosureUniqueId);
    final enclosureTemplate = enclosure != null ? _provider.buildingTemplatesList.firstWhereOrNull((t) => t.id == enclosure.templateId) : null;

    if (dinosaur == null || enclosure == null || enclosureTemplate == null || enclosureTemplate.type != "enclosure") {
      _logToPark("Invalid dinosaur or enclosure for transfer.", isError: true);
      return;
    }
    if (!enclosure.isOperational) {
        _logToPark("${enclosureTemplate.name} is not operational. Cannot add dinosaurs.", isError: true);
        return;
    }
    if (enclosure.dinosaurUniqueIds.length >= (enclosureTemplate.capacity ?? 999)) {
        _logToPark("${enclosureTemplate.name} is at full capacity.", isError: true);
        return;
    }
    if(dinosaur.name.contains("(Incubating)")) {
        _logToPark("${dinosaur.name} is still incubating and cannot be moved.", isError: true);
        return;
    }


    final List<OwnedBuilding> updatedBuildings = _provider.ownedBuildings.map((b) {
      if (b.uniqueId == enclosureUniqueId) {
        return OwnedBuilding(
          uniqueId: b.uniqueId,
          templateId: b.templateId,
          dinosaurUniqueIds: [...b.dinosaurUniqueIds, dinosaurUniqueId],
          currentFoodLevel: b.currentFoodLevel,
          isOperational: b.isOperational,
        );
      }
      return b;
    }).toList();

    _provider.setProviderState(
      ownedBuildings: updatedBuildings,
      doPersist: true,
      doNotify: true
    );
    _logToPark("${dinosaur.name} moved to ${enclosureTemplate.name}.");
    _recalculateParkStats();
  }

  void feedDinosaursInEnclosure(String enclosureUniqueId, int amount) {
    final enclosure = _provider.ownedBuildings.firstWhereOrNull((b) => b.uniqueId == enclosureUniqueId);
     if (enclosure == null) {
        _logToPark("Enclosure not found for feeding.", isError: true);
        return;
    }
    // Find an associated food station. Simplified: assumes one generic food station for the park or per enclosure.
    // For more complex scenarios, link food stations to enclosures.
    final foodStationIndex = _provider.ownedBuildings.indexWhere((b) {
        final template = _provider.buildingTemplatesList.firstWhereOrNull((t) => t.id == b.templateId);
        // Assuming food stations are generic for now and not tied to specific enclosures in data model
        // If they were, would add: && b.linkedEnclosureId == enclosureUniqueId
        return template?.type == "food_station" && b.isOperational; 
    });

    if (foodStationIndex == -1) {
        _logToPark("No operational food station found.", isError: true); // Generic message if not linked
        return;
    }
    if (_provider.playerEnergy < feedDinoEnergyCost) { // Check player energy
        _logToPark("Not enough player energy to refill feeder. Cost: $feedDinoEnergyCost⚡", isError: true);
        return;
    }
    
    final List<OwnedBuilding> updatedBuildings = List.from(_provider.ownedBuildings);
    final foodStation = updatedBuildings[foodStationIndex];
    final newFoodLevel = (foodStation.currentFoodLevel ?? 0) + amount;
    updatedBuildings[foodStationIndex] = OwnedBuilding(
        uniqueId: foodStation.uniqueId,
        templateId: foodStation.templateId,
        dinosaurUniqueIds: foodStation.dinosaurUniqueIds,
        currentFoodLevel: newFoodLevel.clamp(0, enclosureBaseFoodCapacity),
        isOperational: foodStation.isOperational
    );

    _provider.setProviderState(
        ownedBuildings: updatedBuildings,
        playerEnergy: _provider.playerEnergy - feedDinoEnergyCost, // Deduct player energy
        doPersist: true,
        doNotify: true
    );
    _logToPark("Refilled food by $amount. New level: ${updatedBuildings[foodStationIndex].currentFoodLevel}.");
  }

  void toggleBuildingOperationalStatus(String ownedBuildingUniqueId) {
    final ownedBuilding = _provider.ownedBuildings.firstWhereOrNull((b) => b.uniqueId == ownedBuildingUniqueId);
    if (ownedBuilding == null) return;
    final template = _provider.buildingTemplatesList.firstWhereOrNull((t) => t.id == ownedBuilding.templateId);
    if (template == null) return;

    bool currentStatus = ownedBuilding.isOperational;
    bool newStatus = !currentStatus;
    List<OwnedBuilding> tempUpdatedBuildings = List.from(_provider.ownedBuildings);
    int buildingIndex = tempUpdatedBuildings.indexWhere((b) => b.uniqueId == ownedBuildingUniqueId);

    if (newStatus) { // Attempting to turn ON
        if ((template.powerRequired ?? 0) > 0) { // Only check for consumers
            int totalPowerGenerated = _provider.parkManager.currentPowerGenerated;
            
            if (template.type == "power_plant") {
                // This case is fine, power plants don't consume to turn on
            } else { // Consumer building
                int currentTotalPowerConsumedByOthers = _provider.parkManager.currentPowerConsumed;
               
                if (totalPowerGenerated < currentTotalPowerConsumedByOthers + (template.powerRequired ?? 0)) {
                    _logToPark("Cannot turn on ${template.name}. Insufficient power. Available: $totalPowerGenerated, Required (incl. this): ${currentTotalPowerConsumedByOthers + (template.powerRequired ?? 0)}", isError: true);
                    return; // Don't change status
                }
            }
        }
    }
    
    // If we reach here, the toggle is permissible
    tempUpdatedBuildings[buildingIndex] = OwnedBuilding(
        uniqueId: ownedBuilding.uniqueId,
        templateId: ownedBuilding.templateId,
        dinosaurUniqueIds: ownedBuilding.dinosaurUniqueIds,
        currentFoodLevel: ownedBuilding.currentFoodLevel,
        isOperational: newStatus,
    );
    
    _provider.setProviderState(
      ownedBuildings: tempUpdatedBuildings,
      doPersist: false, // Recalculate will persist
      doNotify: true,
    );
    
    _logToPark("${template.name} is now ${newStatus ? 'operational' : 'offline'}.", isError: !newStatus);
    _recalculateParkStats(); // This will update power grid and persist
  }


  void _updateBuildingOperationalStatusBasedOnPower() {
    int totalPowerGenerated = 0;
    int totalPowerRequiredByOperationalConsumers = 0;
    List<OwnedBuilding> currentBuildings = List.from(_provider.ownedBuildings); 

    for (var building in currentBuildings) {
        final template = _provider.buildingTemplatesList.firstWhereOrNull((t) => t.id == building.templateId);
        if (template == null) continue;

        if (template.type == "power_plant" && building.isOperational) {
            totalPowerGenerated += template.powerOutput ?? 0;
        } else if (template.type != "power_plant" && building.isOperational) {
            totalPowerRequiredByOperationalConsumers += template.powerRequired ?? 0;
        }
    }
    
    bool changesMadeToOperationalStatus = false;
    if (totalPowerRequiredByOperationalConsumers > totalPowerGenerated) {
        _logToPark("Power shortage! Demand ($totalPowerRequiredByOperationalConsumers) exceeds supply ($totalPowerGenerated). Attempting to manage load...", isError: true);
        
        List<OwnedBuilding> consumersToPotentiallyTurnOff = currentBuildings
            .where((b) {
                final t = _provider.buildingTemplatesList.firstWhereOrNull((tmpl) => tmpl.id == b.templateId);
                return t?.type != "power_plant" && b.isOperational && (t?.powerRequired ?? 0) > 0;
            })
            .toList()
            ..sort((a, b) {
                final ta = _provider.buildingTemplatesList.firstWhere((t) => t.id == a.templateId);
                final tb = _provider.buildingTemplatesList.firstWhere((t) => t.id == b.templateId);
                return (tb.powerRequired ?? 0).compareTo(ta.powerRequired ?? 0);
            });

        int currentDemand = totalPowerRequiredByOperationalConsumers;
        for (var buildingToTurnOff in consumersToPotentiallyTurnOff) {
            if (currentDemand <= totalPowerGenerated) break; 

            final template = _provider.buildingTemplatesList.firstWhere((t) => t.id == buildingToTurnOff.templateId);
            int buildingIndex = currentBuildings.indexWhere((b) => b.uniqueId == buildingToTurnOff.uniqueId);
            
            if (buildingIndex != -1 && currentBuildings[buildingIndex].isOperational) { 
                currentBuildings[buildingIndex] = OwnedBuilding(
                    uniqueId: buildingToTurnOff.uniqueId,
                    templateId: buildingToTurnOff.templateId,
                    dinosaurUniqueIds: buildingToTurnOff.dinosaurUniqueIds,
                    currentFoodLevel: buildingToTurnOff.currentFoodLevel,
                    isOperational: false, 
                );
                currentDemand -= (template.powerRequired ?? 0);
                _logToPark("${template.name} turned offline due to power shortage.", isError: true);
                changesMadeToOperationalStatus = true;
            }
        }
        totalPowerRequiredByOperationalConsumers = currentDemand; 
    }

    _provider.setProviderState(
        ownedBuildings: changesMadeToOperationalStatus ? currentBuildings : null, 
        parkManager: _provider.parkManager
            ..currentPowerGenerated = totalPowerGenerated
            ..currentPowerConsumed = totalPowerRequiredByOperationalConsumers,
        doPersist: true, 
        doNotify: true 
    );
}


  void updateAllDinosaursStatus() {
    if (_provider.ownedDinosaurs.isEmpty) return;
    bool changed = false;

    final List<OwnedDinosaur> updatedDinos = _provider.ownedDinosaurs.map((dino) {
        final species = _provider.dinosaurSpeciesList.firstWhereOrNull((s) => s.id == dino.speciesId);
        if (species == null) return dino; 

        OwnedDinosaur updatedDino = OwnedDinosaur.fromJson(dino.toJson()); 

        if (updatedDino.name.contains("(Incubating)")) {
            // Incubation progress already handled by processParkTime via _provider.activeTimers
            return updatedDino; // No further changes here if still incubating
        }

        // For hatched dinosaurs:
        updatedDino.age +=1; 

        updatedDino.currentFood = (updatedDino.currentFood - (_random.nextDouble() * 2 + 1)).clamp(0.0, 100.0); 

        double comfortImpact = 0;
        final enclosure = _provider.ownedBuildings.firstWhereOrNull((b) => b.dinosaurUniqueIds.contains(dino.uniqueId));
        
        if (enclosure != null) {
            final enclosureTemplate = _provider.buildingTemplatesList.firstWhereOrNull((t) => t.id == enclosure.templateId);
            if (enclosureTemplate != null) {
                final dinosInSameEnclosure = enclosure.dinosaurUniqueIds.length;
                if (dinosInSameEnclosure < species.socialNeedsMin || dinosInSameEnclosure > species.socialNeedsMax) {
                    comfortImpact -= 5;
                } else {
                    comfortImpact += 2;
                }
                if (enclosureTemplate.capacity != null && species.enclosureSizeNeeds * dinosInSameEnclosure > enclosureTemplate.capacity! * 5 ) {
                     comfortImpact -= 3; 
                }
            }
            final foodStation = _provider.ownedBuildings.firstWhereOrNull((b) {
                final fTemplate = _provider.buildingTemplatesList.firstWhereOrNull((ft) => ft.id == b.templateId);
                return fTemplate?.type == "food_station" && b.isOperational;
            });
            if (foodStation != null && (foodStation.currentFoodLevel ?? 0) > 0) {
                final int foodConsumed = _random.nextInt(5) + 1; 
                final newFoodStationLevel = (foodStation.currentFoodLevel ?? 0) - foodConsumed;
                 List<OwnedBuilding> tempBuildings = List.from(_provider.ownedBuildings);
                 int fsIndex = tempBuildings.indexWhere((b) => b.uniqueId == foodStation.uniqueId);
                 if (fsIndex != -1) {
                    tempBuildings[fsIndex] = OwnedBuilding(
                        uniqueId: foodStation.uniqueId,
                        templateId: foodStation.templateId,
                        dinosaurUniqueIds: foodStation.dinosaurUniqueIds,
                        isOperational: foodStation.isOperational,
                        currentFoodLevel: newFoodStationLevel.clamp(0, enclosureBaseFoodCapacity)
                    );
                     _provider.setProviderState(ownedBuildings: tempBuildings, doPersist: false, doNotify: false); 
                     changed = true;
                 }
                updatedDino.currentFood = (updatedDino.currentFood + foodConsumed * 5).clamp(0.0, 100.0); 
            }


        } else {
            comfortImpact -= 10; 
        }

        if (updatedDino.currentFood < 20) {
          comfortImpact -= 10;
        } else if (updatedDino.currentFood < 50) comfortImpact -= 5;
        else if (updatedDino.currentFood > 80) comfortImpact += 3;

        updatedDino.currentComfort = (updatedDino.currentComfort + comfortImpact).clamp(0.0, 100.0);

        if (updatedDino.currentComfort < species.comfortThreshold * 100 * 0.5) { 
            updatedDino.currentHealth = (updatedDino.currentHealth - 2).clamp(0.0, 100.0);
        }
        if (updatedDino.currentFood < 10) {
            updatedDino.currentHealth = (updatedDino.currentHealth - 3).clamp(0.0, 100.0);
        }

        if (dino.currentComfort != updatedDino.currentComfort || dino.currentFood != updatedDino.currentFood || dino.currentHealth != updatedDino.currentHealth || dino.name != updatedDino.name || dino.age != updatedDino.age) {
            changed = true;
        }
        return updatedDino;
    }).toList();

    if (changed) {
        _provider.setProviderState(ownedDinosaurs: updatedDinos, doPersist: true, doNotify: true);
        _recalculateParkStats(); 
    }
}



  void _recalculateParkStats() {
    _updateBuildingOperationalStatusBasedOnPower(); 

    int newParkRating = 0;
    int newIncomePerMinuteDollars = 0;
    int newOperationalCostPerMinuteDollars = 0;
    
    int currentPowerGenerated = 0;
    int currentPowerConsumed = 0;

    for (var ownedBuilding in _provider.ownedBuildings) { 
      final template = _provider.buildingTemplatesList.firstWhereOrNull((t) => t.id == ownedBuilding.templateId);
      if (template != null && ownedBuilding.isOperational) { 
        newParkRating += template.parkRatingBoost ?? 0;
        newIncomePerMinuteDollars += template.incomePerMinuteDollars ?? 0;
        newOperationalCostPerMinuteDollars += template.operationalCostPerMinuteDollars ?? 0;
        
        if (template.type == "power_plant") {
            currentPowerGenerated += template.powerOutput ?? 0;
        } else {
            currentPowerConsumed += template.powerRequired ?? 0;
        }
      }
    }
    
    for (var ownedDino in _provider.ownedDinosaurs) {
        final species = _provider.dinosaurSpeciesList.firstWhereOrNull((s) => s.id == ownedDino.speciesId);
        if (species != null && !ownedDino.name.contains("(Incubating)")) { 
            double ratingModifier = 1.0;
            if(ownedDino.currentComfort < species.comfortThreshold * 100) ratingModifier *= 0.5; 
            if(ownedDino.currentHealth < 50) ratingModifier *= 0.7; 
            newParkRating += (species.baseRating * ratingModifier).round();
        }
    }
    newParkRating = newParkRating.clamp(0, MAX_PARK_RATING_FOR_STARS * 2); 

    _provider.setProviderState(
      parkManager: ParkManager(
        parkRating: newParkRating,
        parkDollars: _provider.parkManager.parkDollars, 
        parkEnergy: _provider.playerEnergy, 
        maxParkEnergy: _provider.calculatedMaxEnergy, 
        incomePerMinuteDollars: newIncomePerMinuteDollars,
        operationalCostPerMinuteDollars: newOperationalCostPerMinuteDollars,
        currentPowerGenerated: currentPowerGenerated,
        currentPowerConsumed: currentPowerConsumed,
      ),
      doPersist: true, 
      doNotify: true,
    );
  }
  void recalculateParkStats(){ 
    _recalculateParkStats();
  }

  void skipOneMinute() {
    if (_provider.playerEnergy < SKIP_MINUTE_ENERGY_COST) {
        _logToPark("Not enough energy to fast forward time. Cost: $SKIP_MINUTE_ENERGY_COST⚡", isError: true);
        return;
    }

    final newPlayerEnergy = _provider.playerEnergy - SKIP_MINUTE_ENERGY_COST;
    
    processParkTime(1); // Process one minute of park time, which handles incubation and other per-minute updates
    
    // Note: processParkTime now handles its own recalculation and dollar updates.
    // We just need to set the player energy.
    _provider.setProviderState(
        playerEnergy: newPlayerEnergy,
        doPersist: true, // processParkTime already persists some, this ensures energy is saved too
        doNotify: true
    );
    
    _logToPark("Fast forwarded 1 minute. Energy Cost: $SKIP_MINUTE_ENERGY_COST⚡. Check park log for income/cost details.");
  }

  // New method to process park time based on main task timer
  void processParkTime(int minutes) {
    if (minutes <= 0) return;

    double totalNetIncomeFromTimedActivity = 0;
    List<OwnedDinosaur> currentDinos = List.from(_provider.ownedDinosaurs);

    for (int i = 0; i < minutes; i++) {
        // Update incubating dinosaurs
        currentDinos = currentDinos.map((d) {
            if (d.name.contains("(Incubating)")) {
                OwnedDinosaur updatedDino = OwnedDinosaur.fromJson(d.toJson());
                updatedDino.age +=1; // Each "minute" processed increases age/incubation time by 1 unit
                 final species = _provider.dinosaurSpeciesList.firstWhereOrNull((s) => s.id == updatedDino.speciesId);
                if (species != null && updatedDino.age >= baseIncubationDuration) {
                    updatedDino.name = species.name; // Hatch
                    updatedDino.age = 0; // Reset age for hatched dino
                    _logToPark("${species.name} has hatched during timed activity!");
                }
                return updatedDino;
            }
            return d;
        }).toList();
        
        // Update other statuses (like food, comfort) for hatched dinos
        updateAllDinosaursStatus(); 

        _recalculateParkStats(); 

        int incomeThisMinute = _provider.parkManager.incomePerMinuteDollars;
        int costsThisMinute = _provider.parkManager.operationalCostPerMinuteDollars;
        totalNetIncomeFromTimedActivity += (incomeThisMinute - costsThisMinute);
    }

    final double newParkDollars = _provider.parkManager.parkDollars + totalNetIncomeFromTimedActivity;

    _provider.setProviderState(
        parkManager: _provider.parkManager..parkDollars = newParkDollars.isNegative ? 0 : newParkDollars,
        ownedDinosaurs: currentDinos, // Persist the updated dino list (especially incubation changes)
        doPersist: true,
        doNotify: true
    );

    if (totalNetIncomeFromTimedActivity != 0) {
         _logToPark("Task activity resulted in park income change of \$${totalNetIncomeFromTimedActivity.toStringAsFixed(0)} over $minutes minute(s).");
    }
  }

}
--- END OF FILE lib/src/providers/actions/park_actions.dart ---

--- START OF FILE lib/src/providers/actions/task_actions.dart ---
// lib/src/providers/actions/task_actions.dart
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/utils/constants.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/utils/helpers.dart';
import 'package:collection/collection.dart';

class TaskActions {
  final GameProvider _provider;

  TaskActions(this._provider);

  void addMainTask(
      {required String name,
      required String description,
      required String theme,
      required String colorHex}) {
    final newTask = MainTask(
      id: 'mt_${DateTime.now().millisecondsSinceEpoch}',
      name: name,
      description: description,
      theme: theme,
      colorHex: colorHex,
    );
    _provider.setProviderState(mainTasks: [..._provider.mainTasks, newTask]);
  }

  void editMainTask(String taskId,
      {required String name,
      required String description,
      required String theme,
      required String colorHex}) {
    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == taskId) {
        return MainTask(
          id: task.id,
          name: name,
          description: description,
          theme: theme,
          colorHex: colorHex,
          streak: task.streak,
          dailyTimeSpent: task.dailyTimeSpent,
          lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks,
        );
      }
      return task;
    }).toList();
    _provider.setProviderState(mainTasks: newMainTasks);
  }

  void logToDailySummary(String type, Map<String, dynamic> data) {
    final today = getTodayDateString();
    final newCompletedByDay =
        Map<String, dynamic>.from(_provider.completedByDay);
    final dayData = Map<String, dynamic>.from(newCompletedByDay[today] ??
        {
          'taskTimes': <String, int>{},
          'subtasksCompleted': <Map<String, dynamic>>[],
          'checkpointsCompleted': <Map<String, dynamic>>[], // Ensure this exists
          'emotionLogs': <Map<String, dynamic>>[]
        });

    if (type == 'taskTime') {
      final taskTimes =
          Map<String, int>.from(dayData['taskTimes'] as Map? ?? {});
      taskTimes[data['taskId'] as String] =
          (taskTimes[data['taskId'] as String] ?? 0) + (data['time'] as int);
      dayData['taskTimes'] = taskTimes;
    } else if (type == 'subtaskCompleted') {
      final subtasksCompleted = List<Map<String, dynamic>>.from(
          dayData['subtasksCompleted'] as List? ?? []);
      subtasksCompleted.add(data);
      dayData['subtasksCompleted'] = subtasksCompleted;
    } else if (type == 'subSubtaskCompleted') {
      final checkpointsCompleted = List<Map<String, dynamic>>.from(
          dayData['checkpointsCompleted'] as List? ?? []);
      // Ensure data includes 'completionTimestamp'
      if (!data.containsKey('completionTimestamp')) {
          data['completionTimestamp'] = DateTime.now().toIso8601String();
      }
      checkpointsCompleted.add(data);
      dayData['checkpointsCompleted'] = checkpointsCompleted;
    }

    newCompletedByDay[today] = dayData;
    _provider.setProviderState(completedByDay: newCompletedByDay);
  }

  String addSubtask(String mainTaskId, Map<String, dynamic> subtaskData) {
    final newSubtask = SubTask(
      id: 'sub_${DateTime.now().millisecondsSinceEpoch}_${(_provider.mainTasks.fold<int>(0, (prev, task) => prev + task.subTasks.length) + 1)}',
      name: subtaskData['name'] as String,
      isCountable: subtaskData['isCountable'] as bool? ?? false,
      targetCount: subtaskData['isCountable'] as bool? ?? false
          ? (subtaskData['targetCount'] as int? ?? 1)
          : 0,
      subSubTasks:
          (subtaskData['subSubTasksData'] as List<Map<String, dynamic>>?)
                  ?.map((sssData) => SubSubTask(
                        id: 'ssub_${DateTime.now().millisecondsSinceEpoch}_${(_provider.mainTasks.fold<int>(0, (prev, task) => prev + task.subTasks.fold<int>(0, (prevSt, st) => prevSt + st.subSubTasks.length)) + 1)}_${sssData['name']?.hashCode ?? 0}',
                        name: sssData['name'] as String,
                        isCountable: sssData['isCountable'] as bool? ?? false,
                        targetCount: sssData['isCountable'] as bool? ?? false
                            ? (sssData['targetCount'] as int? ?? 1)
                            : 0,
                      ))
                  .toList() ??
              [],
    );

    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id,
          name: task.name,
          description: task.description,
          theme: task.theme,
          colorHex: task.colorHex,
          streak: task.streak,
          dailyTimeSpent: task.dailyTimeSpent,
          lastWorkedDate: task.lastWorkedDate,
          subTasks: [...task.subTasks, newSubtask],
        );
      }
      return task;
    }).toList();
    _provider.setProviderState(mainTasks: newMainTasks);
    return newSubtask.id;
  }

  void updateSubtask(
      String mainTaskId, String subtaskId, Map<String, dynamic> updates) {
    MainTask? taskToUpdate =
        _provider.mainTasks.firstWhereOrNull((t) => t.id == mainTaskId);
    if (taskToUpdate == null) return;

    SubTask? subtaskToUpdate =
        taskToUpdate.subTasks.firstWhereOrNull((s) => s.id == subtaskId);
    if (subtaskToUpdate == null) return;

    final int oldSubtaskTime = subtaskToUpdate.currentTimeSpent;

    if (updates.containsKey('name')) {
      subtaskToUpdate.name = updates['name'] as String;
    }
    if (updates.containsKey('isCountable')) {
      subtaskToUpdate.isCountable = updates['isCountable'] as bool;
    }
    if (updates.containsKey('targetCount')) {
      subtaskToUpdate.targetCount = updates['targetCount'] as int;
    }
    if (updates.containsKey('currentCount')) {
      subtaskToUpdate.currentCount = (updates['currentCount'] as int)
          .clamp(0, subtaskToUpdate.targetCount);
    }
    if (updates.containsKey('currentTimeSpent')) {
      subtaskToUpdate.currentTimeSpent = updates['currentTimeSpent'] as int;
    }

    int timeDifference = 0;
    if (updates.containsKey('currentTimeSpent')) {
      timeDifference = subtaskToUpdate.currentTimeSpent - oldSubtaskTime;
    }

    final Map<String, dynamic> stateUpdatesForSetAndPersist = {};

    if (timeDifference != 0) {
      taskToUpdate.dailyTimeSpent =
          (taskToUpdate.dailyTimeSpent) + timeDifference;
      taskToUpdate.lastWorkedDate = getTodayDateString();
      logToDailySummary(
          'taskTime', {'taskId': mainTaskId, 'time': timeDifference});
      if (timeDifference > 0) {
        stateUpdatesForSetAndPersist['playerEnergy'] = (_provider.playerEnergy +
                timeDifference * energyRegenPerMinuteTasked)
            .clamp(0, _provider.calculatedMaxEnergy);
      }
    }

    final int oldDailyTotalBeforeThisChange =
        taskToUpdate.dailyTimeSpent - timeDifference;
    if (oldDailyTotalBeforeThisChange < dailyTaskGoalMinutes &&
        taskToUpdate.dailyTimeSpent >= dailyTaskGoalMinutes) {
      final double luckBonus =
          1 + (_provider.playerGameStats['luck']!.value / 100);
      final double xpBonusFromArtifact =
          _provider.playerGameStats['bonusXPMod']?.value ?? 0.0;
      final double totalXPMultiplier = luckBonus * (1 + xpBonusFromArtifact);

      stateUpdatesForSetAndPersist['coins'] =
          _provider.coins + (streakBonusCoins * luckBonus).floor();
      stateUpdatesForSetAndPersist['xp'] =
          _provider.xp + (streakBonusXp * totalXPMultiplier).floor();
      taskToUpdate.streak = taskToUpdate.streak + 1;
    }

    final newMainTasks = _provider.mainTasks
        .map((t) => t.id == mainTaskId ? taskToUpdate : t)
        .toList();
    stateUpdatesForSetAndPersist['mainTasks'] = newMainTasks;
    _provider.setProviderState(
      coins: stateUpdatesForSetAndPersist['coins'] as double?,
      xp: stateUpdatesForSetAndPersist['xp'] as double?,
      playerEnergy: stateUpdatesForSetAndPersist['playerEnergy'] as double?,
      mainTasks: newMainTasks,
    );
  }

  bool completeSubtask(String mainTaskId, String subtaskId) {
    MainTask? mainTask =
        _provider.mainTasks.firstWhereOrNull((t) => t.id == mainTaskId);
    if (mainTask == null) return false;
    SubTask? subTask =
        mainTask.subTasks.firstWhereOrNull((st) => st.id == subtaskId);
    if (subTask == null || subTask.completed) return false;

    if (subTask.isCountable && subTask.currentCount < subTask.targetCount) {
      return false;
    }
    if (subTask.currentTimeSpent <= 0 && !subTask.isCountable) {
      bool allSubSubTasksDone =
          subTask.subSubTasks.every((sss) => sss.completed);
      if (subTask.subSubTasks.isNotEmpty && !allSubSubTasksDone) {
        return false;
      }
      if (subTask.subSubTasks.isEmpty && subTask.currentTimeSpent <= 0) {
        return false;
      }
    }

    ActiveTimerInfo? timerForSubtask = _provider.activeTimers[subtaskId];
    SubTask updatedSubTaskForRewards = SubTask(
        id: subTask.id,
        name: subTask.name,
        currentTimeSpent: subTask.currentTimeSpent,
        isCountable: subTask.isCountable,
        targetCount: subTask.targetCount,
        currentCount: subTask.currentCount,
        subSubTasks: subTask.subSubTasks);

    if (timerForSubtask != null) {
      double totalSecondsToLog = timerForSubtask.accumulatedDisplayTime;
      if (timerForSubtask.isRunning) {
        totalSecondsToLog += (DateTime.now()
                .difference(timerForSubtask.startTime)
                .inMilliseconds) /
            1000;
      }
      final int elapsedMinutes = (totalSecondsToLog / 60).round();

      if (elapsedMinutes > 0) {
        updateSubtask(mainTaskId, subtaskId,
            {'currentTimeSpent': subTask.currentTimeSpent + elapsedMinutes});
        final MainTask? refetchedMainTask =
            _provider.mainTasks.firstWhereOrNull((t) => t.id == mainTaskId);
        if (refetchedMainTask != null) {
          updatedSubTaskForRewards = refetchedMainTask.subTasks
                  .firstWhereOrNull((st) => st.id == subtaskId) ??
              subTask;
        }
      }
      final newActiveTimers =
          Map<String, ActiveTimerInfo>.from(_provider.activeTimers);
      newActiveTimers.remove(subtaskId);
      _provider.setProviderState(
          activeTimers: newActiveTimers, doPersist: false);
    }

    final double luckBonus =
        1 + (_provider.playerGameStats['luck']!.value / 100);
    final double xpBonusFromArtifact =
        _provider.playerGameStats['bonusXPMod']?.value ?? 0.0;
    final double totalXPMultiplier = luckBonus * (1 + xpBonusFromArtifact);

    double proportionalXp = 0;
    double proportionalCoins = 0;

    if (updatedSubTaskForRewards.isCountable) {
      proportionalXp =
          updatedSubTaskForRewards.targetCount * xpPerCountUnitSubtask;
      proportionalCoins =
          updatedSubTaskForRewards.targetCount * coinsPerCountUnitSubtask;
    } else {
      proportionalXp =
          updatedSubTaskForRewards.currentTimeSpent * xpPerMinuteSubtask;
      proportionalCoins =
          updatedSubTaskForRewards.currentTimeSpent * coinsPerMinuteSubtask;
    }

    final double baseCompletionXp =
        subtaskCompletionXpBase + _provider.playerLevel + mainTask.streak;
    final double baseCompletionCoins = subtaskCompletionCoinBase +
        (_provider.playerLevel * 0.5) +
        (mainTask.streak * 0.2);

    final int finalXpReward =
        ((baseCompletionXp + proportionalXp) * totalXPMultiplier).floor();
    final int finalCoinReward =
        ((baseCompletionCoins + proportionalCoins) * luckBonus).floor();

    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id,
          name: task.name,
          description: task.description,
          theme: task.theme,
          colorHex: task.colorHex,
          streak: task.streak,
          dailyTimeSpent: task.dailyTimeSpent,
          lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks.map((st) {
            if (st.id == subtaskId) {
              return SubTask(
                  id: st.id,
                  name: st.name,
                  completed: true,
                  completedDate: getTodayDateString(),
                  currentTimeSpent: st.currentTimeSpent,
                  isCountable: st.isCountable,
                  targetCount: st.targetCount,
                  currentCount: st.currentCount,
                  subSubTasks: st.subSubTasks);
            }
            return st;
          }).toList(),
        );
      }
      return task;
    }).toList();

    _provider.setProviderState(
      mainTasks: newMainTasks,
      xp: _provider.xp + finalXpReward,
      coins: _provider.coins + finalCoinReward,
    );

    logToDailySummary('subtaskCompleted', {
      'parentTaskId': mainTask.id,
      'name': updatedSubTaskForRewards.name,
      'timeLogged': updatedSubTaskForRewards.currentTimeSpent,
      'isCountable': updatedSubTaskForRewards.isCountable,
      'currentCount': updatedSubTaskForRewards.currentCount,
      'targetCount': updatedSubTaskForRewards.targetCount
    });
    return true;
  }

  void deleteSubtask(String mainTaskId, String subtaskId) {
    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id,
          name: task.name,
          description: task.description,
          theme: task.theme,
          colorHex: task.colorHex,
          streak: task.streak,
          dailyTimeSpent: task.dailyTimeSpent,
          lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks.where((st) => st.id != subtaskId).toList(),
        );
      }
      return task;
    }).toList();

    final newActiveTimers =
        Map<String, ActiveTimerInfo>.from(_provider.activeTimers);
    newActiveTimers.remove(subtaskId);
    _provider.setProviderState(
        mainTasks: newMainTasks, activeTimers: newActiveTimers);
  }

  void duplicateCompletedSubtask(String mainTaskId, String subtaskId) {
    MainTask? taskToUpdate =
        _provider.mainTasks.firstWhereOrNull((task) => task.id == mainTaskId);
    if (taskToUpdate == null) return;

    SubTask? subTaskToDuplicate =
        taskToUpdate.subTasks.firstWhereOrNull((st) => st.id == subtaskId);
    if (subTaskToDuplicate == null || !subTaskToDuplicate.completed) return;

    final newSubtask = SubTask(
      id: 'sub_${DateTime.now().millisecondsSinceEpoch}_${(taskToUpdate.subTasks.length + 1)}',
      name: subTaskToDuplicate.name,
      completed: false,
      currentTimeSpent: 0,
      completedDate: null,
      isCountable: subTaskToDuplicate.isCountable,
      targetCount: subTaskToDuplicate.targetCount,
      currentCount: 0,
      subSubTasks: subTaskToDuplicate.subSubTasks
          .map((sss) => SubSubTask(
                id: 'ssub_${DateTime.now().millisecondsSinceEpoch}_${(subTaskToDuplicate.subSubTasks.length + 1)}_${sss.name.hashCode}',
                name: sss.name,
                completed: false,
                isCountable: sss.isCountable,
                targetCount: sss.targetCount,
                currentCount: 0,
                completionTimestamp: null, // Reset timestamp
              ))
          .toList(),
    );

    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id,
          name: task.name,
          description: task.description,
          theme: task.theme,
          colorHex: task.colorHex,
          streak: task.streak,
          dailyTimeSpent: task.dailyTimeSpent,
          lastWorkedDate: task.lastWorkedDate,
          subTasks: [...task.subTasks, newSubtask],
        );
      }
      return task;
    }).toList();
    _provider.setProviderState(mainTasks: newMainTasks);
  }

  void addSubSubtask(String mainTaskId, String parentSubtaskId,
      Map<String, dynamic> subSubtaskData) {
    final newSubSubtask = SubSubTask(
      id: 'ssub_${DateTime.now().millisecondsSinceEpoch}_${subSubtaskData['name']?.hashCode ?? 0}',
      name: subSubtaskData['name'] as String,
      isCountable: subSubtaskData['isCountable'] as bool? ?? false,
      targetCount: subSubtaskData['isCountable'] as bool? ?? false
          ? (subSubtaskData['targetCount'] as int? ?? 1)
          : 0,
      completionTimestamp: null,
    );

    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id,
          name: task.name,
          description: task.description,
          theme: task.theme,
          colorHex: task.colorHex,
          streak: task.streak,
          dailyTimeSpent: task.dailyTimeSpent,
          lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks.map((st) {
            if (st.id == parentSubtaskId) {
              return SubTask(
                id: st.id,
                name: st.name,
                completed: st.completed,
                currentTimeSpent: st.currentTimeSpent,
                completedDate: st.completedDate,
                isCountable: st.isCountable,
                targetCount: st.targetCount,
                currentCount: st.currentCount,
                subSubTasks: [...st.subSubTasks, newSubSubtask],
              );
            }
            return st;
          }).toList(),
        );
      }
      return task;
    }).toList();
    _provider.setProviderState(mainTasks: newMainTasks);
  }

  void updateSubSubtask(String mainTaskId, String parentSubtaskId,
      String subSubtaskId, Map<String, dynamic> updates) {
    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id,
          name: task.name,
          description: task.description,
          theme: task.theme,
          colorHex: task.colorHex,
          streak: task.streak,
          dailyTimeSpent: task.dailyTimeSpent,
          lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks.map((st) {
            if (st.id == parentSubtaskId) {
              return SubTask(
                id: st.id,
                name: st.name,
                completed: st.completed,
                currentTimeSpent: st.currentTimeSpent,
                completedDate: st.completedDate,
                isCountable: st.isCountable,
                targetCount: st.targetCount,
                currentCount: st.currentCount,
                subSubTasks: st.subSubTasks.map((sss) {
                  if (sss.id == subSubtaskId) {
                    final updatedSss = SubSubTask(
                      id: sss.id,
                      name: updates['name'] as String? ?? sss.name,
                      completed: updates['completed'] as bool? ?? sss.completed,
                      isCountable:
                          updates['isCountable'] as bool? ?? sss.isCountable,
                      targetCount:
                          updates['targetCount'] as int? ?? sss.targetCount,
                      currentCount:
                          updates['currentCount'] as int? ?? sss.currentCount,
                      completionTimestamp: updates['completionTimestamp'] as String? ?? sss.completionTimestamp,
                    );
                    if (updatedSss.isCountable) {
                      updatedSss.currentCount = updatedSss.currentCount
                          .clamp(0, updatedSss.targetCount);
                    }
                    return updatedSss;
                  }
                  return sss;
                }).toList(),
              );
            }
            return st;
          }).toList(),
        );
      }
      return task;
    }).toList();
    _provider.setProviderState(mainTasks: newMainTasks);
  }

  void completeSubSubtask(
      String mainTaskId, String parentSubtaskId, String subSubtaskId) {
    double xpReward = 0;
    double coinReward = 0;
    bool subSubTaskCompletedSuccessfully = false;
    SubSubTask? completedSubSubTaskInstanceForLog; // Used specifically for logging

    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          // ... (copy other MainTask fields) ...
          id: task.id,
          name: task.name,
          description: task.description,
          theme: task.theme,
          colorHex: task.colorHex,
          streak: task.streak,
          dailyTimeSpent: task.dailyTimeSpent,
          lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks.map((st) {
            if (st.id == parentSubtaskId) {
              return SubTask(
                // ... (copy other SubTask fields) ...
                id: st.id,
                name: st.name,
                completed: st.completed,
                currentTimeSpent: st.currentTimeSpent,
                completedDate: st.completedDate,
                isCountable: st.isCountable,
                targetCount: st.targetCount,
                currentCount: st.currentCount,
                subSubTasks: st.subSubTasks.map((sss) {
                  if (sss.id == subSubtaskId && !sss.completed) {
                    if (sss.isCountable && sss.currentCount < sss.targetCount) {
                      subSubTaskCompletedSuccessfully = false;
                      return sss;
                    }
                    // ... (reward calculation as before) ...
                    final double luckBonus = 1 + (_provider.playerGameStats['luck']!.value / 100);
                    final double xpBonusFromArtifact = _provider.playerGameStats['bonusXPMod']?.value ?? 0.0;
                    final double totalXPMultiplier = luckBonus * (1 + xpBonusFromArtifact);
                    double proportionalXp = 0;
                    double proportionalCoins = 0;
                    if (sss.isCountable) {
                      proportionalXp = sss.targetCount * xpPerCountUnitSubSubtask;
                      proportionalCoins = sss.targetCount * coinsPerCountUnitSubSubtask;
                    }
                    xpReward = ((subSubtaskCompletionXpBase + proportionalXp) * totalXPMultiplier).floorToDouble();
                    coinReward = ((subSubtaskCompletionCoinBase + proportionalCoins) * luckBonus).floorToDouble();

                    // This is the instance that gets saved in the task structure
                    SubSubTask updatedSss = SubSubTask(
                        id: sss.id,
                        name: sss.name,
                        completed: true,
                        isCountable: sss.isCountable,
                        targetCount: sss.targetCount,
                        currentCount: sss.currentCount,
                        completionTimestamp: DateTime.now().toIso8601String(), // SET TIMESTAMP
                    );
                    // This is for logging, capture the state at completion
                    completedSubSubTaskInstanceForLog = SubSubTask(
                        id: sss.id,
                        name: sss.name,
                        completed: true,
                        isCountable: sss.isCountable,
                        targetCount: sss.targetCount,
                        currentCount: sss.currentCount,
                        completionTimestamp: updatedSss.completionTimestamp, // Use the same timestamp
                    );
                    subSubTaskCompletedSuccessfully = true;
                    return updatedSss;
                  }
                  return sss;
                }).toList(),
              );
            }
            return st;
          }).toList(),
        );
      }
      return task;
    }).toList();

    if (subSubTaskCompletedSuccessfully &&
        completedSubSubTaskInstanceForLog != null) {
      _provider.setProviderState(
        mainTasks: newMainTasks,
        xp: _provider.xp + xpReward,
        coins: _provider.coins + coinReward,
      );
      logToDailySummary('subSubtaskCompleted', {
        'mainTaskId': mainTaskId,
        'parentSubtaskId': parentSubtaskId,
        'subSubtaskId': subSubtaskId,
        'name': completedSubSubTaskInstanceForLog!.name,
        'isCountable': completedSubSubTaskInstanceForLog!.isCountable,
        'currentCount': completedSubSubTaskInstanceForLog!.currentCount,
        'targetCount': completedSubSubTaskInstanceForLog!.targetCount,
        'completionTimestamp': completedSubSubTaskInstanceForLog!.completionTimestamp, // Pass to log
        'parentSubtaskName': _provider.mainTasks
                .firstWhereOrNull((m) => m.id == mainTaskId)
                ?.subTasks
                .firstWhereOrNull((s) => s.id == parentSubtaskId)
                ?.name ??
            'N/A',
        'mainTaskName': _provider.mainTasks
                .firstWhereOrNull((m) => m.id == mainTaskId)
                ?.name ??
            'N/A'
      });
    }
  }

  void deleteSubSubtask(
      String mainTaskId, String parentSubtaskId, String subSubtaskId) {
    final newMainTasks = _provider.mainTasks.map((task) {
      if (task.id == mainTaskId) {
        return MainTask(
          id: task.id,
          name: task.name,
          description: task.description,
          theme: task.theme,
          colorHex: task.colorHex,
          streak: task.streak,
          dailyTimeSpent: task.dailyTimeSpent,
          lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks.map((st) {
            if (st.id == parentSubtaskId) {
              return SubTask(
                id: st.id,
                name: st.name,
                completed: st.completed,
                currentTimeSpent: st.currentTimeSpent,
                completedDate: st.completedDate,
                isCountable: st.isCountable,
                targetCount: st.targetCount,
                currentCount: st.currentCount,
                subSubTasks: st.subSubTasks
                    .where((sss) => sss.id != subSubtaskId)
                    .toList(),
              );
            }
            return st;
          }).toList(),
        );
      }
      return task;
    }).toList();
    _provider.setProviderState(mainTasks: newMainTasks);
  }
}
--- END OF FILE lib/src/providers/actions/task_actions.dart ---

--- START OF FILE lib/src/providers/actions/timer_actions.dart ---
// lib/src/providers/actions/timer_actions.dart
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/models/game_models.dart';

class TimerActions {
  final GameProvider _provider;

  TimerActions(this._provider);

  void startTimer(String id, String type, String mainTaskId) {
    Map<String, ActiveTimerInfo> updatedActiveTimers =
        Map.from(_provider.activeTimers);

    // Pause any other running timer
    for (var entry in updatedActiveTimers.entries) {
      final timerId = entry.key;
      final timerInfo = entry.value;
      if (timerInfo.isRunning && timerId != id) {
        final double elapsed =
            (DateTime.now().difference(timerInfo.startTime).inMilliseconds) /
                1000.0;
        updatedActiveTimers[timerId] = ActiveTimerInfo(
          startTime: timerInfo.startTime,
          accumulatedDisplayTime: timerInfo.accumulatedDisplayTime + elapsed,
          isRunning: false,
          type: timerInfo.type,
          mainTaskId: timerInfo.mainTaskId,
        );
      }
    }

    // Start or resume the selected timer
    final existingTimer = updatedActiveTimers[id];
    updatedActiveTimers[id] = ActiveTimerInfo(
      startTime: DateTime.now(),
      accumulatedDisplayTime:
          existingTimer?.accumulatedDisplayTime ?? 0, // Retain accumulated time
      isRunning: true,
      type: type,
      mainTaskId: mainTaskId,
    );
    _provider.setProviderState(activeTimers: updatedActiveTimers);
  }

  void pauseTimer(String id) {
    final timer = _provider.activeTimers[id];
    if (timer != null && timer.isRunning) {
      final double elapsed =
          (DateTime.now().difference(timer.startTime).inMilliseconds) / 1000.0;
      final newActiveTimers =
          Map<String, ActiveTimerInfo>.from(_provider.activeTimers);
      newActiveTimers[id] = ActiveTimerInfo(
        startTime: timer
            .startTime, // Keep original startTime, elapsed time is added to accumulated
        accumulatedDisplayTime: timer.accumulatedDisplayTime + elapsed,
        isRunning: false,
        type: timer.type,
        mainTaskId: timer.mainTaskId,
      );
      _provider.setProviderState(activeTimers: newActiveTimers);
    }
  }

  void logTimerAndReset(String id) {
    final timer = _provider.activeTimers[id];
    if (timer != null) {
      double totalSecondsToLog = timer.accumulatedDisplayTime;
      if (timer.isRunning) {
        totalSecondsToLog +=
            (DateTime.now().difference(timer.startTime).inMilliseconds) /
                1000.0;
      }
      final int minutesToLog = (totalSecondsToLog / 60).round();

      if (minutesToLog > 0) {
        if (timer.type == 'subtask') {
          final MainTask currentMainTask = _provider.mainTasks.firstWhere(
              (t) => t.id == timer.mainTaskId,
              orElse: () =>
                  MainTask(id: '', name: '', description: '', theme: ''));
          if (currentMainTask.id.isNotEmpty) {
            final SubTask subtask = currentMainTask.subTasks.firstWhere(
                (st) => st.id == id,
                orElse: () => SubTask(id: '', name: ''));
            if (subtask.id.isNotEmpty) {
              // Update the subtask's currentTimeSpent
              // This will also trigger daily goal checks and energy regen in updateSubtask
              _provider.updateSubtask(timer.mainTaskId, id, {
                'currentTimeSpent': subtask.currentTimeSpent + minutesToLog
              });
            }
          }
        }
        // Process park time for the logged minutes if park features are active
        _provider.parkActions.processParkTime(minutesToLog);
      }

      final newActiveTimers =
          Map<String, ActiveTimerInfo>.from(_provider.activeTimers);
      newActiveTimers.remove(id);
      _provider.setProviderState(activeTimers: newActiveTimers);
    }
  }
}

--- END OF FILE lib/src/providers/actions/timer_actions.dart ---

--- START OF FILE lib/src/screens/chatbot_screen.dart ---
// lib/src/screens/chatbot_screen.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/widgets/views/chatbot_view.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:arcane/src/providers/game_provider.dart';

class ChatbotScreen extends StatelessWidget {
  const ChatbotScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context); // For dynamic accent
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    // Ensure chatbot memory is initialized when this screen is visited
    WidgetsBinding.instance.addPostFrameCallback((_) {
      gameProvider.initializeChatbotMemory();
    });


    return Scaffold(
      appBar: AppBar(
        title: const Text('Arcane Advisor'),
        backgroundColor: AppTheme.fhBgMedium,
        // Use the dynamic accent color for the AppBar potentially
         flexibleSpace: Container( 
          decoration: BoxDecoration(
            gradient: LinearGradient(
              colors: [
                theme.colorScheme.secondary.withOpacity(0.3),
                AppTheme.fhBgMedium,
              ],
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
            ),
          ),
        ),
      ),
      body: const ChatbotView(),
    );
  }
}
--- END OF FILE lib/src/screens/chatbot_screen.dart ---

--- START OF FILE lib/src/screens/home_screen.dart ---
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/widgets/header_widget.dart';
import 'package:arcane/src/widgets/middle_panel_widget.dart'; // This will be adapted
import 'package:arcane/src/widgets/player_stats_drawer.dart';
import 'package:arcane/src/widgets/task_navigation_drawer.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:arcane/src/widgets/views/artifact_shop_view.dart';
import 'package:arcane/src/widgets/views/blacksmith_view.dart';
import 'package:arcane/src/widgets/views/game_view.dart';
import 'package:arcane/src/widgets/views/task_details_view.dart';
import 'package:arcane/src/widgets/views/park_view.dart'; // New Park View
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen>
    with SingleTickerProviderStateMixin {
  int _selectedIndex = 0; // For BottomNavigationBar or TabBar
  late GameProvider _gameProvider;
  final ScrollController _scrollController = ScrollController();
  bool _isUsernameDialogShowing = false;
  late TabController _tabController; // Add TabController

  final List<Map<String, dynamic>> _views = [
    {
      'label': 'MISSIONS',
      'value': 'task-details',
      'icon': MdiIcons.clipboardListOutline
    },
    {
      'label': 'ARMORY',
      'value': 'artifact-shop',
      'icon': MdiIcons.storefrontOutline
    },
    {'label': 'FORGE', 'value': 'blacksmith', 'icon': MdiIcons.hammerWrench},
    {'label': 'ARENA', 'value': 'game', 'icon': MdiIcons.swordCross},
    {'label': 'PARK', 'value': 'park', 'icon': MdiIcons.tree}, // Changed Park Icon
  ];

  @override
  void initState() {
    super.initState();
    _gameProvider = Provider.of<GameProvider>(context, listen: false);

    _tabController = TabController(length: _views.length, vsync: this);

    _selectedIndex =
        _views.indexWhere((view) => view['value'] == _gameProvider.currentView);
    if (_selectedIndex == -1) {
      _selectedIndex = 0;
      _gameProvider.setCurrentView(_views[0]['value'] as String);
    }
    _tabController.index = _selectedIndex; // Set initial tab index

    // Listen to tab controller changes to update provider
    _tabController.addListener(() {
      if (_tabController.indexIsChanging ||
          _tabController.index == _selectedIndex) {
        return;
      }
      FocusScope.of(context).unfocus(); // Unfocus on tab change
      setState(() {
        _selectedIndex = _tabController.index;
      });
      _gameProvider.setCurrentView(_views[_selectedIndex]['value'] as String);
      print(
          "[HomeScreen] TabController Listener: Updated selectedIndex to $_selectedIndex for view ${_views[_selectedIndex]['value']}");
    });

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (_gameProvider.selectedTaskId == null &&
          _gameProvider.mainTasks.isNotEmpty) {
        _gameProvider.setSelectedTaskId(_gameProvider.mainTasks.first.id);
      }
      _checkAndPromptForUsername(_gameProvider);
    });
    _gameProvider.addListener(_handleProviderForUsernamePrompt);
    _gameProvider.addListener(_handleCurrentViewChangeFromProvider);

    print(
        "[HomeScreen] initState: Initial selectedIndex: $_selectedIndex, currentView: ${_gameProvider.currentView}");
  }

  void _handleProviderForUsernamePrompt() {
    _checkAndPromptForUsername(
        Provider.of<GameProvider>(context, listen: false));
  }

  void _handleCurrentViewChangeFromProvider() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    final newIndex =
        _views.indexWhere((view) => view['value'] == gameProvider.currentView);
    if (newIndex != -1 && newIndex != _selectedIndex) {
      if (mounted) {
        FocusScope.of(context).unfocus(); // Unfocus if view changes from provider
        setState(() {
          _selectedIndex = newIndex;
        });
        _tabController.animateTo(newIndex); // Animate to the new tab
        print(
            "[HomeScreen] _handleCurrentViewChangeFromProvider: Updated selectedIndex to $newIndex for view ${gameProvider.currentView}");
      }
    } else if (newIndex == -1 &&
        _views.indexWhere((v) => v['value'] == gameProvider.currentView) ==
            -1) {
      if (mounted && _selectedIndex != 0) {
        FocusScope.of(context).unfocus(); // Unfocus if defaulting
        setState(() {
          _selectedIndex = 0;
        });
        _tabController.animateTo(0); // Animate to the first tab
        print(
            "[HomeScreen] _handleCurrentViewChangeFromProvider: currentView '${gameProvider.currentView}' not in tabs, defaulting to index 0.");
      }
    }
  }

  void _checkAndPromptForUsername(GameProvider gameProvider) {
    if (mounted &&
        gameProvider.isUsernameMissing &&
        gameProvider.currentUser != null &&
        !_isUsernameDialogShowing &&
        !gameProvider.authLoading &&
        !gameProvider.isDataLoadingAfterLogin) {
      print("[HomeScreen] Prompting for username.");
      setState(() {
        _isUsernameDialogShowing = true;
      });
      _showUsernameDialog(context, gameProvider).then((_) {
        if (mounted) {
          setState(() {
            _isUsernameDialogShowing = false;
          });
        }
      });
    }
  }

  Future<void> _showUsernameDialog(
      BuildContext context, GameProvider gameProvider) async {
    final TextEditingController usernameController = TextEditingController();
    final GlobalKey<FormState> dialogFormKey = GlobalKey<FormState>();
    print("[HomeScreen] Showing username dialog.");
    final Color currentAccentColor =
        gameProvider.getSelectedTask()?.taskColor ??
            Theme.of(context).colorScheme.secondary;

    return showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: Text('Set Your Callsign',
              style: TextStyle(color: currentAccentColor)),
          content: Form(
            key: dialogFormKey,
            child: TextFormField(
              controller: usernameController,
              decoration:
                  const InputDecoration(hintText: "Enter callsign (username)"),
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'Callsign cannot be empty.';
                }
                if (value.trim().length < 3) {
                  return 'Must be at least 3 characters.';
                }
                return null;
              },
            ),
          ),
          actions: <Widget>[
            ElevatedButton(
              style:
                  ElevatedButton.styleFrom(backgroundColor: currentAccentColor),
              child: Text('CONFIRM CALLSIGN',
                  style: TextStyle(
                      color: ThemeData.estimateBrightnessForColor(
                                  currentAccentColor) ==
                              Brightness.dark
                          ? AppTheme.fhTextPrimary
                          : AppTheme.fhBgDark)),
              onPressed: () async {
                if (dialogFormKey.currentState!.validate()) {
                  String newUsername = usernameController.text.trim();
                  Navigator.of(dialogContext).pop();
                  print(
                      "[HomeScreen] Username dialog confirmed with: $newUsername");
                  await gameProvider.updateUserDisplayName(newUsername);
                  if (mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(
                          content: Text('Callsign updated!'),
                          backgroundColor: AppTheme.fhAccentGreen),
                    );
                  }
                }
              },
            ),
          ],
        );
      },
    );
  }

  void _onItemTapped(int index) {
    if (index < 0 || index >= _views.length) return;
    FocusScope.of(context).unfocus(); // Unfocus on BottomNav tap
    print(
        "[HomeScreen] _onItemTapped: index $index, view value: ${_views[index]['value']}");
    setState(() {
      _selectedIndex = index;
    });
    _gameProvider.setCurrentView(_views[index]['value'] as String);
     _tabController.animateTo(index); // Sync TabController on BottomNav tap for smaller screens
  }

  @override
  void dispose() {
    _gameProvider.removeListener(_handleProviderForUsernamePrompt);
    _gameProvider.removeListener(_handleCurrentViewChangeFromProvider);
    _scrollController.dispose();
    _tabController.dispose(); // Dispose TabController
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;
    final bool isLargeScreen = screenWidth > 900;

    final gameProvider = context.watch<GameProvider>();
    final Color currentTaskColor =
        gameProvider.getSelectedTask()?.taskColor ?? AppTheme.fhAccentTealFixed;
    final ThemeData dynamicTheme =
        AppTheme.getThemeData(primaryAccent: currentTaskColor);

    print(
        "[HomeScreen] build: SelectedIndex: $_selectedIndex, CurrentView from provider: ${gameProvider.currentView}");

    return Theme(
      data: dynamicTheme,
      child: Scaffold(
        body: SafeArea(
          child: Column(
            children: [
              HeaderWidget(
                  currentViewLabel: _views.isNotEmpty &&
                          _selectedIndex >= 0 &&
                          _selectedIndex < _views.length
                      ? _views[_selectedIndex]['label'] as String
                      : "MISSIONS"),
              Expanded(
                child: isLargeScreen
                    ? Row(
                        children: [
                          Container(
                            width: 280,
                            decoration: BoxDecoration(
                              color: dynamicTheme.cardTheme.color,
                              border: Border(
                                  right: BorderSide(
                                      color: dynamicTheme.dividerTheme.color ??
                                          AppTheme.fhBorderColor,
                                      width: 1)),
                            ),
                            child: const TaskNavigationDrawer(),
                          ),
                          Expanded(
                            child: Column(
                              // New: Column for TabBar and TabBarView
                              children: [
                                Container(
                                  color: dynamicTheme.cardTheme.color,
                                  child: TabBar(
                                    controller: _tabController,
                                    isScrollable: false,
                                    indicatorColor:
                                        dynamicTheme.colorScheme.secondary,
                                    labelColor:
                                        dynamicTheme.colorScheme.secondary,
                                    unselectedLabelColor: dynamicTheme
                                        .textTheme.bodyMedium?.color
                                        ?.withOpacity(0.7),
                                    tabs: _views.map((view) {
                                      return Tab(
                                        icon: Icon(view['icon'] as IconData),
                                        text: view['label'] as String,
                                      );
                                    }).toList(),
                                  ),
                                ),
                                Expanded(
                                  // Ensure TabBarView takes remaining space
                                  child: TabBarView(
                                    controller: _tabController,
                                    children: _views
                                        .map<Widget>((v) => MiddlePanelWidget(
                                            selectedIndex: _views.indexOf(v),
                                            views: _views
                                                .map<Widget>((v) =>
                                                    _getViewWidget(
                                                        v['value'] as String))
                                                .toList()))
                                        .toList(),
                                  ),
                                ),
                              ],
                            ),
                          ),
                          Container(
                            width: 320,
                            decoration: BoxDecoration(
                              color: dynamicTheme.cardTheme.color,
                              border: Border(
                                  left: BorderSide(
                                      color: dynamicTheme.dividerTheme.color ??
                                          AppTheme.fhBorderColor,
                                      width: 1)),
                            ),
                            child: const PlayerStatsDrawer(),
                          ),
                        ],
                      )
                    : MiddlePanelWidget(
                        selectedIndex: _selectedIndex,
                        views: _views
                            .map<Widget>(
                                (v) => _getViewWidget(v['value'] as String))
                            .toList()),
              ),
            ],
          ),
        ),
        drawer: isLargeScreen ? null : const TaskNavigationDrawer(),
        endDrawer: isLargeScreen ? null : const PlayerStatsDrawer(),
        bottomNavigationBar: isLargeScreen
            ? null
            : BottomNavigationBar(
                items: _views.map((view) {
                  return BottomNavigationBarItem(
                    icon: Icon(view['icon'] as IconData),
                    label: view['label'] as String,
                  );
                }).toList(),
                currentIndex: _selectedIndex.clamp(0, _views.length - 1),
                onTap: _onItemTapped,
              ),
      ),
    );
  }

  Widget _getViewWidget(String viewValue) {
    switch (viewValue) {
      case 'task-details':
        return const TaskDetailsView();
      case 'artifact-shop':
        return const ArtifactShopView();
      case 'blacksmith':
        return const BlacksmithView();
      case 'game':
        return const GameView();
      case 'park': // New Park View
        return const ParkView(); 
      default:
        if (_views.isNotEmpty) {
          return _getViewWidget(_views[0]['value'] as String);
        }
        return const Center(child: Text('Unknown View'));
    }
  }
}

--- END OF FILE lib/src/screens/home_screen.dart ---

--- START OF FILE lib/src/screens/logbook_screen.dart ---
import 'package:flutter/material.dart';
import 'package:arcane/src/widgets/views/daily_summary_view.dart';
// import 'package:arcane/src/widgets/views/chatbot_view.dart'; // REMOVE
import 'package:arcane/src/screens/chatbot_screen.dart'; // NEW
import 'package:arcane/src/theme/app_theme.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
// Provider imports remain if DailySummaryView needs them directly or indirectly.

class LogbookScreen extends StatelessWidget { // Can be StatelessWidget now
  const LogbookScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Intelligence Archives'),
        backgroundColor: AppTheme.fhBgMedium,
        // REMOVE TabBar from here
      ),
      body: Center( // DailySummaryView is the main content now
        child:  ConstrainedBox(
          constraints: BoxConstraints(maxWidth: 900),
          child: DailySummaryView(),
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          Navigator.push(
            context,
            MaterialPageRoute(builder: (context) => const ChatbotScreen()),
          );
        },
        label: const Text('Advisor'),
        icon: Icon(MdiIcons.robotHappyOutline),
        backgroundColor: theme.colorScheme.secondary, // Use dynamic accent
        foregroundColor: ThemeData.estimateBrightnessForColor(theme.colorScheme.secondary) == Brightness.dark 
                            ? AppTheme.fhTextPrimary 
                            : AppTheme.fhBgDark,
      ),
    );
  }
}
--- END OF FILE lib/src/screens/logbook_screen.dart ---

--- START OF FILE lib/src/screens/login_screen.dart ---
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:provider/provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:firebase_auth/firebase_auth.dart'; // Import FirebaseAuthException

class LoginScreen extends StatefulWidget {
  const LoginScreen({super.key});

  @override
  State<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends State<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  String _email = '';
  String _password = '';
  String _username = '';
  bool _isLogin = true;
  bool _isLoading = false;
  String _error = '';
  bool _obscurePassword = true;
  final _usernameController = TextEditingController();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  @override
  void dispose() {
    _usernameController.dispose();
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }
    _formKey.currentState!.save();
    setState(() {
      _isLoading = true;
      _error = '';
    });

    try {
      final gameProvider = Provider.of<GameProvider>(context, listen: false);
      if (_isLogin) {
        await gameProvider.loginUser(_email, _password);
      } else {
        await gameProvider.signupUser(_email, _password, _username);
      }
      // Auth state change will handle navigation in MyApp or GameProvider listener
    } catch (e) {
      // print("[LoginScreen] Auth Error: $e"); // DEBUG
      setState(() {
        if (e is FirebaseAuthException) {
          _error =
              e.message ?? "An unknown Firebase authentication error occurred.";
        } else {
          _error = "An unexpected error occurred. Please try again.";
        }
      });
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: AppTheme.fhBgDark, // Use the new dark background
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child:
              // Add a ConstrainedBox to limit the width for desktop
              ConstrainedBox(
            constraints:
                const BoxConstraints(maxWidth: 400), // Max width of 400 pixels
            child: Card(
              color: AppTheme.fhBgMedium, // Slightly lighter card background
              elevation: 0, // Flatter design
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8.0),
                side: const BorderSide(
                    color: AppTheme.fhBorderColor, width: 1.5), // Themed border
              ),
              child: Padding(
                padding: const EdgeInsets.symmetric(
                    horizontal: 24.0, vertical: 32.0),
                child: Form(
                  key: _formKey,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: <Widget>[
                      Icon(MdiIcons.shieldCrownOutline,
                          size: 56,
                          color: AppTheme.fhAccentTealFixed), // Themed Icon
                      const SizedBox(height: 16),
                      Text(
                        'ARCANE',
                        style: theme.textTheme.displaySmall?.copyWith(
                          // Use displaySmall for prominent title
                          color: AppTheme.fhAccentTealFixed,
                        ),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 8),
                      Text(
                        _isLogin
                            ? 'Secure Login'
                            : 'Create Account', // Updated subtitle
                        style: theme.textTheme.titleMedium?.copyWith(
                          color: AppTheme.fhTextSecondary,
                        ),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 32),
                      if (!_isLogin)
                        Padding(
                          padding: const EdgeInsets.only(bottom: 16.0),
                          child: TextFormField(
                            controller: _usernameController,
                            decoration: InputDecoration(
                              labelText: 'Username',
                              prefixIcon: Icon(MdiIcons.accountOutline,
                                  color: theme
                                      .inputDecorationTheme.labelStyle?.color,
                                  size: 20),
                            ),
                            style: const TextStyle(
                                color: AppTheme.fhTextPrimary,
                                fontFamily: AppTheme.fontBody),
                            validator: (value) {
                              if (value == null || value.trim().isEmpty) {
                                return 'Please enter a username.';
                              }
                              if (value.trim().length < 3) {
                                return 'Username must be at least 3 characters.';
                              }
                              return null;
                            },
                            onSaved: (value) => _username = value!.trim(),
                          ),
                        ),
                      TextFormField(
                        controller: _emailController,
                        decoration: InputDecoration(
                          labelText: 'Email Address',
                          prefixIcon: Icon(MdiIcons.emailOutline,
                              color:
                                  theme.inputDecorationTheme.labelStyle?.color,
                              size: 20),
                        ),
                        keyboardType: TextInputType.emailAddress,
                        style: const TextStyle(
                            color: AppTheme.fhTextPrimary,
                            fontFamily: AppTheme.fontBody),
                        validator: (value) {
                          if (value == null ||
                              value.isEmpty ||
                              !value.contains('@')) {
                            return 'Please enter a valid email.';
                          }
                          return null;
                        },
                        onSaved: (value) => _email = value!,
                      ),
                      const SizedBox(height: 16),
                      TextFormField(
                        controller: _passwordController,
                        decoration: InputDecoration(
                          labelText: 'Password',
                          prefixIcon: Icon(MdiIcons.lockOutline,
                              color:
                                  theme.inputDecorationTheme.labelStyle?.color,
                              size: 20),
                          suffixIcon: IconButton(
                            icon: Icon(
                              _obscurePassword
                                  ? MdiIcons.eyeOutline
                                  : MdiIcons.eyeOffOutline,
                              color:
                                  theme.inputDecorationTheme.labelStyle?.color,
                            ),
                            onPressed: () {
                              setState(() {
                                _obscurePassword = !_obscurePassword;
                              });
                            },
                          ),
                        ),
                        obscureText: _obscurePassword,
                        style: const TextStyle(
                            color: AppTheme.fhTextPrimary,
                            fontFamily: AppTheme.fontBody),
                        validator: (value) {
                          if (value == null ||
                              value.isEmpty ||
                              value.length < 6) {
                            return 'Password must be at least 6 characters long.';
                          }
                          return null;
                        },
                        onSaved: (value) => _password = value!,
                      ),
                      if (_error.isNotEmpty)
                        Padding(
                          padding: const EdgeInsets.only(top: 16.0),
                          child: Text(
                            _error,
                            style: const TextStyle(
                                color: AppTheme.fhAccentRed,
                                fontSize: 12,
                                fontFamily: AppTheme.fontBody),
                            textAlign: TextAlign.center,
                          ),
                        ),
                      const SizedBox(height: 32),
                      if (_isLoading)
                        const CircularProgressIndicator(
                            color: AppTheme.fhAccentTealFixed)
                      else
                        ElevatedButton(
                          onPressed: _submit,
                          style: ElevatedButton.styleFrom(
                            minimumSize: const Size(double.infinity, 48),
                          ),
                          child: Text(_isLogin ? 'LOGIN' : 'SIGN UP'),
                        ),
                      const SizedBox(height: 20),
                      TextButton(
                        onPressed: () {
                          setState(() {
                            _isLogin = !_isLogin;
                            _error = '';
                            _formKey.currentState?.reset();
                            _usernameController.clear();
                            _emailController.clear();
                            _passwordController.clear();
                          });
                        },
                        child: Text(
                          _isLogin
                              ? 'Need an account? Sign Up'
                              : 'Already have an account? Login',
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

--- END OF FILE lib/src/screens/login_screen.dart ---

--- START OF FILE lib/src/screens/settings_screen.dart ---
import 'package:flutter/material.dart';
import 'package:arcane/src/widgets/views/settings_view.dart';
import 'package:arcane/src/theme/app_theme.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('System Configuration'),
        backgroundColor: AppTheme.fhBgMedium, // Match header style
      ),
      body: Center( // Center the content
        child: ConstrainedBox( // Limit width for larger screens
          constraints: const BoxConstraints(maxWidth: 800), 
          child: const SettingsView(),
        ),
      ),
    );
  }
}

--- END OF FILE lib/src/screens/settings_screen.dart ---

--- START OF FILE lib/src/services/ai_service.dart ---
import 'dart:convert';
import 'package:google_generative_ai/google_generative_ai.dart' as genai;
import 'package:arcane/src/config/api_keys.dart'; // Your API keys file
import 'package:flutter/foundation.dart'; // For kDebugMode
import 'package:arcane/src/models/game_models.dart'; // For ChatbotMessage

class AIService {
  Future<Map<String, dynamic>> makeAICall({
    required String prompt,
    required int currentApiKeyIndex,
    required Function(int) onNewApiKeyIndex,
    required Function(String) onLog,
  }) async {
    return await _makeAICall(
        prompt: prompt,
        currentApiKeyIndex: currentApiKeyIndex,
        onNewApiKeyIndex: onNewApiKeyIndex,
        onLog: onLog);
  }

  Future<Map<String, dynamic>> _makeAICall({
    required String prompt,
    required int currentApiKeyIndex,
    required Function(int) onNewApiKeyIndex,
    required Function(String) onLog,
  }) async {
    if (geminiApiKeys.isEmpty ||
        geminiApiKeys.every((key) => key.startsWith('YOUR_GEMINI_API_KEY'))) {
      const errorMsg =
          "No valid Gemini API keys found. Cannot generate content.";
      onLog(// Ensure string is passed
          "<span style=\"color:var(--fh-accent-red);\">Error: AI content generation failed (No API Key or invalid key).</span>");
      throw Exception(errorMsg);
    }
    if (geminiModelName.isEmpty) {
      const errorMsg =
          "GEMINI_MODEL_NAME not configured. Cannot generate content.";
      onLog(// Ensure string is passed
          "<span style=\"color:var(--fh-accent-red);\">Error: AI content generation failed (GEMINI_MODEL_NAME not configured).</span>");
      throw Exception(errorMsg);
    }

    // Log the full prompt in debug mode
    if (kDebugMode) {
      print("[AIService] AI Prompt:\n$prompt");
    }

    for (int i = 0; i < geminiApiKeys.length; i++) {
      final int keyAttemptIndex =
          (currentApiKeyIndex + i) % geminiApiKeys.length;
      final String apiKey = geminiApiKeys[keyAttemptIndex];

      if (apiKey.startsWith('YOUR_GEMINI_API_KEY')) {
        onLog(// Ensure string is passed
            "<span style=\"color:var(--fh-accent-orange);\">Skipping invalid API key at index $keyAttemptIndex.</span>");
        continue;
      }

      try {
        onLog(// Ensure string is passed
            "Trying API key index $keyAttemptIndex for model $geminiModelName...");
        final model =
            genai.GenerativeModel(model: geminiModelName, apiKey: apiKey);
        final response =
            await model.generateContent([genai.Content.text(prompt)]);

        String? rawResponseText = response.text;
        if (rawResponseText == null || rawResponseText.trim().isEmpty) {
          throw Exception("AI response was empty or null.");
        }

        // Log the raw response in debug mode
        if (kDebugMode) {
          print(
              "[AIService] Raw AI Response (Key Index $keyAttemptIndex):\n$rawResponseText");
        }
        onLog("Raw AI Response received. Attempting to parse JSON..."); // Ensure string is passed

        // More robust JSON extraction
        String jsonString = rawResponseText.trim();
        int jsonStart = jsonString.indexOf('{');
        int jsonEnd = jsonString.lastIndexOf('}');

        if (jsonStart != -1 && jsonEnd != -1 && jsonEnd > jsonStart) {
          jsonString = jsonString.substring(jsonStart, jsonEnd + 1);
        } else {
          onLog(// Ensure string is passed
              "<span style=\"color:var(--fh-accent-red);\">Error: Could not find valid JSON object delimiters {{ ... }} in AI response.</span>");
          if (kDebugMode) {
            print(
                "[AIService] Failed to find JSON delimiters. Raw response was: $rawResponseText");
          }
          throw Exception("Could not extract JSON object from AI response.");
        }

        // Attempt to remove common non-JSON prefixes/suffixes if any (like markdown code blocks)
        // This is a secondary check if the above { } extraction wasn't perfect
        if (jsonString.startsWith("```json") && jsonString.endsWith("```")) {
          jsonString = jsonString.substring(7, jsonString.length - 3).trim();
        } else if (jsonString.startsWith("```") && jsonString.endsWith("```")) {
          jsonString = jsonString.substring(3, jsonString.length - 3).trim();
        }

        final Map<String, dynamic> generatedData = jsonDecode(jsonString);
        onNewApiKeyIndex(keyAttemptIndex);
        onLog(// Ensure string is passed
            "<span style=\"color:var(--fh-accent-green);\">Successfully processed AI response with API key index $keyAttemptIndex.</span>");
        return generatedData;
      } catch (e) {
        String errorDetail = e.toString();
        if (e is FormatException) {
          errorDetail =
              "JSON FormatException: ${e.message}. Check AI response for syntax errors (e.g., trailing commas, unquoted keys, incorrect string escapes).";
          if (kDebugMode) {
            print(
                "[AIService] JSON Parsing Error: ${e.message}. Offending JSON string part (approx): ${e.source.toString().substring(0, (e.offset ?? e.source.toString().length).clamp(0, e.source.toString().length)).substring(0, 100)}");
          }
        } else if (errorDetail.contains("API key not valid")) {
          errorDetail = "API key not valid. Please check your configuration.";
        } else if (errorDetail.contains("quota")) {
          errorDetail = "API quota exceeded for this key.";
        } else if (errorDetail
            .contains("Candidate was blocked due to SAFETY")) {
          errorDetail =
              "AI response blocked due to safety settings. Try a different prompt or adjust safety settings if possible.";
        }
        onLog(// Ensure string is passed
            "<span style=\"color:var(--fh-accent-red);\">Error with API key index $keyAttemptIndex: $errorDetail</span>");
        if (i == geminiApiKeys.length - 1) {
          throw Exception("All API keys failed. Last error: $errorDetail");
        }
      }
    }
    const finalErrorMsg = "All API keys failed or were invalid.";
    onLog("<span style=\"color:var(--fh-accent-red);\">$finalErrorMsg</span>"); // Ensure string is passed
    throw Exception(finalErrorMsg);
  }

  Future<Map<String, List<Map<String, dynamic>>>> generateSpecificGameContent({
    required int levelForContent,
    required int currentApiKeyIndex,
    required Function(int) onNewApiKeyIndex,
    required List<String?>
        themes, // Themes for this specific batch, can include null for general
    required Function(String) onLog,
    String? playerStatsString, // New parameter
    String? existingEnemyIdsString,
    String? existingArtifactIdsString,
    String? existingLocationIdsString,
    int numEnemiesToGenerate = 0,
    int numArtifactsPerTheme = 0,
    int numPowerupsPerTheme = 0,
    int numLocationsToGenerate = 0,
    String? specificLocationKeyForEnemies,
  }) async {
    onLog(// Ensure string is passed
        "Attempting to generate specific game content for themes: ${themes.map((t) => t ?? 'General').join(', ')}...");

    String enemyInstructions = "";
    if (numEnemiesToGenerate > 0) {
      enemyInstructions = """
"newEnemies" should be an array of $numEnemiesToGenerate enemy objects.
- Consider these player stats for balancing: ${playerStatsString ?? "Player stats not provided, use general balancing for level $levelForContent."}. Enemies should be challenging but fair.
- Distribute these enemies among the themes [${themes.map((t) => t == null ? "null (general)" : "'$t'").join(', ')}] or focus on "$specificLocationKeyForEnemies" if provided.
Each enemy object must have:
- id: string, unique (e.g., "gen_enemy_lvl${levelForContent}_a2f5")
- name: string (e.g., "Shadow Lurker", "Arcane Golem")
- theme: string or null (one of [${themes.map((t) => t == null ? "null" : "'$t'").join(', ')}])
- locationKey: string (MUST match one of the 'id's from "newGameLocations" if generated, or "$specificLocationKeyForEnemies" if provided, or an existing one if appropriate for theme)
- minPlayerLevel: number (should be $levelForContent or slightly higher, e.g., up to ${levelForContent + 2})
- health: number (range: ${50 + levelForContent * 12} to ${80 + levelForContent * 18})
- attack: number (range: ${8 + (levelForContent * 1.8).floor()} to ${12 + (levelForContent * 2.2).floor()})
- defense: number (range: ${3 + (levelForContent * 0.6).floor()} to ${5 + (levelForContent * 1.1).floor()})
- coinReward: number (range: ${20 + levelForContent * 5} to ${50 + levelForContent * 10})
- xpReward: number (range: ${30 + levelForContent * 8} to ${70 + levelForContent * 15})
- description: string (max 100 chars)
""";
    }

    String artifactInstructions = "";
    if (numArtifactsPerTheme > 0 || numPowerupsPerTheme > 0) {
      artifactInstructions =
          "\"newArtifacts\" should be an array of artifact objects.\n";
      for (String? themeName in themes) {
        String currentThemeNameForPrompt = themeName ?? "general (null theme)";
        if (numArtifactsPerTheme > 0) {
          artifactInstructions += """
  - For the theme "$currentThemeNameForPrompt", generate $numArtifactsPerTheme of 'weapon', $numArtifactsPerTheme of 'armor', and $numArtifactsPerTheme of 'talisman' artifacts.
""";
        }
        if (numPowerupsPerTheme > 0) {
          artifactInstructions += """
  - For the theme "$currentThemeNameForPrompt", generate $numPowerupsPerTheme 'powerup' artifacts.
""";
        }
      }
      artifactInstructions += """
Each artifact object must have:
- id: string, unique (e.g., "gen_art_lvl${levelForContent}_tech_wpn_b3c8")
- name: string
- type: string ['weapon', 'armor', 'talisman', 'powerup']
- theme: string or null (MUST be the theme it was generated for, use null for general items)
- description: string (max 100 chars)
- cost: number (range: ${50 + levelForContent * 10} to ${300 + levelForContent * 25})
- icon: string (a single, relevant emoji)
- For 'weapon', 'armor', 'talisman':
    - baseAtt: number (0 if not applicable)
    - baseRunic: number (0 if not applicable)
    - baseDef: number (0 if not applicable)
    - baseHealth: number (0 if not applicable)
    - baseLuck: number (0-10, integer percentage)
    - baseCooldown: number (0-15, integer percentage)
    - bonusXPMod: number (0.0 to 0.15, decimal for percentage)
    - upgradeBonus: object (e.g., {"att": 2, "luck": 1}). Modest values.
    - maxLevel: number (3, 5, or 7)
- For 'powerup':
    - effectType: string ['direct_damage', 'heal_player']
    - effectValue: number
    - uses: number (typically 1)
    (omit baseStats, upgradeBonus, maxLevel for powerups or set to 0/null)
""";
    }

    String locationInstructions = "";
    if (numLocationsToGenerate > 0) {
      locationInstructions = """
"newGameLocations" should be an array of $numLocationsToGenerate game location objects.
Each location object must have:
- id: string, unique (e.g., "loc_dark_forest", "loc_crystal_caves_$levelForContent")
- name: string (e.g., "Whispering Woods", "Sunken Temple of Eldoria")
- description: string (short, evocative description, max 150 chars)
- minPlayerLevelToUnlock: number (Based on current level. E.g., $levelForContent, ${levelForContent + 2}, etc.)
- iconEmoji: string (a single emoji representing the location, e.g., "🌲", "🏛️", "💎")
- associatedTheme: string or null (e.g., "knowledge", "tech", or null for general, matching one of [${themes.map((t) => t == null ? "null" : "'$t'").join(', ')}])
- bossEnemyIdToUnlockNextLocation: string or null (ID of an enemy generated in "newEnemies" that, when defeated, could unlock another location. Can be null.)
""";
    }

    final String prompt = """
Generate new game content suitable for a player at level $levelForContent in a fantasy RPG.
Focus on generating content ONLY for the following themes (if applicable, or general content if a theme is null/not provided in the list): [${themes.map((t) => t == null ? "null (general)" : "'$t'").join(', ')}].
Provide the output as a single, valid JSON object.
The top-level keys should ONLY be those for which content is requested (e.g., "newEnemies", "newArtifacts", "newGameLocations").
If no enemies are requested for this batch/theme, do not include the "newEnemies" key, and so on.
Ensure there are NO trailing commas in lists or objects. All strings must be properly escaped.

IMPORTANT:
${existingEnemyIdsString != null && existingEnemyIdsString.isNotEmpty ? "- Do NOT generate enemies with IDs from this list: [$existingEnemyIdsString]." : ""}
${existingArtifactIdsString != null && existingArtifactIdsString.isNotEmpty ? "- Do NOT generate artifacts with IDs from this list: [$existingArtifactIdsString]." : ""}
${existingLocationIdsString != null && existingLocationIdsString.isNotEmpty ? "- Do NOT generate locations with IDs from this list: [$existingLocationIdsString]." : ""}
- All generated IDs and names MUST be new and unique.

$locationInstructions
$enemyInstructions
$artifactInstructions

Return ONLY the JSON object.
""";
    try {
      final Map<String, dynamic> rawData = await _makeAICall(
        prompt: prompt,
        currentApiKeyIndex: currentApiKeyIndex,
        onNewApiKeyIndex: onNewApiKeyIndex,
        onLog: onLog,
      );

      final List<Map<String, dynamic>> newEnemies =
          (rawData['newEnemies'] as List?)
                  ?.map((e) => e as Map<String, dynamic>)
                  .toList() ??
              [];
      final List<Map<String, dynamic>> newArtifacts =
          (rawData['newArtifacts'] as List?)
                  ?.map((a) => a as Map<String, dynamic>)
                  .toList() ??
              [];
      final List<Map<String, dynamic>> newGameLocations =
          (rawData['newGameLocations'] as List?)
                  ?.map((loc) => loc as Map<String, dynamic>)
                  .toList() ??
              [];

      onLog(// Ensure string is passed
          "AI content generation successful for this batch. Parsed ${newEnemies.length} enemies, ${newArtifacts.length} artifacts, ${newGameLocations.length} locations.");

      return {
        'newEnemies': newEnemies,
        'newArtifacts': newArtifacts,
        'newGameLocations': newGameLocations
      };
    } catch (e) {
      onLog(// Ensure string is passed
          "<span style=\"color:var(--fh-accent-red);\">AI Call failed for generateSpecificGameContent: ${e.toString()}</span>");
      if (kDebugMode) {
        print("[AIService] generateSpecificGameContent caught error: $e");
      }
      rethrow;
    }
  }

  Future<List<Map<String, dynamic>>> generateAISubquests({
    required String mainTaskName,
    required String mainTaskDescription,
    String? mainTaskTheme,
    required String generationMode,
    required String userInput,
    required int numSubquests,
    required int currentApiKeyIndex,
    required Function(int) onNewApiKeyIndex,
    required Function(String) onLog,
  }) async {
    onLog(// Ensure string is passed
        "Attempting to generate sub-quests for \"$mainTaskName\"... Mode: $generationMode");

    String modeSpecificInstructions = "";
    switch (generationMode) {
      case "book_chapter":
        modeSpecificInstructions = """
The user is providing details about a book chapter. Input: "$userInput"
Break this down into approximately $numSubquests actionable sub-quests.
For each sub-quest, suggest 1-3 smaller, concrete steps (sub-subtasks).
If a step involves reading pages, make it "countable" with "targetCount". E.g., "Read pages 10-25" -> name: "Read pages 10-25", isCountable: true, targetCount: 16.
""";
        break;
      case "text_list":
        modeSpecificInstructions = """
The user provided a hierarchical text list. Top-level items are sub-quests. Indented items are sub-subtasks. Input:
$userInput
Convert top-level items to sub-quests, indented items to sub-subtasks.
If an item mentions quantity (e.g., "3 sets", "10 pages"), make it "countable" and set "targetCount".
""";
        break;
      case "general_plan":
      default:
        modeSpecificInstructions = """
The user provided a general plan. Input: "$userInput"
Break this into approximately $numSubquests logical sub-quests.
For each sub-quest, suggest 1-3 smaller, concrete steps (sub-subtasks).
Make items "countable" with "targetCount" if they imply quantity.
""";
        break;
    }

    final String prompt = """
You are an assistant for a gamified task management app.
Main quest: "$mainTaskName" (Description: "$mainTaskDescription", Theme: "${mainTaskTheme ?? 'General'}").
AI generation mode: "$generationMode".

$modeSpecificInstructions

Provide the output as a single, valid JSON object with one key: "newSubquests".
"newSubquests" should be an array of sub-quest objects (approx $numSubquests). Each sub-quest object MUST have:
- name: string (concise name)
- isCountable: boolean
- targetCount: number (if isCountable, otherwise 0 or 1)
- subSubTasksData: array of sub-subtask objects. Each sub-subtask object must have:
  - name: string (concise name)
  - isCountable: boolean
  - targetCount: number (if isCountable, otherwise 0 or 1)

Example JSON:
{
  "newSubquests": [
    {
      "name": "Understand Chapter 1 Concepts",
      "isCountable": false,
      "targetCount": 0,
      "subSubTasksData": [
        { "name": "Read pages 1-10", "isCountable": true, "targetCount": 10 },
        { "name": "Summarize key points", "isCountable": false, "targetCount": 1 }
      ]
    }
  ]
}
Create actionable, distinct sub-quests and steps. Ensure names are clear.
If user input is vague for $numSubquests, generate fewer, meaningful ones.
Return ONLY the JSON object, no markdown or comments. NO TRAILING COMMAS.
""";
    try {
      final Map<String, dynamic> rawData = await _makeAICall(
        prompt: prompt,
        currentApiKeyIndex: currentApiKeyIndex,
        onNewApiKeyIndex: onNewApiKeyIndex,
        onLog: onLog,
      );
      final List<Map<String, dynamic>> newSubquests =
          (rawData['newSubquests'] as List?)
                  ?.map((sq) => sq as Map<String, dynamic>)
                  .toList() ??
              [];

      // Basic validation
      bool isValid = newSubquests.every((sq) =>
          sq['name'] is String &&
          sq['isCountable'] is bool &&
          sq['targetCount'] is num &&
          sq['subSubTasksData'] is List &&
          (sq['subSubTasksData'] as List).every((sss) =>
              sss['name'] is String &&
              sss['isCountable'] is bool &&
              sss['targetCount'] is num));

      if (!isValid) {
        onLog(// Ensure string is passed
            "<span style=\"color:var(--fh-accent-orange);\">AI subquest response malformed.</span>");
        if (kDebugMode) {
          print("[AIService] Malformed subquest data: $newSubquests");
        }
        throw Exception("AI subquest response malformed.");
      }
      onLog(// Ensure string is passed
          "AI subquest generation successful. Parsed ${newSubquests.length} subquests.");
      return newSubquests;
    } catch (e) {
      onLog(// Ensure string is passed
          "<span style=\"color:var(--fh-accent-red);\">AI Call failed for generateAISubquests: ${e.toString()}</span>");
      if (kDebugMode) {
        print("[AIService] generateAISubquests caught error: $e");
      }
      rethrow;
    }
  }

  Future<String> getChatbotResponse({ 
    required ChatbotMemory memory,
    required String userMessage,
    required String completedByDayJsonLast7Days,
    required String olderDaysSummary,
    required int currentApiKeyIndex,
    required Function(int) onNewApiKeyIndex,
    required Function(String) onLog,
  }) async {
    onLog("Attempting to get chatbot response...");

    final conversationHistoryString = memory.conversationHistory
        .map((msg) => "${msg.sender == MessageSender.user ? 'User' : 'Bot'}: ${msg.text}")
        .join('\n');
    
    final String prompt = """
You are Arcane Advisor, a helpful AI assistant integrated into a gamified task management app.
Your user is interacting with you through a chat interface.

Your knowledge includes:
1.  Conversation History (most recent first):
$conversationHistoryString

2.  User's Logbook Data for the Last 7 Days (JSON format):
```json
$completedByDayJsonLast7Days
```
   (This contains daily 'taskTimes', 'subtasksCompleted', 'checkpointsCompleted', and 'emotionLogs'.)

3.  Summary of Logbook Data Older Than 7 Days:
$olderDaysSummary

4.  User's Explicitly Remembered Items:
${memory.userRememberedItems.isNotEmpty ? memory.userRememberedItems.join('\n') : "Nothing specific noted by the user to remember."}


User's current message: "$userMessage"

Based on all this information, provide a concise, helpful, and encouraging response.
If the user asks to "Remember X", acknowledge it and state that you will remember "X". Do not include "X" in your response beyond the acknowledgement, as the system will store it separately.
If the user asks to "Forget last" or "Forget everything", acknowledge the action. The system handles the memory modification.
If the user asks about their progress, summaries, emotion trends, or checkpoint completions, use the provided information from the JSON data or the older summary.
Keep responses relatively short and conversational.
Do not use markdown in your primary text response.
"""
        .trim();

    if (geminiApiKeys.isEmpty || geminiApiKeys.every((key) => key.startsWith('YOUR_GEMINI_API_KEY'))) {
        const errorMsg = "No valid Gemini API keys found. Chatbot cannot respond.";
        onLog("<span style=\"color:var(--fh-accent-red);\">Error: Chatbot failed (No API Key).</span>");
        return "I'm currently unable to process requests due to a configuration issue. Please check the API keys.";
    }
     if (geminiModelName.isEmpty) {
      const errorMsg ="GEMINI_MODEL_NAME not configured. Chatbot cannot respond.";
      onLog("<span style=\"color:var(--fh-accent-red);\">Error: Chatbot failed (Model Name not configured).</span>");
      return "I'm currently unable to process requests due to a model configuration issue.";
    }

    if (kDebugMode) {
      print("[AIService - Chatbot] Prompt:\n$prompt");
    }

    for (int i = 0; i < geminiApiKeys.length; i++) {
      final int keyAttemptIndex = (currentApiKeyIndex + i) % geminiApiKeys.length;
      final String apiKey = geminiApiKeys[keyAttemptIndex];

      if (apiKey.startsWith('YOUR_GEMINI_API_KEY')) {
        onLog("<span style=\"color:var(--fh-accent-orange);\">Skipping invalid API key for chatbot at index $keyAttemptIndex.</span>");
        continue;
      }

      try {
        onLog("Chatbot trying API key index $keyAttemptIndex for model $geminiModelName...");
        final model = genai.GenerativeModel(model: geminiModelName, apiKey: apiKey);
        final response = await model.generateContent([genai.Content.text(prompt)]);

        String? rawResponseText = response.text;
        if (rawResponseText == null || rawResponseText.trim().isEmpty) {
          throw Exception("Chatbot AI response was empty or null.");
        }

        if (kDebugMode) {
          print("[AIService - Chatbot] Raw AI Response (Key Index $keyAttemptIndex):\n$rawResponseText");
        }
        onLog("<span style=\"color:var(--fh-accent-green);\">Chatbot successfully processed response with API key index $keyAttemptIndex.</span>");
        onNewApiKeyIndex(keyAttemptIndex);
        return rawResponseText.trim(); 

      } catch (e) {
        String errorDetail = e.toString();
         if (e is genai.GenerativeAIException && e.message.contains("USER_LOCATION_INVALID")) {
          errorDetail = "Geographic location restriction. This API key may not be usable in your current region.";
        } else if (errorDetail.contains("API key not valid")) {
          errorDetail = "API key not valid. Please check your configuration.";
        } else if (errorDetail.contains("quota")) {
          errorDetail = "API quota exceeded for this key.";
        } else if (errorDetail.contains("Candidate was blocked due to SAFETY")) {
          errorDetail = "AI response blocked due to safety settings. Try rephrasing.";
        }
        onLog("<span style=\"color:var(--fh-accent-red);\">Chatbot Error with API key index $keyAttemptIndex: $errorDetail</span>");
        if (i == geminiApiKeys.length - 1) {
          return "I'm having trouble connecting to my core functions right now. Please try again later. (Error: $errorDetail)";
        }
      }
    }
    return "I seem to be experiencing technical difficulties. Please check back soon.";
  }

}
--- END OF FILE lib/src/services/ai_service.dart ---

--- START OF FILE lib/src/services/firebase_service.dart ---
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';

// This file primarily exports instances. Initialization happens in main.dart.
// Specific service methods (like wrappers around auth or firestore calls)
// can be added here if desired, but GameProvider will mostly use these directly.

final FirebaseAuth firebaseAuthInstance = FirebaseAuth.instance;
final FirebaseFirestore firestoreInstance = FirebaseFirestore.instance;

// Example of a user helper, though GameProvider will handle most auth state
Stream<User?> get authStateChanges => firebaseAuthInstance.authStateChanges();

Future<User?> signInWithEmail(String email, String password) async {
  try {
    UserCredential userCredential = await firebaseAuthInstance.signInWithEmailAndPassword(
      email: email,
      password: password,
    );
    return userCredential.user;
  } on FirebaseAuthException catch (e) { // Catch specific exception
    print('[FirebaseService] signInWithEmail error: Code: ${e.code}, Message: ${e.message}'); // DEBUG
    rethrow; // Rethrow to be caught by UI or provider
  } catch (e) { // Catch generic errors
    print('[FirebaseService] signInWithEmail generic error: $e'); // DEBUG
    rethrow;
  }
}

Future<User?> signUpWithEmail(String email, String password) async {
  try {
    UserCredential userCredential = await firebaseAuthInstance.createUserWithEmailAndPassword(
      email: email,
      password: password,
    );
    return userCredential.user;
  } on FirebaseAuthException catch (e) { // Catch specific exception
    print('[FirebaseService] signUpWithEmail error: Code: ${e.code}, Message: ${e.message}'); // DEBUG
    rethrow;
  } catch (e) { // Catch generic errors
    print('[FirebaseService] signUpWithEmail generic error: $e'); // DEBUG
    rethrow;
  }
}

Future<void> signOut() async {
  try {
    await firebaseAuthInstance.signOut();
  } on FirebaseAuthException catch (e) {
     print('[FirebaseService] signOut error: Code: ${e.code}, Message: ${e.message}'); // DEBUG
     rethrow;
  } catch (e) {
     print('[FirebaseService] signOut generic error: $e'); // DEBUG
     rethrow;
  }
}

Future<void> changePassword(String newPassword) async {
  User? user = firebaseAuthInstance.currentUser;
  if (user != null) {
    try {
      await user.updatePassword(newPassword);
    } on FirebaseAuthException catch (e) { // Catch specific exception
       print('[FirebaseService] changePassword error: Code: ${e.code}, Message: ${e.message}'); // DEBUG
       rethrow;
    } catch (e) { // Catch generic errors
       print('[FirebaseService] changePassword generic error: $e'); // DEBUG
       rethrow;
    }
  } else {
    throw FirebaseAuthException(message: "No user currently signed in.", code: "no-user");
  }
}
--- END OF FILE lib/src/services/firebase_service.dart ---

--- START OF FILE lib/src/services/storage_service.dart ---
import 'package:cloud_firestore/cloud_firestore.dart';

const String _userCollection = 'users';
const String _userSubcollectionDocId = 'data';
const String _gameStateDocId = 'gameState';

class StorageService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  DocumentReference<Map<String, dynamic>> _userDocRef(String userId) {
    return _firestore
        .collection(_userCollection)
        .doc(userId)
        .collection(_userSubcollectionDocId)
        .doc(_gameStateDocId);
  }

  Future<Map<String, dynamic>?> getUserData(String userId) async {
    if (userId.isEmpty) {
      // print("StorageService Error: userId is required for getUserData.");
      return null;
    }
    try {
      final docSnap = await _userDocRef(userId).get();
      if (docSnap.exists) {
        return docSnap.data();
      } else {
        // print("No game data found for user $userId, will initialize.");
        return null; // Indicates no data, GameProvider will initialize
      }
    } catch (e) {
      // print("Error getting user data from Firestore: $e");
      return null;
    }
  }

  Future<bool> setUserData(String userId, Map<String, dynamic> data) async {
     if (userId.isEmpty) {
      // print("StorageService Error: userId is required for setUserData.");
      return false;
    }
    try {
      await _userDocRef(userId).set(data);
      return true;
    } catch (e) {
      // print("Error setting user data in Firestore: $e");
      return false;
    }
  }

  Future<bool> updateUserData(String userId, Map<String, dynamic> partialData) async {
     if (userId.isEmpty) {
      // print("StorageService Error: userId is required for updateUserData.");
      return false;
    }
    try {
      await _userDocRef(userId).update(partialData);
      return true;
    } catch (e) {
      // print("Error updating user data in Firestore: $e");
      // If the document doesn't exist, update will fail.
      // Consider checking doc existence or using set with merge:true if needed.
      return false;
    }
  }

  Future<bool> deleteUserData(String userId) async {
     if (userId.isEmpty) {
      // print("StorageService Error: userId is required for deleteUserData.");
      return false;
    }
    try {
      await _userDocRef(userId).delete();
      // print("Game data deleted for user $userId.");
      return true;
    } catch (e) {
      // print("Error deleting user data from Firestore: $e");
      return false;
    }
  }
}
--- END OF FILE lib/src/services/storage_service.dart ---

--- START OF FILE lib/src/theme/app_theme.dart ---
import 'package:flutter/material.dart';

class AppTheme {
  // Valorant-inspired color palette (BASE colors)
  static const Color fhBgDeepDark = Color(0xFF0F1923); 
  static const Color fhBgDark = Color(0xFF1A2838); 
  static const Color fhBgMedium = Color(0xFF203040); 
  static const Color fhBgLight = Color(0xFF2C3E50); 
  static const Color fhBorderColor = Color(0xFF384B5F); 

  static const Color fhTextPrimary = Color(0xFFEAEAEA); 
  static const Color fhTextSecondary = Color(0xFFB0B8C0); 
  static const Color fhTextDisabled = Color(0xFF707880);

  // Fixed accents (won't change with task theme)
  static const Color fhAccentRed = Color(0xFFFD4556); // Valorant Red (e.g., for errors, critical actions)
  static const Color fhAccentTealFixed = Color(0xFF00F8F8); 
  static const Color fhAccentTeal = Color(0xFF00F8F8); // Default system teal (can be used if no task color)
  static const Color fhAccentGold = Color(0xFFFFE075); 
  static const Color fhAccentPurple = Color(0xFF8A2BE2); 
  static const Color fhAccentGreen = Color(0xFF4CAF50); 
  static const Color fhAccentOrange = Color(0xFFFF7043); 

  static const String fontDisplay = 'RobotoCondensed'; 
  static const String fontBody = 'OpenSans';

  
  // Method to generate ThemeData with a dynamic primary accent color
  static ThemeData getThemeData({required Color primaryAccent}) {
    final Brightness accentBrightness = ThemeData.estimateBrightnessForColor(primaryAccent);
    final Color onPrimaryAccent = accentBrightness == Brightness.dark ? fhTextPrimary : fhBgDark;

    return ThemeData(
      brightness: Brightness.dark,
      primaryColor: primaryAccent, // Dynamic primary accent
      scaffoldBackgroundColor: fhBgDeepDark,

      colorScheme: ColorScheme.dark(
        primary: primaryAccent, // Dynamic primary accent
        secondary: primaryAccent, // Also use dynamic accent for secondary for consistency
        surface: fhBgDark, 
        error: fhAccentRed,
        onPrimary: onPrimaryAccent, // Text on dynamic primary accent
        onSecondary: onPrimaryAccent, // Text on dynamic secondary accent
        onSurface: fhTextPrimary, 
        onError: fhTextPrimary,
      ),

      fontFamily: fontBody,

      appBarTheme: AppBarTheme(
        backgroundColor: fhBgDark, 
        elevation: 0, 
        centerTitle: true,
        iconTheme: const IconThemeData(color: fhTextSecondary, size: 22),
        titleTextStyle: TextStyle(
          fontFamily: fontDisplay,
          color: fhTextPrimary,
          fontWeight: FontWeight.bold,
          fontSize: 20, 
          letterSpacing: 1.1,
        ),
      ),

      textTheme: TextTheme(
        displayLarge: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontWeight: FontWeight.bold, fontSize: 48, letterSpacing: 1.2),
        displayMedium: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontWeight: FontWeight.bold, fontSize: 36, letterSpacing: 1.1),
        displaySmall: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontWeight: FontWeight.w600, fontSize: 28),
        headlineLarge: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontWeight: FontWeight.bold, fontSize: 22),
        headlineMedium: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontWeight: FontWeight.w600, fontSize: 20),
        headlineSmall: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontWeight: FontWeight.w500, fontSize: 18),
        titleLarge: TextStyle(fontFamily: fontBody, color: fhTextPrimary, fontWeight: FontWeight.bold, fontSize: 16),
        titleMedium: TextStyle(fontFamily: fontBody, color: fhTextPrimary, fontWeight: FontWeight.w500, fontSize: 14),
        titleSmall: TextStyle(fontFamily: fontBody, color: fhTextSecondary, fontSize: 12, fontWeight: FontWeight.w400),
        bodyLarge: TextStyle(fontFamily: fontBody, color: fhTextPrimary, fontSize: 15, height: 1.5),
        bodyMedium: TextStyle(fontFamily: fontBody, color: fhTextSecondary, fontSize: 13, height: 1.4),
        bodySmall: TextStyle(fontFamily: fontBody, color: fhTextSecondary, fontSize: 11, height: 1.3),
        labelLarge: TextStyle(fontFamily: fontBody, color: onPrimaryAccent, fontWeight: FontWeight.bold, letterSpacing: 1, fontSize: 14), 
        labelMedium: TextStyle(fontFamily: fontBody, color: fhTextSecondary, letterSpacing: 0.8, fontSize: 12),
        labelSmall: TextStyle(fontFamily: fontBody, color: fhTextSecondary, letterSpacing: 0.5, fontSize: 10),
      ),

      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: primaryAccent, // Dynamic accent for buttons
          foregroundColor: onPrimaryAccent,
          textStyle: TextStyle(fontFamily: fontBody, fontWeight: FontWeight.bold, fontSize: 14, letterSpacing: 0.8),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4.0)),
          elevation: 2,
        ),
      ),

      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          side: BorderSide(color: primaryAccent, width: 1.5), // Dynamic accent
          foregroundColor: primaryAccent, // Dynamic accent
          textStyle: TextStyle(fontFamily: fontBody, fontWeight: FontWeight.bold, fontSize: 14, letterSpacing: 0.8),
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4.0)),
        ),
      ),

      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: primaryAccent, // Dynamic accent
          textStyle: TextStyle(fontFamily: fontBody, fontSize: 13, fontWeight: FontWeight.w600),
        ),
      ),

      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: fhBgMedium.withOpacity(0.8),
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
        hintStyle: TextStyle(color: fhTextSecondary.withOpacity(0.7), fontFamily: fontBody, fontSize: 13),
        labelStyle: TextStyle(color: fhTextSecondary, fontFamily: fontBody, fontSize: 14),
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(4.0),
          borderSide: const BorderSide(color: fhBorderColor, width: 1.0),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(4.0),
          borderSide: const BorderSide(color: fhBorderColor, width: 1.0),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(4.0),
          borderSide: BorderSide(color: primaryAccent, width: 1.5), // Dynamic accent
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(4.0),
          borderSide: BorderSide(color: fhAccentRed.withOpacity(0.7), width: 1.0),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(4.0),
          borderSide: const BorderSide(color: fhAccentRed, width: 1.5),
        ),
        prefixIconColor: fhTextSecondary,
        suffixIconColor: fhTextSecondary,
      ),

      progressIndicatorTheme: ProgressIndicatorThemeData(
        color: primaryAccent, // Dynamic accent for progress
        linearTrackColor: fhBgMedium,
        circularTrackColor: fhBgMedium,
        linearMinHeight: 5,
      ),

      chipTheme: ChipThemeData(
        backgroundColor: fhBgMedium,
        labelStyle: TextStyle(color: fhTextPrimary, fontFamily: fontBody, fontSize: 11),
        selectedColor: primaryAccent, // Dynamic accent
        secondarySelectedColor: primaryAccent.withOpacity(0.7), // Dynamic accent
        disabledColor: fhBorderColor.withOpacity(0.5),
        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4)),
        side: BorderSide(color: fhBorderColor.withOpacity(0.3)),
      ),

      tabBarTheme: TabBarThemeData(
        labelColor: primaryAccent, // Dynamic accent
        unselectedLabelColor: fhTextSecondary,
        indicator: UnderlineTabIndicator(
          borderSide: BorderSide(color: primaryAccent, width: 2.0), // Dynamic accent
        ),
        labelStyle: TextStyle(fontFamily: fontDisplay, fontWeight: FontWeight.bold, fontSize: 13, letterSpacing: 0.5),
        unselectedLabelStyle: TextStyle(fontFamily: fontDisplay, fontWeight: FontWeight.w500, fontSize: 13, letterSpacing: 0.5),
        indicatorSize: TabBarIndicatorSize.label,
      ),

      iconTheme: const IconThemeData(
        color: fhTextSecondary,
        size: 20,
      ),

      tooltipTheme: TooltipThemeData(
        preferBelow: false,
        textStyle: TextStyle(fontSize: 11, color: fhBgDark, fontFamily: fontBody),
        decoration: BoxDecoration(
          color: fhAccentGold.withOpacity(0.95),
          borderRadius: BorderRadius.circular(4),
        ),
      ),

      dividerTheme: DividerThemeData(
        color: fhBorderColor.withOpacity(0.5),
        thickness: 1,
        space: 1,
      ),

      cardTheme: CardThemeData(
        color: fhBgDark, 
        elevation: 0, 
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(2.0), 
          side: BorderSide(color: fhBorderColor.withOpacity(0.4), width: 1),
        ),
        margin: const EdgeInsets.symmetric(vertical: 6, horizontal: 0),
      ),

      listTileTheme: ListTileThemeData(
        iconColor: fhTextSecondary,
        textColor: fhTextPrimary,
        tileColor: Colors.transparent, 
        selectedTileColor: primaryAccent.withOpacity(0.1), // Dynamic accent
        titleTextStyle: TextStyle(fontFamily: fontBody, fontSize: 14, fontWeight: FontWeight.w500),
        subtitleTextStyle: TextStyle(fontFamily: fontBody, fontSize: 12, color: fhTextSecondary),
        minVerticalPadding: 12,
      ),

      switchTheme: SwitchThemeData(
        thumbColor: WidgetStateProperty.resolveWith<Color?>((Set<WidgetState> states) {
          if (states.contains(WidgetState.selected)) {
            return primaryAccent; // Dynamic accent
          }
          return fhTextSecondary.withOpacity(0.6);
        }),
        trackColor: WidgetStateProperty.resolveWith<Color?>((Set<WidgetState> states) {
          if (states.contains(WidgetState.selected)) {
            return primaryAccent.withOpacity(0.3); // Dynamic accent
          }
          return fhBorderColor.withOpacity(0.3);
        }),
        trackOutlineColor: WidgetStateProperty.all(Colors.transparent),
      ),

      dialogTheme: DialogThemeData(
        backgroundColor: fhBgMedium,
        titleTextStyle: TextStyle(fontFamily: fontDisplay, color: fhTextPrimary, fontSize: 20, fontWeight: FontWeight.w600),
        contentTextStyle: TextStyle(fontFamily: fontBody, color: fhTextPrimary, fontSize: 14),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(4.0)),
        elevation: 5,
      ),
      
      bottomNavigationBarTheme: BottomNavigationBarThemeData(
          backgroundColor: fhBgDeepDark,
          selectedItemColor: primaryAccent, // Dynamic Accent
          unselectedItemColor: fhTextSecondary.withOpacity(0.8),
          selectedLabelStyle: TextStyle(fontSize: 10, fontFamily: fontBody, fontWeight: FontWeight.bold, letterSpacing: 0.5),
          unselectedLabelStyle: TextStyle(fontSize: 10, fontFamily: fontBody, letterSpacing: 0.5),
          type: BottomNavigationBarType.fixed,
          elevation: 0,
      ),
    );
  }
}
--- END OF FILE lib/src/theme/app_theme.dart ---

--- START OF FILE lib/src/utils/constants.dart ---
// lib/src/utils/constants.dart
import 'package:arcane/src/models/game_models.dart'; // For PlayerStat, MainTaskTemplate

// Initial Main Task Templates (Moved from game_models.dart)
List<MainTaskTemplate> initialMainTaskTemplates = [
  MainTaskTemplate(
      id: "build_routine",
      name: "Routine & Reflection",
      description: "Establish routines, track progress, reflect.",
      theme: "order",
      colorHex: "FF4CAF50") // Green
];

Map<String, PlayerStat> basePlayerGameStats = {
  'strength': PlayerStat(
      name: 'STRENGTH',
      value: 10,
      base: 10,
      description: 'Increases physical damage dealt.',
      icon: 'mdi-sword'), // MDI Icon
  'runic': PlayerStat(
      name: 'RUNIC',
      value: 5,
      base: 5,
      description: 'Increases elemental and special attack damage.',
      icon: 'mdi-fire'), // MDI Icon
  'defense': PlayerStat(
      name: 'DEFENSE',
      value: 5,
      base: 5,
      description: 'Reduces all damage taken.',
      icon: 'mdi-shield'), // MDI Icon
  'vitality': PlayerStat(
      name: 'VITALITY',
      value: 100,
      base: 100,
      description: 'Increases maximum Health.',
      icon: 'mdi-heart'), // MDI Icon
  'luck': PlayerStat(
      name: 'LUCK',
      value: 1,
      base: 1,
      description: 'Increases Perk activation, XP, and Coin gains.',
      icon: 'mdi-clover'), // MDI Icon
  'cooldown': PlayerStat(
      name: 'COOLDOWN',
      value: 0,
      base: 0,
      description: 'Reduces recharge time of special abilities.',
      icon: 'mdi-clock-fast'), // MDI Icon
  // bonusXPMod is handled dynamically in GameProvider, not a base displayed stat.
};

// Game constants
// ignore_for_file: constant_identifier_names
const double xpPerLevelBase = 150; // Increased base XP
const double xpLevelMultiplier = 1.22; // Increased multiplier
const double baseMaxPlayerEnergy = 100;
const double playerEnergyPerLevelVitality = 5;
const double energyPerAttack = 10;
const double energyRegenPerMinuteTasked = 2;

const double subtaskCompletionXpBase = 5;
const double subtaskCompletionCoinBase = 2;

const double xpPerMinuteSubtask = 0.2;
const double coinsPerMinuteSubtask = 0.05;
const double xpPerCountUnitSubtask = 0.5;
const double coinsPerCountUnitSubtask = 0.1;

const double subSubtaskCompletionXpBase = 1;
const double subSubtaskCompletionCoinBase = 0.5;

const double xpPerCountUnitSubSubtask = 0.1;
const double coinsPerCountUnitSubSubtask = 0.02;

const double blacksmithUpgradeCostMultiplier = 1.5;
const int dailyTaskGoalMinutes = 15;
const double streakBonusCoins = 10;
const double streakBonusXp = 20;
const double artifactSellPercentage = 0.3;

// Initial Game Locations (Moved from game_models.dart and made part of constants for pre-build)
// AI can add to this list via GameProvider.
List<GameLocation> initialGameLocations = [
  GameLocation(
      id: "loc_dark_forest",
      name: "Dark Forest",
      description: "A menacing forest teeming with shadowy beasts.",
      minPlayerLevelToUnlock: 1,
      iconEmoji: "🌲",
      associatedTheme: "nature",
      bossEnemyIdToUnlockNextLocation: "enemy_forest_guardian"),
  GameLocation(
      id: "loc_ruined_temple",
      name: "Ruined Temple",
      description: "Ancient ruins guarded by forgotten constructs.",
      minPlayerLevelToUnlock: 3,
      iconEmoji: "🏛️",
      associatedTheme: "ancient",
      bossEnemyIdToUnlockNextLocation: "enemy_temple_golem"),
  // AI can generate more, or they can be added here.
];

// Initial Enemy Templates
List<EnemyTemplate> initialEnemyTemplates = [
  EnemyTemplate(
      id: "enemy_goblin_scout",
      name: "Goblin Scout",
      theme: "nature",
      locationKey: "loc_dark_forest",
      minPlayerLevel: 1,
      health: 40,
      attack: 6,
      defense: 2,
      coinReward: 10,
      xpReward: 15,
      description: "A nimble but weak forest scout."),
  EnemyTemplate(
      id: "enemy_forest_spider",
      name: "Giant Forest Spider",
      theme: "nature",
      locationKey: "loc_dark_forest",
      minPlayerLevel: 1,
      health: 60,
      attack: 8,
      defense: 3,
      coinReward: 15,
      xpReward: 25,
      description: "A large, venomous arachnid."),
  EnemyTemplate(
      id: "enemy_forest_guardian",
      name: "Forest Guardian (Boss)",
      theme: "nature",
      locationKey: "loc_dark_forest",
      minPlayerLevel: 2,
      health: 150,
      attack: 12,
      defense: 5,
      coinReward: 50,
      xpReward: 70,
      description: "An ancient protector of the woods."),
  EnemyTemplate(
      id: "enemy_stone_servant",
      name: "Stone Servant",
      theme: "ancient",
      locationKey: "loc_ruined_temple",
      minPlayerLevel: 3,
      health: 80,
      attack: 10,
      defense: 8,
      coinReward: 25,
      xpReward: 40,
      description: "A magically animated stone guard."),
  EnemyTemplate(
      id: "enemy_temple_golem",
      name: "Temple Golem (Boss)",
      theme: "ancient",
      locationKey: "loc_ruined_temple",
      minPlayerLevel: 4,
      health: 200,
      attack: 15,
      defense: 10,
      coinReward: 80,
      xpReward: 100,
      description: "The formidable guardian of the temple's heart."),
];

// Initial Artifact Templates
List<ArtifactTemplate> initialArtifactTemplates = [
  // Weapons
  ArtifactTemplate(
      id: "art_rusty_sword",
      name: "Rusty Sword",
      type: "weapon",
      theme: null,
      description: "A basic, somewhat worn sword.",
      cost: 20,
      icon: "mdi-sword", // Keep as MDI for now
      baseAtt: 2,
      maxLevel: 3,
      upgradeBonus: {"att": 1}),
  ArtifactTemplate(
      id: "art_hunter_bow",
      name: "Hunter's Bow",
      type: "weapon",
      theme: "nature",
      description: "A simple bow, good for hunting.",
      cost: 50,
      icon: "🏹", // Emoji for this one
      baseAtt: 3,
      baseLuck: 1,
      maxLevel: 5,
      upgradeBonus: {"att": 1, "luck": 1}),
  // Armor
  ArtifactTemplate(
      id: "art_leather_jerkin",
      name: "Leather Jerkin",
      type: "armor",
      theme: null,
      description: "Basic leather protection.",
      cost: 30,
      icon: "🛡️", // Emoji
      baseDef: 1,
      baseHealth: 5,
      maxLevel: 3,
      upgradeBonus: {"def": 1, "health": 5}),
  ArtifactTemplate(
      id: "art_iron_greaves",
      name: "Iron Greaves",
      type: "armor",
      theme: "tech",
      description: "Sturdy leg protection.",
      cost: 60,
      icon: "mdi-shoe-sneaker", // MDI
      baseDef: 2,
      baseHealth: 10,
      maxLevel: 5,
      upgradeBonus: {
        "def": 1,
        "health": 8
      }), 
  // Talismans
  ArtifactTemplate(
      id: "art_lucky_clover",
      name: "Lucky Clover",
      type: "talisman",
      theme: "nature",
      description: "Might bring good fortune.",
      cost: 40,
      icon: "🍀", // Emoji
      baseLuck: 2,
      bonusXPMod: 0.02,
      maxLevel: 3,
      upgradeBonus: {"luck": 1, "bonusXPMod": 0}),
  // Powerups
  ArtifactTemplate(
      id: "art_healing_draught",
      name: "Healing Draught",
      type: "powerup",
      theme: null,
      description: "Restores a small amount of health.",
      cost: 25,
      icon: "🧪", // Emoji
      effectType: "heal_player",
      effectValue: 30,
      uses: 1),
];

// Park Management Constants
const double baseMaxParkEnergy = 100; // Player energy also used for park initially
const double parkEnergyRegenPerMinute = 5; // Player energy regen can be used for park tasks
const double fossilExcavationEnergyCost = 10; // Player Energy cost
const double incubationEnergyCost = 25; // Player Energy cost
const double feedDinoEnergyCost = 5; // Player Energy cost
const int enclosureBaseFoodCapacity = 100; // Food units an enclosure's feeder can hold
const int baseIncubationDuration = 5; // Age units for incubation
const int MAX_PARK_RATING_FOR_STARS = 1000; // Max rating for 5-star display
const int SKIP_MINUTE_ENERGY_COST = 10;
const int SKIP_MINUTE_PARK_DOLLAR_BONUS = 50; // Optional: Bonus dollars for skipping


// Initial Dinosaur Species
List<DinosaurSpecies> initialDinosaurSpecies = [
  DinosaurSpecies(
    id: "dino_triceratops",
    name: "Triceratops",
    description: "A large, herbivorous dinosaur known for its three prominent horns and large frill.",
    diet: "herbivore",
    incubationCostDollars: 15000,
    fossilExcavationEnergyCost: 50,
    baseRating: 200,
    comfortThreshold: 0.60, // 60%
    socialNeedsMin: 2,
    socialNeedsMax: 5,
    enclosureSizeNeeds: 10,
    icon: "🦕",
    minPlayerLevelToUnlock: 1,
  ),
  DinosaurSpecies(
    id: "dino_velociraptor",
    name: "Velociraptor",
    description: "A small, agile carnivore known for its intelligence and sickle-shaped claws.",
    diet: "carnivore",
    incubationCostDollars: 25000,
    fossilExcavationEnergyCost: 75,
    baseRating: 350,
    comfortThreshold: 0.50, // 50%
    socialNeedsMin: 3,
    socialNeedsMax: 6,
    enclosureSizeNeeds: 8,
    icon: "🦖",
    minPlayerLevelToUnlock: 3,
  ),
  DinosaurSpecies(
    id: "dino_tyrannosaurus_rex",
    name: "Tyrannosaurus Rex",
    description: "The tyrant lizard king, an apex predator with a fearsome reputation and powerful bite.",
    diet: "carnivore",
    incubationCostDollars: 100000,
    fossilExcavationEnergyCost: 150,
    baseRating: 950,
    comfortThreshold: 0.40, 
    socialNeedsMin: 1,
    socialNeedsMax: 2,
    enclosureSizeNeeds: 25,
    icon: "🦖",
    minPlayerLevelToUnlock: 15,
  ),
  DinosaurSpecies(
    id: "dino_brachiosaurus",
    name: "Brachiosaurus",
    description: "A colossal long-necked herbivore, one of the tallest dinosaurs to have ever lived.",
    diet: "herbivore",
    incubationCostDollars: 75000,
    fossilExcavationEnergyCost: 120,
    baseRating: 700,
    comfortThreshold: 0.65,
    socialNeedsMin: 1,
    socialNeedsMax: 3,
    enclosureSizeNeeds: 30, 
    icon: "🦕",
    minPlayerLevelToUnlock: 12,
  ),
  DinosaurSpecies(
    id: "dino_parasaurolophus",
    name: "Parasaurolophus",
    description: "A hadrosaur known for the distinctive cranial crest, likely used for display and communication.",
    diet: "herbivore",
    incubationCostDollars: 12000,
    fossilExcavationEnergyCost: 45,
    baseRating: 180,
    comfortThreshold: 0.70,
    socialNeedsMin: 3,
    socialNeedsMax: 10,
    enclosureSizeNeeds: 12,
    icon: "🦕",
    minPlayerLevelToUnlock: 5,
  ),
  DinosaurSpecies(
    id: "dino_gallimimus",
    name: "Gallimimus",
    description: "A fast, ostrich-like dinosaur that likely lived in flocks and foraged for small animals and plants.",
    diet: "omnivore", 
    incubationCostDollars: 8000,
    fossilExcavationEnergyCost: 30,
    baseRating: 120,
    comfortThreshold: 0.75, 
    socialNeedsMin: 5,
    socialNeedsMax: 15,
    enclosureSizeNeeds: 15, 
    icon: "🦕",
    minPlayerLevelToUnlock: 2,
  ),
  DinosaurSpecies(
    id: "dino_dilophosaurus",
    name: "Dilophosaurus",
    description: "A medium-sized carnivore with twin crests, known for its frill and venomous spit (in JP lore).",
    diet: "carnivore",
    incubationCostDollars: 18000,
    fossilExcavationEnergyCost: 60,
    baseRating: 280,
    comfortThreshold: 0.55,
    socialNeedsMin: 1,
    socialNeedsMax: 3,
    enclosureSizeNeeds: 9,
    icon: "🦖",
    minPlayerLevelToUnlock: 7,
  ),
  DinosaurSpecies(
    id: "dino_stegosaurus",
    name: "Stegosaurus",
    description: "A large herbivore easily recognized by the double row of kite-shaped plates along its back and tail spikes (thagomizer).",
    diet: "herbivore",
    incubationCostDollars: 20000,
    fossilExcavationEnergyCost: 65,
    baseRating: 250,
    comfortThreshold: 0.60,
    socialNeedsMin: 2,
    socialNeedsMax: 6,
    enclosureSizeNeeds: 14,
    icon: "🦕",
    minPlayerLevelToUnlock: 8,
  ),
  DinosaurSpecies(
    id: "dino_compsognathus",
    name: "Compsognathus",
    description: "A small, bipedal carnivore, often hunting in packs to overwhelm small prey.",
    diet: "carnivore",
    incubationCostDollars: 5000,
    fossilExcavationEnergyCost: 20,
    baseRating: 50, 
    comfortThreshold: 0.60,
    socialNeedsMin: 5,
    socialNeedsMax: 20,
    enclosureSizeNeeds: 5,
    icon: "🦖",
    minPlayerLevelToUnlock: 1,
  ),
  DinosaurSpecies(
    id: "dino_pteranodon", 
    name: "Pteranodon",
    description: "A large flying reptile (pterosaur) with a distinctive cranial crest and a leathery wingspan.",
    diet: "piscivore",
    incubationCostDollars: 30000,
    fossilExcavationEnergyCost: 80,
    baseRating: 400,
    comfortThreshold: 0.50,
    socialNeedsMin: 2,
    socialNeedsMax: 8,
    enclosureSizeNeeds: 18, 
    icon: "🐉", 
    minPlayerLevelToUnlock: 10,
  ),
  DinosaurSpecies(
    id: "dino_metriacanthosaurus",
    name: "Metriacanthosaurus",
    description: "A medium-to-large-sized theropod dinosaur from the Middle Jurassic period.",
    diet: "carnivore",
    incubationCostDollars: 35000,
    fossilExcavationEnergyCost: 90,
    baseRating: 450,
    comfortThreshold: 0.50,
    socialNeedsMin: 1,
    socialNeedsMax: 2,
    enclosureSizeNeeds: 16,
    icon: "🦖",
    minPlayerLevelToUnlock: 9,
  ),
  DinosaurSpecies(
    id: "dino_proceratosaurus",
    name: "Proceratosaurus",
    description: "An early, small-sized tyrannosauroid with a distinctive nasal crest.",
    diet: "carnivore",
    incubationCostDollars: 10000,
    fossilExcavationEnergyCost: 40,
    baseRating: 150,
    comfortThreshold: 0.65,
    socialNeedsMin: 2,
    socialNeedsMax: 5,
    enclosureSizeNeeds: 7,
    icon: "🦖",
    minPlayerLevelToUnlock: 4,
  ),
  DinosaurSpecies(
    id: "dino_herrerasaurus",
    name: "Herrerasaurus",
    description: "One of the earliest known dinosaurs, a bipedal carnivore from the Late Triassic period.",
    diet: "carnivore",
    incubationCostDollars: 16000,
    fossilExcavationEnergyCost: 55,
    baseRating: 220,
    comfortThreshold: 0.58,
    socialNeedsMin: 1,
    socialNeedsMax: 3,
    enclosureSizeNeeds: 10,
    icon: "🦖",
    minPlayerLevelToUnlock: 6,
  ),
  DinosaurSpecies(
    id: "dino_segisaurus",
    name: "Segisaurus",
    description: "A small, agile coelophysoid theropod known from a single incomplete fossil.",
    diet: "carnivore", 
    incubationCostDollars: 7000,
    fossilExcavationEnergyCost: 25,
    baseRating: 90,
    comfortThreshold: 0.70,
    socialNeedsMin: 2,
    socialNeedsMax: 7,
    enclosureSizeNeeds: 6,
    icon: "🦖",
    minPlayerLevelToUnlock: 2,
  ),
  DinosaurSpecies(
    id: "dino_baryonyx",
    name: "Baryonyx",
    description: "A large spinosaurid dinosaur with distinctive, large claws and a long, crocodile-like snout, adapted for catching fish.",
    diet: "piscivore",
    incubationCostDollars: 40000,
    fossilExcavationEnergyCost: 100,
    baseRating: 500,
    comfortThreshold: 0.50,
    socialNeedsMin: 1,
    socialNeedsMax: 2,
    enclosureSizeNeeds: 17, 
    icon: "🦖",
    minPlayerLevelToUnlock: 11,
  ),
  DinosaurSpecies(
    id: "dino_ankylosaurus", 
    name: "Ankylosaurus",
    description: "A heavily armored herbivore with a massive club-like tail, offering formidable defense.",
    diet: "herbivore",
    incubationCostDollars: 22000,
    fossilExcavationEnergyCost: 70,
    baseRating: 300,
    comfortThreshold: 0.55, 
    socialNeedsMin: 1,
    socialNeedsMax: 3,
    enclosureSizeNeeds: 15,
    icon: "🦕",
    minPlayerLevelToUnlock: 14,
  ),
];

// Initial Building Templates
List<BuildingTemplate> initialBuildingTemplates = [
  BuildingTemplate(
    id: "bldg_small_herb_enclosure",
    name: "Small Herbivore Paddock",
    type: "enclosure",
    costDollars: 10000,
    icon: "mdi-fence",
    capacity: 5, 
    operationalCostPerMinuteDollars: 100,
    parkRatingBoost: 50,
    sizeX: 3, sizeY: 3,
    powerRequired: 5, // Example power requirement
  ),
    BuildingTemplate(
    id: "bldg_small_carn_enclosure",
    name: "Small Carnivore Paddock",
    type: "enclosure",
    costDollars: 15000, 
    icon: "mdi-gate-alert",
    capacity: 3, 
    operationalCostPerMinuteDollars: 200,
    parkRatingBoost: 70,
    sizeX: 3, sizeY: 3,
    powerRequired: 7, // Example power requirement
  ),
  BuildingTemplate(
    id: "bldg_fossil_center",
    name: "Fossil Center",
    type: "fossil_center",
    costDollars: 20000,
    icon: "mdi-bone",
    operationalCostPerMinuteDollars: 500,
    parkRatingBoost: 20,
    sizeX: 2, sizeY: 2,
    powerRequired: 15,
  ),
  BuildingTemplate(
    id: "bldg_hatchery",
    name: "Hammond Creation Lab",
    type: "hatchery",
    costDollars: 30000,
    icon: "mdi-egg-outline",
    capacity: 1, 
    operationalCostPerMinuteDollars: 1000,
    parkRatingBoost: 30,
    sizeX: 2, sizeY: 3,
    powerRequired: 25,
  ),
   BuildingTemplate(
    id: "bldg_visitor_center",
    name: "Visitor Center",
    type: "visitor_center",
    costDollars: 30000,
    icon: "mdi-office-building",
    operationalCostPerMinuteDollars: 300,
    incomePerMinuteDollars: 1000, 
    parkRatingBoost: 100,
    sizeX: 2, sizeY: 2,
    powerRequired: 10, // Visitor centers also need some power
  ),
  BuildingTemplate(
    id: "bldg_food_station_herb",
    name: "Herbivore Feeder",
    type: "food_station",
    costDollars: 5000,
    icon: "mdi-food-apple-outline",
    capacity: enclosureBaseFoodCapacity, 
    operationalCostPerMinuteDollars: 50,
    sizeX: 1, sizeY: 1,
    powerRequired: 2,
  ),
  BuildingTemplate(
    id: "bldg_food_station_carn",
    name: "Carnivore Feeder",
    type: "food_station",
    costDollars: 7500,
    icon: "mdi-food-steak",
    capacity: enclosureBaseFoodCapacity, 
    operationalCostPerMinuteDollars: 100,
    sizeX: 1, sizeY: 1,
    powerRequired: 3,
  ),
  BuildingTemplate(
    id: "bldg_research_outpost",
    name: "Research Outpost",
    type: "research_outpost",
    costDollars: 25000,
    icon: "mdi-flask-outline",
    operationalCostPerMinuteDollars: 750,
    parkRatingBoost: 40,
    sizeX: 2, sizeY: 2,
    powerRequired: 20,
  ),
   BuildingTemplate(
    id: "bldg_gift_shop",
    name: "Gift Shop",
    type: "amenity_shop",
    costDollars: 20000,
    icon: "mdi-gift-outline",
    operationalCostPerMinuteDollars: 200,
    incomePerMinuteDollars: 1500,
    parkRatingBoost: 30,
    sizeX: 1, sizeY: 2,
    powerRequired: 5,
  ),
  BuildingTemplate(
    id: "bldg_power_plant_small",
    name: "Small Power Plant",
    type: "power_plant",
    costDollars: 30000,
    icon: "mdi-transmission-tower",
    operationalCostPerMinuteDollars: 1200,
    parkRatingBoost: 10,
    sizeX: 3, sizeY: 2,
    powerOutput: 100, // Generates 100 power units
    powerRequired: 0, // Power plants don't consume their own type of power
  ),
];
--- END OF FILE lib/src/utils/constants.dart ---

--- START OF FILE lib/src/utils/helpers.dart ---
import 'package:intl/intl.dart';

String getTodayDateString() {
  return DateFormat('yyyy-MM-dd').format(DateTime.now());
}

String romanize(int num) {
  if (num.isNaN || num == 0) return "0";
  if (num > 3999 || num < 1) return num.toString(); // Simplified for typical game levels

  const List<String> rnOnes = ["", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"];
  const List<String> rnTens = ["", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"];
  const List<String> rnHundreds = ["", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"];
  const List<String> rnThousands = ["", "M", "MM", "MMM"];

  String thousands = rnThousands[(num / 1000).floor()];
  String hundreds = rnHundreds[((num % 1000) / 100).floor()];
  String tens = rnTens[((num % 100) / 10).floor()];
  String ones = rnOnes[num % 10];

  return thousands + hundreds + tens + ones;
}

double xpForLevel(int level, double xpPerLevelBase, double xpLevelMultiplier) {
  if (level <= 1) return 0;
  double totalXp = 0;
  for (int i = 1; i < level; i++) {
    totalXp += (xpPerLevelBase * (xpLevelMultiplierPow(xpLevelMultiplier, i - 1))).floor();
  }
  return totalXp;
}

double xpToNext(int currentLevel, double xpPerLevelBase, double xpLevelMultiplier) {
  return (xpPerLevelBase * (xpLevelMultiplierPow(xpLevelMultiplier, currentLevel - 1))).floorToDouble();
}

// Custom power function to avoid dart:math for simple integer powers
// ignore_for_file: non_constant_identifier_names
double xpLevelMultiplierPow(double base, int exponent) {
  double result = 1.0;
  for (int i = 0; i < exponent; i++) {
    result *= base;
  }
  return result;
}

String formatTime(double totalSeconds) {
  int hours = (totalSeconds / 3600).floor();
  int minutes = ((totalSeconds % 3600) / 60).floor();
  int seconds = (totalSeconds % 60).floor();

  String paddedHours = hours.toString().padLeft(2, '0');
  String paddedMinutes = minutes.toString().padLeft(2, '0');
  String paddedSeconds = seconds.toString().padLeft(2, '0');

  if (hours > 0) {
    return "$paddedHours:$paddedMinutes:$paddedSeconds";
  }
  return "$paddedMinutes:$paddedSeconds";
}

--- END OF FILE lib/src/utils/helpers.dart ---

--- START OF FILE lib/src/widgets/header_widget.dart ---
// lib/src/widgets/header_widget.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/screens/logbook_screen.dart';
import 'package:arcane/src/screens/settings_screen.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class HeaderWidget extends StatelessWidget {
  final String currentViewLabel;
  const HeaderWidget({super.key, required this.currentViewLabel});

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    final screenWidth = MediaQuery.of(context).size.width;
    final bool isSmallScreen = screenWidth < 900; // Match HomeScreen breakpoint
    final Color currentAccentColor =
        gameProvider.getSelectedTask()?.taskColor ??
            theme.colorScheme.secondary;

    return Container(
      color: Colors.transparent,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            height: kToolbarHeight,
            padding: const EdgeInsets.symmetric(horizontal: 8.0),
            child: Row(
              children: <Widget>[
                if (isSmallScreen)
                  IconButton(
                    icon: Icon(MdiIcons.formatListChecks,
                        color: AppTheme.fhTextSecondary),
                    onPressed: () {
                       FocusScope.of(context).unfocus(); // Unfocus before opening drawer
                       Scaffold.of(context).openDrawer();
                    },
                    tooltip: 'Missions',
                  ),
                if (!isSmallScreen)
                  Icon(MdiIcons.shieldCrownOutline,
                      color: currentAccentColor, size: 32),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    currentViewLabel.toUpperCase(),
                    style: theme.textTheme.headlineSmall?.copyWith(
                      color: AppTheme.fhTextPrimary,
                      letterSpacing: 1.0,
                    ),
                    textAlign:
                        isSmallScreen ? TextAlign.start : TextAlign.center,
                  ),
                ),
                IconButton(
                  icon: Icon(MdiIcons.bookOpenVariant,
                      color: AppTheme.fhTextSecondary),
                  onPressed: () {
                    FocusScope.of(context).unfocus(); // Unfocus before navigation
                    Navigator.push(
                        context,
                        MaterialPageRoute(
                            builder: (context) => const LogbookScreen()));
                  },
                  tooltip: 'Logbook',
                ),
                IconButton(
                  icon: Icon(MdiIcons.cogOutline,
                      color: AppTheme.fhTextSecondary),
                  onPressed: () {
                    FocusScope.of(context).unfocus(); // Unfocus before navigation
                    Navigator.push(
                        context,
                        MaterialPageRoute(
                            builder: (context) => const SettingsScreen()));
                  },
                  tooltip: 'Settings',
                ),
                if (isSmallScreen)
                  IconButton(
                    icon: Icon(MdiIcons.accountCircleOutline,
                        color: AppTheme.fhTextSecondary),
                    onPressed: () {
                      FocusScope.of(context).unfocus(); // Unfocus before opening drawer
                      Scaffold.of(context).openEndDrawer();
                    },
                    tooltip: 'Profile & Stats',
                  ),
              ],
            ),
          ),
          // Stats Row
          Container(
            padding:
                const EdgeInsets.symmetric(horizontal: 16.0, vertical: 6.0),
            decoration: BoxDecoration(
                color: AppTheme.fhBgDark.withOpacity(0.5),
                border: Border(
                    bottom: BorderSide(
                        color: AppTheme.fhBorderColor.withOpacity(0.3),
                        width: 1))),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                _buildStatChip(
                  theme,
                  icon: MdiIcons.circleMultipleOutline, // Coins
                  value: gameProvider.coins.toStringAsFixed(0),
                  color: AppTheme.fhAccentGold,
                ),
                const SizedBox(width: 20),
                _buildStatChip(
                  theme,
                  icon: MdiIcons.flashOutline, // Energy
                  value:
                      '${gameProvider.playerEnergy.toStringAsFixed(0)}/${gameProvider.calculatedMaxEnergy.toStringAsFixed(0)}',
                  color: gameProvider.getSelectedTask()?.taskColor ??
                      AppTheme
                          .fhAccentTealFixed, // Retain teal for energy as it's distinct
                ),
                const SizedBox(width: 20),
                _buildStatChip(
                  theme,
                  icon: MdiIcons.starShootingOutline, // XP Level
                  value:
                      'Lvl ${gameProvider.romanize(gameProvider.playerLevel)}',
                  color: currentAccentColor, // Use dynamic accent
                ),
                const SizedBox(width: 4),
                Expanded(
                  child: SizedBox(
                    height: 6,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(3),
                      child: LinearProgressIndicator(
                        value: (gameProvider.xpProgressPercent / 100)
                            .clamp(0.0, 1.0),
                        backgroundColor:
                            AppTheme.fhBorderColor.withOpacity(0.2),
                        valueColor: AlwaysStoppedAnimation<Color>(
                            currentAccentColor.withOpacity(0.7)),
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatChip(ThemeData theme,
      {required IconData icon, required String value, required Color color}) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(icon, color: color, size: 16),
        const SizedBox(width: 6),
        Text(
          value,
          style: theme.textTheme.labelMedium?.copyWith(
              color: AppTheme.fhTextPrimary,
              fontWeight: FontWeight.w600,
              fontSize: 13),
        ),
      ],
    );
  }
}

--- END OF FILE lib/src/widgets/header_widget.dart ---

--- START OF FILE lib/src/widgets/left_panel_widget.dart ---
// lib/src/widgets/left_panel_widget.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart'; // For theme icons

class LeftPanelWidget extends StatelessWidget {
  const LeftPanelWidget({super.key});

  IconData _getThemeIcon(String? theme) {
    switch (theme) {
      case 'tech':
        return MdiIcons.memory;
      case 'knowledge':
        return MdiIcons.bookOpenPageVariantOutline;
      case 'learning':
        return MdiIcons.lightbulbOutline;
      case 'discipline':
        return MdiIcons.karate;
      case 'order':
        return MdiIcons.playlistCheck;
      default:
        return MdiIcons.briefcaseOutline;
    }
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    final isMobile = MediaQuery.of(context).size.width <
        768; // Adjusted to match HomeScreen's desktop breakpoint logic

    // print("[LeftPanelWidget] Building LeftPanelWidget. Mobile: $isMobile"); // DEBUG

    // Mobile view now primarily driven by HomeScreen's SingleChildScrollView
    // Desktop View is also effectively mobile now due to HomeScreen changes.
    // So, we can unify the logic more or keep the structure for potential future re-differentiation.
    // For now, we'll keep the isMobile check but ensure it works within a scrollable context.

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Row(
              children: [
                Icon(MdiIcons.swordCross,
                    color: gameProvider.getSelectedTask()?.taskColor ??
                        AppTheme.fhAccentTealFixed,
                    size: isMobile ? 24 : 28),
                const SizedBox(width: 8),
                Text('Quests',
                    style: isMobile
                        ? theme.textTheme.titleLarge
                        : theme.textTheme.headlineSmall
                            ?.copyWith(fontFamily: AppTheme.fontDisplay)),
              ],
            ),
            const Divider(height: 16),
            if (gameProvider.mainTasks.isEmpty)
              const Padding(
                padding: EdgeInsets.symmetric(vertical: 20.0),
                child: Center(
                    child: Text('No quests available.',
                        style: TextStyle(
                            color: AppTheme.fhTextSecondary,
                            fontStyle: FontStyle.italic))),
              )
            else if (isMobile) // Horizontal scroll for icons on mobile
              SizedBox(
                height: 60,
                child: ListView.builder(
                  scrollDirection: Axis.horizontal,
                  itemCount: gameProvider.mainTasks.length,
                  itemBuilder: (ctx, index) {
                    final task = gameProvider.mainTasks[index];
                    final isSelected = gameProvider.selectedTaskId == task.id;
                    return Tooltip(
                      message: task.name,
                      child: Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 4.0),
                        child: InkWell(
                          onTap: () {
                            gameProvider.setSelectedTaskId(task.id);
                            gameProvider.setCurrentView('task-details');
                          },
                          borderRadius: BorderRadius.circular(8),
                          child: Container(
                            width: 48,
                            height: 48,
                            decoration: BoxDecoration(
                              color: isSelected
                                  ? (gameProvider
                                          .getSelectedTask()
                                          ?.taskColor ??
                                      AppTheme.fhAccentTealFixed)
                                  : AppTheme.fhBgLight,
                              border: Border.all(
                                color: isSelected
                                    ? (gameProvider
                                            .getSelectedTask()
                                            ?.taskColor ??
                                        AppTheme.fhAccentTealFixed)
                                    : AppTheme.fhBorderColor,
                                width: 2,
                              ),
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Icon(
                              _getThemeIcon(task.theme),
                              color: isSelected
                                  ? Colors.white
                                  : AppTheme.fhTextSecondary,
                              size: 24,
                            ),
                          ),
                        ),
                      ),
                    );
                  },
                ),
              )
            else // Vertical list for larger screens (now also part of SingleChildScrollView)
              ListView.builder(
                shrinkWrap: true, // Important for ListView in Column
                physics: const NeverScrollableScrollPhysics(), // Parent scrolls
                itemCount: gameProvider.mainTasks.length,
                itemBuilder: (context, index) {
                  final task = gameProvider.mainTasks[index];
                  final isSelected = gameProvider.selectedTaskId == task.id;
                  return Card(
                    elevation: isSelected ? 2 : 0,
                    margin: const EdgeInsets.only(bottom: 8.0),
                    color: isSelected
                        ? (gameProvider.getSelectedTask()?.taskColor ??
                                AppTheme.fhAccentTealFixed)
                            .withOpacity(0.2)
                        : AppTheme.fhBgLight,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(6.0),
                      side: BorderSide(
                        color: isSelected
                            ? (gameProvider.getSelectedTask()?.taskColor ??
                                AppTheme.fhAccentTealFixed)
                            : Colors.transparent,
                        width: 2,
                      ),
                    ),
                    child: ListTile(
                      leading: Icon(
                        _getThemeIcon(task.theme),
                        color: isSelected
                            ? (gameProvider.getSelectedTask()?.taskColor ??
                                AppTheme.fhAccentTealFixed)
                            : AppTheme.fhTextSecondary,
                        size: 22,
                      ),
                      title: Text(
                        task.name,
                        style: theme.textTheme.titleMedium?.copyWith(
                          color: isSelected
                              ? AppTheme.fhTextPrimary
                              : AppTheme.fhTextPrimary,
                          fontWeight:
                              isSelected ? FontWeight.bold : FontWeight.normal,
                          fontSize: 15,
                        ),
                        overflow: TextOverflow.ellipsis,
                      ),
                      trailing: Chip(
                        label: Text('🔥${task.streak}'),
                        backgroundColor: Colors.transparent,
                        labelStyle: TextStyle(
                          color: isSelected
                              ? AppTheme.fhTextPrimary
                              : AppTheme.fhAccentOrange,
                          fontWeight: FontWeight.bold,
                          fontSize: 13,
                        ),
                        padding: const EdgeInsets.symmetric(
                            horizontal: 6, vertical: 2),
                        visualDensity: VisualDensity.compact,
                      ),
                      selected: isSelected,
                      onTap: () {
                        gameProvider.setSelectedTaskId(task.id);
                        gameProvider.setCurrentView('task-details');
                      },
                      selectedTileColor:
                          (gameProvider.getSelectedTask()?.taskColor ??
                                  AppTheme.fhAccentTealFixed)
                              .withOpacity(0.15),
                      contentPadding: const EdgeInsets.symmetric(
                          horizontal: 12, vertical: 4),
                    ),
                  );
                },
              ),
            if (isMobile &&
                gameProvider.selectedTaskId != null &&
                gameProvider.mainTasks.isNotEmpty) ...[
              const Divider(height: 16),
              Text(
                gameProvider.getSelectedTask()?.name ?? 'Select a Quest',
                style: theme.textTheme.bodyMedium?.copyWith(
                    fontWeight: FontWeight.bold, color: AppTheme.fhTextPrimary),
                textAlign: TextAlign.center,
                overflow: TextOverflow.ellipsis,
              ),
              Text(
                '🔥 Streak: ${gameProvider.getSelectedTask()?.streak ?? 0}',
                style: theme.textTheme.bodyMedium?.copyWith(
                    color: AppTheme.fhAccentOrange,
                    fontWeight: FontWeight.bold),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/left_panel_widget.dart ---

--- START OF FILE lib/src/widgets/middle_panel_widget.dart ---
// lib/src/widgets/middle_panel_widget.dart
import 'package:flutter/material.dart';

class MiddlePanelWidget extends StatelessWidget {
  final int selectedIndex;
  final List<Widget> views;

  const MiddlePanelWidget({
    super.key,
    required this.selectedIndex,
    required this.views,
  });

  @override
  Widget build(BuildContext context) {
    print("[MiddlePanelWidget] Building. SelectedIndex: $selectedIndex");

    // Define a maximum width for the content
    const double maxWidth = 600.0; // Slightly wider for better viewability

    return Padding(
      padding: const EdgeInsets.fromLTRB(0, 8, 0, 0),
      child: Center( // Center the content horizontally
        child: ConstrainedBox( // Apply maxWidth
          constraints: const BoxConstraints(maxWidth: maxWidth),
          child: IndexedStack(
            index: selectedIndex,
            children: views.map((view) {
              // Wrap each view in a SingleChildScrollView and KeepAliveWrapper
              return KeepAliveWrapper(
                child: SingleChildScrollView(
                  padding: const EdgeInsets.symmetric(horizontal: 4.0, vertical: 8.0),
                  child: view,
                ),
              );
            }).toList(),
          ),
        ),
      ),
    );
  }
}

// Helper widget to keep state in IndexedStack (similar to TabBarView's needs)
class KeepAliveWrapper extends StatefulWidget {
  final Widget child;
  const KeepAliveWrapper({super.key, required this.child});

  @override
  State<KeepAliveWrapper> createState() => _KeepAliveWrapperState();
}

class _KeepAliveWrapperState extends State<KeepAliveWrapper> with AutomaticKeepAliveClientMixin {
  @override
  Widget build(BuildContext context) {
    super.build(context); // Important to call super.build
    return widget.child;
  }

  @override
  bool get wantKeepAlive => true;
}
--- END OF FILE lib/src/widgets/middle_panel_widget.dart ---

--- START OF FILE lib/src/widgets/player_stats_drawer.dart ---
// lib/src/widgets/player_stats_drawer.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
// import 'package:arcane/src/utils/constants.dart'; // No longer needed for basePlayerGameStats

class PlayerStatsDrawer extends StatelessWidget {
  const PlayerStatsDrawer({super.key});

  Widget _buildStatDisplay(BuildContext context, String icon, String name,
      String value, // Changed iconEmoji to icon (MDI name or emoji string)
      {String? buffValue,
      Color? buffColor,
      String? description,
      double? progressPercent}) {
    final theme = Theme.of(context);
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    Widget iconWidget;
    if (icon.length == 1 || icon.length == 2) {
      // Assume emoji if 1 or 2 chars
      iconWidget = Text(icon,
          style: TextStyle(
              fontSize: 20,
              color: (gameProvider.getSelectedTask()?.taskColor ??
                      AppTheme.fhAccentTealFixed)
                  .withOpacity(0.9)));
    } else {
      // Assume MDI icon name if longer
      final iconData = MdiIcons.fromString(icon.replaceAll('mdi-', '')) ??
          MdiIcons.helpCircleOutline;
      iconWidget = Icon(iconData,
          size: 20,
          color: (gameProvider.getSelectedTask()?.taskColor ??
                  AppTheme.fhAccentTealFixed)
              .withOpacity(0.9));
    }

    // Valorant style stat display
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 6.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              iconWidget, // Use the determined icon widget
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  name.toUpperCase(),
                  style: theme.textTheme.labelMedium?.copyWith(
                      color: AppTheme.fhTextSecondary,
                      fontWeight: FontWeight.w600, // Bolder label
                      letterSpacing: 1),
                ),
              ),
              if (buffValue != null)
                Text(
                  buffValue,
                  style: theme.textTheme.labelSmall?.copyWith(
                      color: buffColor,
                      fontWeight: FontWeight.bold,
                      fontSize: 12), // Larger buff text
                ),
              const SizedBox(width: 6),
              Text(
                value,
                style: theme.textTheme.bodyLarge?.copyWith(
                    // Use bodyLarge for stat value
                    color: AppTheme.fhTextPrimary,
                    fontWeight: FontWeight.bold),
              ),
            ],
          ),
          if (progressPercent != null &&
              name.toUpperCase() != 'VITALITY' &&
              name.toUpperCase() != 'XP CALC MOD') // Updated condition
            Padding(
              padding: const EdgeInsets.only(
                  top: 5.0, left: 32 + 12), // Align with text after icon
              child: SizedBox(
                  height: 6, // Thicker progress bar
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(3),
                    child: LinearProgressIndicator(
                      value: progressPercent.clamp(0.0, 1.0),
                      backgroundColor: AppTheme.fhBorderColor.withOpacity(0.2),
                      valueColor: AlwaysStoppedAnimation<Color>(
                          (gameProvider.getSelectedTask()?.taskColor ??
                                  AppTheme.fhAccentTealFixed)
                              .withOpacity(0.7)),
                    ),
                  )),
            ),
          if (gameProvider.settings.descriptionsVisible &&
              description != null &&
              description.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(top: 4.0, left: 32 + 12),
              child: Text(
                description,
                style: theme.textTheme.bodySmall?.copyWith(
                    fontSize: 10,
                    color: AppTheme.fhTextSecondary.withOpacity(0.7),
                    fontStyle: FontStyle.italic),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildSectionTitle(ThemeData theme, IconData icon, String title) {
    return Padding(
      padding: const EdgeInsets.only(
          bottom: 8.0,
          top: 20.0,
          left: 16.0,
          right: 16.0), // Increased top padding
      child: Row(
        children: [
          Icon(icon,
              color: AppTheme.fhAccentRed, size: 20), // Use primary accent
          const SizedBox(width: 10),
          Text(
            title.toUpperCase(), // Uppercase titles
            style: theme.textTheme.headlineSmall?.copyWith(
                // Use headlineSmall
                color: AppTheme.fhTextPrimary, // Brighter title
                letterSpacing: 0.8,
                fontWeight: FontWeight.bold),
          ),
        ],
      ),
    );
  }

  Widget _buildEquippedItemRow(BuildContext context, ThemeData theme,
      String label, Map<String, dynamic>? itemDetails, VoidCallback onUnequip) {
    final String name = itemDetails?['name'] ?? 'Empty Slot';
    final String iconStr = itemDetails?['icon'] ?? '➖'; // MDI name or emoji
    final bool isEquipped = itemDetails?['uniqueId'] != null;

    Widget iconWidget;
    if (iconStr.length == 1 || iconStr.length == 2) {
      iconWidget = Text(iconStr, style: const TextStyle(fontSize: 18));
    } else {
      final iconData = MdiIcons.fromString(iconStr.replaceAll('mdi-', '')) ??
          MdiIcons.minusCircleOutline;
      iconWidget = Icon(iconData, size: 18);
    }

    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 3.0),
      child: Row(
        children: [
          SizedBox(
            width: 70, // Consistent width for label
            child: Text('$label:',
                style: theme.textTheme.bodyMedium?.copyWith(
                    color: AppTheme.fhTextSecondary.withOpacity(0.8),
                    fontSize: 13)),
          ),
          iconWidget, // Use the determined icon widget
          const SizedBox(width: 10),
          Expanded(
            child: Text(
              name,
              style: theme.textTheme.bodyMedium?.copyWith(
                fontSize: 13,
                color: isEquipped
                    ? (gameProvider.getSelectedTask()?.taskColor ??
                        AppTheme
                            .fhAccentTealFixed) // Brighter for equipped items
                    : AppTheme.fhTextSecondary.withOpacity(0.6),
                fontStyle: isEquipped ? FontStyle.normal : FontStyle.italic,
                fontWeight: isEquipped ? FontWeight.w600 : FontWeight.normal,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          if (isEquipped)
            OutlinedButton(
              onPressed: onUnequip,
              style: OutlinedButton.styleFrom(
                padding:
                    const EdgeInsets.symmetric(horizontal: 10, vertical: 4),
                textStyle: TextStyle(
                    fontSize: 10, // Smaller text for button
                    fontFamily: AppTheme.fontBody, // Use body font
                    fontWeight: FontWeight.bold),
                foregroundColor: AppTheme.fhAccentOrange, // Orange for unequip
                side: BorderSide(
                    color: AppTheme.fhAccentOrange.withOpacity(0.7), width: 1),
                minimumSize: const Size(0, 26), // Slightly taller button
              ),
              child: const Text('UNEQUIP'),
            ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    print(
        "[PlayerStatsDrawer] Building drawer. Player HP: ${gameProvider.currentGame.playerCurrentHp}");

    final playerMaxHp = gameProvider.playerGameStats['vitality']!.value;
    final playerCurrentHp = gameProvider.currentGame.playerCurrentHp;
    final hpPercent =
        playerMaxHp > 0 ? (playerCurrentHp / playerMaxHp).clamp(0.0, 1.0) : 0.0;
    Color hpBarColor;
    if (hpPercent * 100 > 60) {
      hpBarColor = AppTheme.fhAccentGreen;
    } else if (hpPercent * 100 > 30) {
      hpBarColor = AppTheme.fhAccentOrange;
    } else {
      hpBarColor = AppTheme.fhAccentRed;
    }

    final Map<String, dynamic> equippedItemsDetails = {};
    gameProvider.equippedItems.forEach((slot, uniqueId) {
      if (uniqueId != null) {
        final owned = gameProvider.getArtifactByUniqueId(uniqueId);
        if (owned != null) {
          final template =
              gameProvider.getArtifactTemplateById(owned.templateId);
          if (template != null) {
            equippedItemsDetails[slot] = {
              'name':
                  '${template.name} Lvl ${owned.currentLevel}', // Include level
              'icon': template.icon,
              'uniqueId': owned.uniqueId,
            };
          } else {
            equippedItemsDetails[slot] = {
              'name': 'Unknown Item',
              'icon': MdiIcons.helpRhombusOutline.codePoint.toString(),
              'uniqueId': uniqueId
            }; // Default icon
          }
        } else {
          equippedItemsDetails[slot] = {
            'name': 'Error Loading',
            'icon': MdiIcons.alertCircleOutline.codePoint.toString(),
            'uniqueId': uniqueId
          }; // Default icon
        }
      } else {
        equippedItemsDetails[slot] = {
          'name': 'Empty Slot',
          'icon': '➖',
          'uniqueId': null
        };
      }
    });

    final unequippedGear = gameProvider.artifacts.where((ownedArt) {
      final template =
          gameProvider.getArtifactTemplateById(ownedArt.templateId);
      return template != null &&
          template.type != 'powerup' &&
          !gameProvider.equippedItems.values.contains(ownedArt.uniqueId);
    }).toList();

    return Drawer(
      backgroundColor: AppTheme.fhBgDark, // Darker drawer background
      child: ListView(
        padding: EdgeInsets.zero,
        children: <Widget>[
          Container(
            // Header Section
            padding: EdgeInsets.fromLTRB(
                16, MediaQuery.of(context).padding.top + 16, 16, 16),
            decoration: BoxDecoration(
                color: AppTheme.fhBgMedium, // Slightly lighter header
                border: Border(
                    bottom: BorderSide(
                        color: AppTheme.fhBorderColor.withOpacity(0.5),
                        width: 1))),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                    gameProvider.currentUser?.displayName ??
                        "Adventurer", // Display Name
                    style: theme.textTheme.displaySmall
                        ?.copyWith(color: AppTheme.fhAccentRed)),
                const SizedBox(height: 4),
                Text('LEVEL ${gameProvider.romanize(gameProvider.playerLevel)}',
                    style: theme.textTheme.headlineSmall?.copyWith(
                        color: AppTheme.fhTextSecondary, letterSpacing: 1)),
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 12.0),
                  child: Row(
                    children: [
                      Icon(MdiIcons.starShootingOutline,
                          color: AppTheme.fhAccentGold, size: 16),
                      const SizedBox(width: 6),
                      Text(
                        '${gameProvider.currentLevelXPProgress.toStringAsFixed(0)} / ${gameProvider.xpNeededForNextLevel.toStringAsFixed(0)} XP',
                        style: theme.textTheme.bodyMedium
                            ?.copyWith(color: AppTheme.fhTextSecondary),
                      ),
                    ],
                  ),
                ),
                SizedBox(
                  // XP Bar
                  height: 8, // Thicker XP Bar
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(4),
                    child: LinearProgressIndicator(
                      value: (gameProvider.xpProgressPercent / 100)
                          .clamp(0.0, 1.0),
                      backgroundColor: AppTheme.fhBorderColor.withOpacity(0.3),
                      valueColor: const AlwaysStoppedAnimation<Color>(
                          AppTheme.fhAccentGold),
                    ),
                  ),
                ),
                const SizedBox(height: 12),
                Row(
                  // HP Bar
                  children: <Widget>[
                    Icon(MdiIcons.heartPulse, size: 18, color: hpBarColor),
                    const SizedBox(width: 8),
                    Expanded(
                      child: SizedBox(
                        height: 8,
                        child: ClipRRect(
                          borderRadius: BorderRadius.circular(4),
                          child: LinearProgressIndicator(
                            value: hpPercent,
                            backgroundColor:
                                AppTheme.fhBorderColor.withOpacity(0.3),
                            valueColor:
                                AlwaysStoppedAnimation<Color>(hpBarColor),
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 10),
                    Text(
                      '${playerCurrentHp.toStringAsFixed(0)} / ${playerMaxHp.toStringAsFixed(0)} HP',
                      style: theme.textTheme.bodyMedium?.copyWith(
                          color: AppTheme.fhTextPrimary,
                          fontWeight: FontWeight.w600),
                    ),
                  ],
                ),
              ],
            ),
          ),
          _buildSectionTitle(theme, MdiIcons.swordCross, 'Equipped Gear'),
          _buildEquippedItemRow(
              context,
              theme,
              'Weapon',
              equippedItemsDetails['weapon'],
              () => gameProvider.unequipArtifact('weapon')),
          _buildEquippedItemRow(
              context,
              theme,
              'Armor',
              equippedItemsDetails['armor'],
              () => gameProvider.unequipArtifact('armor')),
          _buildEquippedItemRow(
              context,
              theme,
              'Talisman',
              equippedItemsDetails['talisman'],
              () => gameProvider.unequipArtifact('talisman')),
          _buildSectionTitle(
              theme, MdiIcons.treasureChestOutline, 'Inventory (Gear)'),
          if (unequippedGear.isEmpty)
            Padding(
              padding:
                  const EdgeInsets.symmetric(vertical: 15.0, horizontal: 16.0),
              child: Center(
                  child: Text('No gear in inventory.',
                      style: theme.textTheme.bodyMedium?.copyWith(
                          fontStyle: FontStyle.italic,
                          color: AppTheme.fhTextSecondary.withOpacity(0.7)))),
            )
          else
            ListView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: unequippedGear.length,
              itemBuilder: (context, index) {
                final ownedArt = unequippedGear[index];
                final template =
                    gameProvider.getArtifactTemplateById(ownedArt.templateId);
                if (template == null) return const SizedBox.shrink();

                Widget itemIconWidget;
                if (template.icon.length == 1 || template.icon.length == 2) {
                  itemIconWidget =
                      Text(template.icon, style: const TextStyle(fontSize: 18));
                } else {
                  final iconData = MdiIcons.fromString(
                          template.icon.replaceAll('mdi-', '')) ??
                      MdiIcons.treasureChest;
                  itemIconWidget = Icon(iconData, size: 18);
                }

                return Padding(
                  padding: const EdgeInsets.symmetric(
                      vertical: 2.0, horizontal: 16.0),
                  child: Material(
                    color:
                        AppTheme.fhBgMedium.withOpacity(0.7), // Item background
                    borderRadius: BorderRadius.circular(4),
                    child: InkWell(
                      onTap: () =>
                          gameProvider.equipArtifact(ownedArt.uniqueId),
                      borderRadius: BorderRadius.circular(4),
                      hoverColor: (gameProvider.getSelectedTask()?.taskColor ??
                              AppTheme.fhAccentTealFixed)
                          .withOpacity(0.1),
                      child: Padding(
                        padding: const EdgeInsets.symmetric(
                            horizontal: 10.0, vertical: 8.0),
                        child: Row(
                          children: [
                            itemIconWidget,
                            const SizedBox(width: 10),
                            Expanded(
                              child: Text(
                                '${template.name} (Lvl ${ownedArt.currentLevel})',
                                style: theme.textTheme.bodyMedium?.copyWith(
                                    color: AppTheme.fhTextPrimary,
                                    fontSize: 13),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            ElevatedButton(
                              onPressed: () =>
                                  gameProvider.equipArtifact(ownedArt.uniqueId),
                              style: ElevatedButton.styleFrom(
                                backgroundColor: (gameProvider
                                        .getSelectedTask()
                                        ?.taskColor ??
                                    AppTheme
                                        .fhAccentTealFixed), // Accent for equip
                                foregroundColor: AppTheme.fhBgDark,
                                padding: const EdgeInsets.symmetric(
                                    horizontal: 12, vertical: 6),
                                textStyle: TextStyle(
                                    fontSize: 10,
                                    fontFamily: AppTheme.fontBody,
                                    fontWeight: FontWeight.bold),
                                minimumSize:
                                    const Size(0, 28), // Slightly taller button
                                elevation: 1,
                              ),
                              child: const Text('EQUIP'),
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                );
              },
            ),
          _buildSectionTitle(theme, MdiIcons.starFourPointsOutline, 'Runes'),
          const Padding(
            padding: EdgeInsets.symmetric(vertical: 15.0, horizontal: 16.0),
            child: Center(
                child: Text("Rune system not yet active.",
                    style: TextStyle(
                        fontStyle: FontStyle.italic,
                        color: AppTheme.fhTextDisabled))),
          ),
          _buildSectionTitle(theme, MdiIcons.chartLineVariant, 'Player Stats'),
          ListView(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            children: gameProvider.playerGameStats.entries.map((entry) {
              final stat = entry.value;
              // Hide internal bonusXPMod, show XP CALC MOD instead if it's the one used for display
              if (stat.name == 'bonusXPMod') return const SizedBox.shrink();

              final buffValue = stat.value - stat.base;
              String statValDisplay =
                  stat.value.toStringAsFixed(0); // Default display

              if (stat.name == 'LUCK' ||
                  stat.name == 'COOLDOWN' ||
                  stat.name == 'XP CALC MOD') {
                statValDisplay =
                    '${(stat.value * (stat.name == 'XP CALC MOD' ? 100 : 1)).toStringAsFixed(0)}%';
              }

              String? buffDisplay;
              Color? buffColorVal;
              if (buffValue != 0) {
                String buffValueStr = (stat.name == 'LUCK' ||
                        stat.name == 'COOLDOWN' ||
                        stat.name == 'XP CALC MOD')
                    ? '${(buffValue * (stat.name == 'XP CALC MOD' ? 100 : 1)).toStringAsFixed(0)}%'
                    : buffValue.toStringAsFixed(0);
                buffDisplay = '${buffValue > 0 ? '+' : ''}$buffValueStr';
                buffColorVal = buffValue > 0
                    ? AppTheme.fhAccentGreen
                    : AppTheme.fhAccentRed;
              }

              double progress = 0.0;
              if (stat.name != 'VITALITY' && stat.name != 'XP CALC MOD') {
                double typicalMax =
                    100 + (gameProvider.playerLevel - 1) * 2.0;
                if (stat.name == 'STRENGTH' ||
                    stat.name == 'RUNIC' ||
                    stat.name == 'DEFENSE') {
                  typicalMax = 50 + (gameProvider.playerLevel * 2.0);
                } else if (stat.name == 'LUCK' || stat.name == 'COOLDOWN') {
                  typicalMax = 100.0;
                }
                progress = (stat.value.abs() / typicalMax).clamp(0.0, 1.0);
              }

              return _buildStatDisplay(
                context,
                stat.icon, // Pass the MDI name or emoji string
                stat.name,
                statValDisplay,
                buffValue: buffDisplay,
                buffColor: buffColorVal,
                description: stat.description,
                progressPercent:
                    (stat.name != 'VITALITY' && stat.name != 'XP CALC MOD')
                        ? progress
                        : null,
              );
            }).toList(),
          ),
          const SizedBox(height: 20),
        ],
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/player_stats_drawer.dart ---

--- START OF FILE lib/src/widgets/right_panel_widget.dart ---
// lib/src/widgets/right_panel_widget.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
// import 'package:arcane/src/utils/constants.dart'; // Removed unused import
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:arcane/src/models/game_models.dart'; // Ensured models are imported for OwnedArtifact, ArtifactTemplate

class RightPanelWidget extends StatelessWidget {
  const RightPanelWidget({super.key});

  Widget _buildStatDisplay(
      BuildContext context, String iconEmoji, String name, String value,
      {String? buffValue,
      Color? buffColor,
      String? description,
      double? progressPercent}) {
    final theme = Theme.of(context);
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 6.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Text(iconEmoji,
                  style: TextStyle(
                      fontSize: 18,
                      color: AppTheme.fhTextSecondary.withAlpha(
                          (0.8 * 255).round()))), // Fixed withOpacity
              const SizedBox(width: 10),
              Expanded(
                child: Text(
                  name.toUpperCase(),
                  style: theme.textTheme.titleSmall?.copyWith(
                      fontFamily: AppTheme.fontDisplay,
                      color: AppTheme.fhTextPrimary,
                      fontSize: 13,
                      letterSpacing: 0.5),
                ),
              ),
              if (buffValue != null)
                Text(
                  buffValue,
                  style: theme.textTheme.labelSmall
                      ?.copyWith(color: buffColor, fontWeight: FontWeight.bold),
                ),
              const SizedBox(width: 4),
              Text(
                value,
                style: theme.textTheme.titleSmall?.copyWith(
                    color: AppTheme.fhTextPrimary,
                    fontWeight: FontWeight.bold,
                    fontSize: 14),
              ),
            ],
          ),
          if (progressPercent != null &&
              name.toUpperCase() != 'VITALITY' &&
              name.toUpperCase() != 'XP CALC MOD' && // Updated condition
              name.toUpperCase() !=
                  'XP BONUS') // Check if this is the display name for bonusXPMod
            Padding(
              padding: const EdgeInsets.only(top: 4.0, left: 30),
              child: SizedBox(
                  height: 8,
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(4),
                    child: LinearProgressIndicator(
                      value: progressPercent.clamp(0.0, 1.0),
                      backgroundColor: AppTheme.fhBgLight
                          .withAlpha((0.5 * 255).round()), // Fixed withOpacity
                      valueColor: const AlwaysStoppedAnimation<Color>(
                          AppTheme.fhAccentOrange),
                    ),
                  )),
            ),
          if (gameProvider.settings.descriptionsVisible &&
              description != null &&
              description.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(top: 4.0, left: 30),
              child: Text(
                description,
                style: theme.textTheme.bodySmall?.copyWith(
                    fontSize: 11,
                    color:
                        AppTheme.fhTextSecondary.withAlpha((0.8 * 255).round()),
                    fontStyle: FontStyle.italic), // Fixed withOpacity
              ),
            ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    // print("[RightPanelWidget] Building RightPanelWidget"); // DEBUG

    final playerMaxHp = gameProvider.playerGameStats['vitality']!.value;
    final playerCurrentHp = gameProvider.currentGame.playerCurrentHp;
    final hpPercent = playerMaxHp > 0 ? (playerCurrentHp / playerMaxHp) : 0.0;
    Color hpBarColor;
    if (hpPercent * 100 > 60) {
      hpBarColor = AppTheme.fhAccentGreen;
    } else if (hpPercent * 100 > 30) {
      hpBarColor = AppTheme.fhAccentOrange;
    } else {
      hpBarColor = AppTheme.fhAccentRed;
    }

    final Map<String, dynamic> equippedItemsDetails = {};
    gameProvider.equippedItems.forEach((slot, uniqueId) {
      if (uniqueId != null) {
        final owned = gameProvider.artifacts.firstWhere(
            (art) => art.uniqueId == uniqueId,
            orElse: () =>
                OwnedArtifact(uniqueId: '', templateId: '', currentLevel: 0));
        if (owned.uniqueId.isNotEmpty) {
          final template = gameProvider.artifactTemplatesList.firstWhere(
              (tmpl) => tmpl.id == owned.templateId,
              orElse: () => ArtifactTemplate(
                  id: '',
                  name: '',
                  type: '',
                  description: '',
                  cost: 0,
                  icon: ''));
          if (template.id.isNotEmpty) {
            equippedItemsDetails[slot] = {
              'name': template.name,
              'icon': template.icon,
              'level': owned.currentLevel,
              'uniqueId': owned.uniqueId,
            };
          } else {
            equippedItemsDetails[slot] = {
              'name': 'Unknown Item',
              'icon': '❓',
              'level': 0,
              'uniqueId': uniqueId
            };
          }
        } else {
          equippedItemsDetails[slot] = {
            'name': 'Error Loading',
            'icon': '⚠️',
            'level': 0,
            'uniqueId': uniqueId
          };
        }
      } else {
        equippedItemsDetails[slot] = {
          'name': 'None',
          'icon': '➖',
          'level': null,
          'uniqueId': null
        };
      }
    });

    final unequippedArtifacts = gameProvider.artifacts
        .where((ownedArt) =>
            !gameProvider.equippedItems.values.contains(ownedArt.uniqueId) &&
            (gameProvider.artifactTemplatesList
                    .firstWhere((t) => t.id == ownedArt.templateId,
                        orElse: () => ArtifactTemplate(
                            id: '',
                            name: '',
                            type: '',
                            description: '',
                            cost: 0,
                            icon: ''))
                    .type !=
                'powerup'))
        .toList();

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: <Widget>[
            Row(
              children: <Widget>[
                Text(
                  'VIT',
                  style: theme.textTheme.titleMedium?.copyWith(
                      fontFamily: AppTheme.fontDisplay,
                      fontWeight: FontWeight.bold),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: SizedBox(
                    height: 10,
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(5),
                      child: LinearProgressIndicator(
                        value: hpPercent,
                        backgroundColor: AppTheme.fhBgLight.withAlpha(
                            (0.5 * 255).round()), // Fixed withOpacity
                        valueColor: AlwaysStoppedAnimation<Color>(hpBarColor),
                      ),
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                Text(
                  '${playerCurrentHp.toStringAsFixed(0)} / ${playerMaxHp.toStringAsFixed(0)}',
                  style: theme.textTheme.bodySmall
                      ?.copyWith(color: AppTheme.fhTextPrimary),
                ),
                const SizedBox(width: 12),
                Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: (gameProvider.getSelectedTask()?.taskColor ??
                        AppTheme.fhAccentTealFixed),
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Text(
                    gameProvider.romanize(gameProvider.playerLevel),
                    style: theme.textTheme.labelSmall?.copyWith(
                        color: AppTheme.fhBgDark, fontWeight: FontWeight.bold),
                  ),
                ),
              ],
            ),
            const Divider(height: 24),
            _buildSectionTitle(
                gameProvider, theme, MdiIcons.hanger, 'Equipped Gear'),
            _buildEquippedItemRow(
                gameProvider,
                theme,
                'Weapon',
                equippedItemsDetails['weapon'],
                () => gameProvider.unequipArtifact('weapon')),
            _buildEquippedItemRow(
                gameProvider,
                theme,
                'Armor',
                equippedItemsDetails['armor'],
                () => gameProvider.unequipArtifact('armor')),
            _buildEquippedItemRow(
                gameProvider,
                theme,
                'Talisman',
                equippedItemsDetails['talisman'],
                () => gameProvider.unequipArtifact('talisman')),
            const Divider(height: 24),
            _buildSectionTitle(gameProvider, theme, MdiIcons.bagPersonalOutline,
                'Backpack (Gear)'),
            unequippedArtifacts.isEmpty
                ? Padding(
                    padding: const EdgeInsets.symmetric(vertical: 20.0),
                    child: Center(
                        child: Text('Backpack is empty of gear.',
                            style: theme.textTheme.bodySmall?.copyWith(
                                fontStyle: FontStyle.italic,
                                color: AppTheme.fhTextSecondary))),
                  )
                : ListView.builder(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemCount: unequippedArtifacts.length,
                    itemBuilder: (context, index) {
                      final ownedArt = unequippedArtifacts[index];
                      final template = gameProvider.artifactTemplatesList
                          .firstWhere((t) => t.id == ownedArt.templateId,
                              orElse: () => ArtifactTemplate(
                                  id: '',
                                  name: '',
                                  type: '',
                                  description: '',
                                  cost: 0,
                                  icon: ''));
                      if (template.id == '') return const SizedBox.shrink();

                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 2.0),
                        child: Material(
                          color: AppTheme.fhBgLight.withAlpha(
                              (0.5 * 255).round()), // Fixed withOpacity
                          borderRadius: BorderRadius.circular(4),
                          child: InkWell(
                            onTap: () =>
                                gameProvider.equipArtifact(ownedArt.uniqueId),
                            borderRadius: BorderRadius.circular(4),
                            child: Padding(
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 8.0, vertical: 6.0),
                              child: Row(
                                children: [
                                  Text(template.icon,
                                      style: const TextStyle(fontSize: 16)),
                                  const SizedBox(width: 8),
                                  Expanded(
                                    child: Text(
                                      '${template.name} (Lvl ${ownedArt.currentLevel})',
                                      style: theme.textTheme.bodySmall
                                          ?.copyWith(
                                              color: AppTheme.fhTextPrimary),
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                  ),
                                  OutlinedButton(
                                    onPressed: () => gameProvider
                                        .equipArtifact(ownedArt.uniqueId),
                                    style: OutlinedButton.styleFrom(
                                      padding: const EdgeInsets.symmetric(
                                          horizontal: 8, vertical: 4),
                                      textStyle: const TextStyle(
                                          fontSize: 10,
                                          fontFamily: AppTheme.fontBody),
                                      side: BorderSide(
                                          color: AppTheme.fhAccentOrange
                                              .withAlpha((0.5 * 255).round()),
                                          width: 0.5), // Fixed withOpacity
                                      foregroundColor: (gameProvider
                                              .getSelectedTask()
                                              ?.taskColor ??
                                          AppTheme.fhAccentTealFixed),
                                      minimumSize: const Size(0, 24),
                                    ),
                                    child: const Text('EQUIP'),
                                  ),
                                ],
                              ),
                            ),
                          ),
                        ),
                      );
                    },
                  ),
            const Divider(height: 24),
            _buildSectionTitle(gameProvider, theme, MdiIcons.accountStarOutline,
                'Player Stats'),
            ListView(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              children: gameProvider.playerGameStats.entries.map((entry) {
                final stat = entry.value;
                // Hide internal bonusXPMod, show XP CALC MOD instead if it's the one used for display
                if (stat.name == 'bonusXPMod') return const SizedBox.shrink();

                final buffValue = stat.value - stat.base;
                String statValDisplay = stat.value
                    .toStringAsFixed(0); // Default to 0 decimal places

                if (stat.name == 'LUCK' ||
                    stat.name == 'COOLDOWN' ||
                    stat.name ==
                        'XP CALC MOD') { // Updated condition for display
                  statValDisplay =
                      '${(stat.value * (stat.name == 'XP CALC MOD' ? 100 : 1)).toStringAsFixed(0)}%';
                }

                String? buffDisplay;
                Color? buffColorVal;
                if (buffValue != 0) {
                  String buffValueStr = (stat.name == 'LUCK' ||
                          stat.name == 'COOLDOWN' ||
                          stat.name == 'XP CALC MOD')
                      ? '${(buffValue * (stat.name == 'XP CALC MOD' ? 100 : 1)).toStringAsFixed(0)}%'
                      : buffValue.toStringAsFixed(0);
                  buffDisplay = '${buffValue > 0 ? '+' : ''}$buffValueStr';
                  buffColorVal = buffValue > 0
                      ? AppTheme.fhAccentGreen
                      : AppTheme.fhAccentRed;
                }

                double progress = 0.0;
                if (stat.name != 'VITALITY' && stat.name != 'XP CALC MOD') {
                  double typicalMax =
                      100 + (gameProvider.playerLevel - 1) * 2.0;
                  if (stat.name == 'STRENGTH' ||
                      stat.name == 'RUNIC' ||
                      stat.name == 'DEFENSE') {
                    typicalMax = 50 + (gameProvider.playerLevel * 2.0);
                  } else if (stat.name == 'LUCK' || stat.name == 'COOLDOWN') {
                    typicalMax = 100.0;
                  }
                  progress = (stat.value.abs() / typicalMax).clamp(0.0, 1.0);
                }

                return _buildStatDisplay(
                  context,
                  stat.icon,
                  stat.name,
                  statValDisplay,
                  buffValue: buffDisplay,
                  buffColor: buffColorVal,
                  description: stat.description,
                  progressPercent:
                      (stat.name != 'VITALITY' && stat.name != 'XP CALC MOD')
                          ? progress
                          : null,
                );
              }).toList(),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionTitle(
      GameProvider gameProvider, ThemeData theme, IconData icon, String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0),
      child: Row(
        children: [
          Icon(icon,
              color: (gameProvider.getSelectedTask()?.taskColor ??
                  AppTheme.fhAccentTealFixed),
              size: 18),
          const SizedBox(width: 8),
          Text(
            title,
            style: theme.textTheme.titleSmall?.copyWith(
                fontFamily: AppTheme.fontDisplay,
                color: AppTheme.fhTextSecondary,
                fontSize: 14,
                letterSpacing: 0.5),
          ),
        ],
      ),
    );
  }

  Widget _buildEquippedItemRow(GameProvider gameProvider, ThemeData theme,
      String label, Map<String, dynamic>? itemDetails, VoidCallback onUnequip) {
    final String name = itemDetails?['name'] ?? 'None';
    final String icon = itemDetails?['icon'] ?? '➖';
    final int? level = itemDetails?['level'];
    final String? uniqueId = itemDetails?['uniqueId'];

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        children: [
          SizedBox(
            width: 65,
            child: Text('$label:',
                style: theme.textTheme.bodySmall
                    ?.copyWith(color: AppTheme.fhTextSecondary)),
          ),
          Text(icon, style: const TextStyle(fontSize: 16)),
          const SizedBox(width: 6),
          Expanded(
            child: Text(
              level != null ? '$name (Lvl $level)' : name,
              style: theme.textTheme.bodySmall?.copyWith(
                color: name == 'None'
                    ? AppTheme.fhTextSecondary.withAlpha((0.7 * 255).round())
                    : (gameProvider.getSelectedTask()?.taskColor ??
                        AppTheme
                            .fhAccentTealFixed), // Fixed withOpacity & fhAccentLightCyan
                fontStyle: name == 'None' ? FontStyle.italic : FontStyle.normal,
                fontWeight:
                    name == 'None' ? FontWeight.normal : FontWeight.bold,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
          if (uniqueId != null)
            TextButton(
              onPressed: onUnequip,
              style: TextButton.styleFrom(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                textStyle: const TextStyle(
                    fontSize: 10, fontFamily: AppTheme.fontBody),
                foregroundColor: AppTheme.fhAccentRed,
                minimumSize: const Size(0, 24),
                side: BorderSide(
                    color: AppTheme.fhAccentRed.withAlpha((0.5 * 255).round()),
                    width: 0.5), // Fixed withOpacity
              ),
              child: const Text('UNEQUIP'),
            ),
        ],
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/right_panel_widget.dart ---

--- START OF FILE lib/src/widgets/task_navigation_drawer.dart ---
// lib/src/widgets/task_navigation_drawer.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:arcane/src/models/game_models.dart'; // Added import

// import 'package:flutter_colorpicker/flutter_colorpicker.dart'; // For color picker

class TaskNavigationDrawer extends StatefulWidget {
  const TaskNavigationDrawer({super.key});

  @override
  State<TaskNavigationDrawer> createState() => _TaskNavigationDrawerState();
}

class _TaskNavigationDrawerState extends State<TaskNavigationDrawer> {
  final _newTaskNameController = TextEditingController();
  final _newTaskDescController = TextEditingController();

  // For editing
  final _editTaskNameController = TextEditingController();
  final _editTaskDescController = TextEditingController();

  // Theme and Color selection state for dialogs
  // These will be initialized when the dialog is shown.
  String _dialogSelectedTheme = 'tech';
  String _dialogSelectedColorHex =
      AppTheme.fhAccentTealFixed.value.toRadixString(16).toUpperCase();

  final List<Map<String, dynamic>> _availableThemes = [
    {'name': 'tech', 'icon': MdiIcons.memory, 'color': AppTheme.fhAccentTealFixed},
    {'name': 'knowledge', 'icon': MdiIcons.bookOpenPageVariantOutline, 'color': AppTheme.fhAccentPurple},
    {'name': 'learning', 'icon': MdiIcons.schoolOutline, 'color': AppTheme.fhAccentOrange},
    {'name': 'discipline', 'icon': MdiIcons.karate, 'color': AppTheme.fhAccentRed},
    {'name': 'order', 'icon': MdiIcons.playlistCheck, 'color': AppTheme.fhAccentGreen},
    {'name': 'health', 'icon': MdiIcons.heartPulse, 'color': Color(0xFF58D68D)},
    {'name': 'finance', 'icon': MdiIcons.cashMultiple, 'color': Color(0xFFF1C40F)},
    {'name': 'creative', 'icon': MdiIcons.paletteOutline, 'color': Color(0xFFEC7063)},
    {'name': 'exploration', 'icon': MdiIcons.mapSearchOutline, 'color': Color(0xFF5DADE2)},
    {'name': 'social', 'icon': MdiIcons.accountGroupOutline, 'color': Color(0xFFE59866)},
    {'name': 'nature', 'icon': MdiIcons.treeOutline, 'color': Color(0xFF2ECC71)},
    {'name': 'general', 'icon': MdiIcons.targetAccount, 'color': AppTheme.fhTextSecondary},
  ];

  Color _getColorForTheme(String themeName) {
    return _availableThemes.firstWhere((t) => t['name'] == themeName,
            orElse: () => {'color': AppTheme.fhAccentTealFixed})['color']
        as Color;
  }

  @override
  void dispose() {
    _newTaskNameController.dispose();
    _newTaskDescController.dispose();
    _editTaskNameController.dispose();
    _editTaskDescController.dispose();
    super.dispose();
  }

  IconData _getThemeIcon(String? themeName) {
    return _availableThemes.firstWhere((t) => t['name'] == themeName,
            orElse: () => _availableThemes.last)['icon']
        as IconData;
  }

  void _showAddTaskDialog(BuildContext context, GameProvider gameProvider) {
    _newTaskNameController.clear();
    _newTaskDescController.clear();
    _dialogSelectedTheme = 'tech'; // Reset to default
    _dialogSelectedColorHex = _getColorForTheme(_dialogSelectedTheme)
        .value
        .toRadixString(16)
        .toUpperCase(); // Reset to default theme's color

    showDialog(
      context: context,
      builder: (BuildContext dialogContext) {
        return StatefulBuilder(
            builder: (BuildContext context, StateSetter setStateDialog) {
          return AlertDialog(
            backgroundColor: AppTheme.fhBgMedium,
            title: Text('Add New Mission',
                style: TextStyle(color: AppTheme.fhAccentRed)),
            content: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: <Widget>[
                  TextField(
                      controller: _newTaskNameController,
                      decoration: InputDecoration(labelText: 'Mission Name')),
                  const SizedBox(height: 8),
                  TextField(
                      controller: _newTaskDescController,
                      decoration: InputDecoration(labelText: 'Description'),
                      maxLines: 2),
                  const SizedBox(height: 8),
                  DropdownButtonFormField<String>(
                    decoration: InputDecoration(labelText: 'Theme'),
                    dropdownColor: AppTheme.fhBgLight,
                    value: _dialogSelectedTheme,
                    items: _availableThemes
                        .map((themeMap) => DropdownMenuItem<String>(
                            value: themeMap['name'] as String,
                            child: Row(
                              children: [
                                Icon(
                                    _getThemeIcon(themeMap['name'] as String),
                                    size: 18,
                                    color: themeMap['color'] as Color),
                                SizedBox(width: 8),
                                Text(themeMap['name'] as String),
                              ],
                            )))
                        .toList(),
                    onChanged: (String? newValue) {
                      if (newValue != null) {
                        setStateDialog(() {
                          _dialogSelectedTheme = newValue;
                          _dialogSelectedColorHex = _getColorForTheme(newValue)
                              .value
                              .toRadixString(16)
                              .toUpperCase();
                        });
                      }
                    },
                  ),
                  const SizedBox(height: 16),
                  Text("Select Theme Color:",
                      style: Theme.of(context).textTheme.labelMedium),
                  const SizedBox(height: 8),
                  Wrap(
                    spacing: 8.0,
                    runSpacing: 8.0,
                    children: _availableThemes.map((themeMap) {
                      Color color = themeMap['color'] as Color;
                      String colorHex =
                          color.value.toRadixString(16).toUpperCase();
                      bool isSelectedColor = _dialogSelectedColorHex == colorHex;

                      return GestureDetector(
                        onTap: () => setStateDialog(
                            () => _dialogSelectedColorHex = colorHex),
                        child: Container(
                          width: 30,
                          height: 30,
                          decoration: BoxDecoration(
                            color: color,
                            borderRadius: BorderRadius.circular(4),
                            border: isSelectedColor
                                ? Border.all(color: Colors.white, width: 2)
                                : Border.all(
                                    color: Colors.white.withOpacity(0.3),
                                    width: 1),
                          ),
                          child: isSelectedColor
                              ? Icon(MdiIcons.check,
                                  color: ThemeData.estimateBrightnessForColor(
                                              color) ==
                                          Brightness.dark
                                      ? Colors.white
                                      : Colors.black,
                                  size: 18)
                              : null,
                        ),
                      );
                    }).toList(),
                  ),
                ],
              ),
            ),
            actions: <Widget>[
              TextButton(
                  child: Text('Cancel'),
                  onPressed: () => Navigator.of(dialogContext).pop()),
              ElevatedButton(
                child: Text('Add Mission'),
                onPressed: () {
                  if (_newTaskNameController.text.isNotEmpty) {
                    gameProvider.addMainTask(
                      name: _newTaskNameController.text,
                      description: _newTaskDescController.text,
                      theme: _dialogSelectedTheme,
                      colorHex: _dialogSelectedColorHex,
                    );
                    Navigator.of(dialogContext).pop();
                  }
                },
              ),
            ],
          );
        });
      },
    );
  }

  void _showEditTaskDialog(
      BuildContext context, GameProvider gameProvider, MainTask taskToEdit) {
    _editTaskNameController.text = taskToEdit.name;
    _editTaskDescController.text = taskToEdit.description;
    _dialogSelectedTheme = taskToEdit.theme;
    _dialogSelectedColorHex = taskToEdit.colorHex;

    showDialog(
      context: context,
      builder: (BuildContext dialogContext) {
        return StatefulBuilder(
            builder: (BuildContext context, StateSetter setStateDialog) {
          return AlertDialog(
            backgroundColor: AppTheme.fhBgMedium,
            title: Text('Edit Mission',
                style: TextStyle(color: AppTheme.fhAccentRed)),
            content: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: <Widget>[
                  TextField(
                      controller: _editTaskNameController,
                      decoration: InputDecoration(labelText: 'Mission Name')),
                  const SizedBox(height: 8),
                  TextField(
                      controller: _editTaskDescController,
                      decoration: InputDecoration(labelText: 'Description'),
                      maxLines: 2),
                  const SizedBox(height: 8),
                  DropdownButtonFormField<String>(
                      decoration: InputDecoration(labelText: 'Theme'),
                      dropdownColor: AppTheme.fhBgLight,
                      value: _dialogSelectedTheme,
                      items: _availableThemes
                          .map((themeMap) => DropdownMenuItem<String>(
                              value: themeMap['name'] as String,
                              child: Row(
                                children: [
                                  Icon(
                                      _getThemeIcon(
                                          themeMap['name'] as String),
                                      size: 18,
                                      color: themeMap['color'] as Color),
                                  SizedBox(width: 8),
                                  Text(themeMap['name'] as String),
                                ],
                              )))
                          .toList(),
                      onChanged: (String? newValue) {
                        if (newValue != null) {
                          setStateDialog(() {
                            _dialogSelectedTheme = newValue;
                            _dialogSelectedColorHex =
                                _getColorForTheme(newValue)
                                    .value
                                    .toRadixString(16)
                                    .toUpperCase();
                          });
                        }
                      }),
                  const SizedBox(height: 16),
                  Text("Select Theme Color:",
                      style: Theme.of(context).textTheme.labelMedium),
                  const SizedBox(height: 8),
                  Wrap(
                    spacing: 8.0,
                    runSpacing: 8.0,
                    children: _availableThemes.map((themeMap) {
                      Color color = themeMap['color'] as Color;
                      String colorHex =
                          color.value.toRadixString(16).toUpperCase();
                      bool isSelectedColor = _dialogSelectedColorHex == colorHex;

                      return GestureDetector(
                        onTap: () => setStateDialog(
                            () => _dialogSelectedColorHex = colorHex),
                        child: Container(
                          width: 30,
                          height: 30,
                          decoration: BoxDecoration(
                            color: color,
                            borderRadius: BorderRadius.circular(4),
                            border: isSelectedColor
                                ? Border.all(color: Colors.white, width: 2)
                                : Border.all(
                                    color: Colors.white.withOpacity(0.3),
                                    width: 1),
                          ),
                          child: isSelectedColor
                              ? Icon(MdiIcons.check,
                                  color: ThemeData.estimateBrightnessForColor(
                                              color) ==
                                          Brightness.dark
                                      ? Colors.white
                                      : Colors.black,
                                  size: 18)
                              : null,
                        ),
                      );
                    }).toList(),
                  ),
                ],
              ),
            ),
            actions: <Widget>[
              TextButton(
                  child: Text('Cancel'),
                  onPressed: () => Navigator.of(dialogContext).pop()),
              ElevatedButton(
                child: Text('Save Changes'),
                onPressed: () {
                  if (_editTaskNameController.text.isNotEmpty) {
                    gameProvider.editMainTask(
                      taskToEdit.id,
                      name: _editTaskNameController.text,
                      description: _editTaskDescController.text,
                      theme: _dialogSelectedTheme,
                      colorHex: _dialogSelectedColorHex,
                    );
                    Navigator.of(dialogContext).pop();
                  }
                },
              ),
            ],
          );
        });
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);

    return Drawer(
      backgroundColor: AppTheme.fhBgDark,
      child: Column(
        children: [
          AppBar(
            title: Text('MISSIONS',
                style: theme.textTheme.headlineSmall?.copyWith(
                    color: AppTheme.fhTextPrimary, letterSpacing: 1)),
            automaticallyImplyLeading: false,
            backgroundColor: AppTheme.fhBgMedium,
            elevation: 0,
            actions: [
              IconButton(
                icon: Icon(MdiIcons.plusCircleOutline,
                    color: AppTheme.fhAccentTeal),
                onPressed: () => _showAddTaskDialog(context, gameProvider),
                tooltip: 'Add New Mission',
              ),
            ],
          ),
          Expanded(
            child: gameProvider.mainTasks.isEmpty
                ? Center(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Text(
                        'No missions available. Add a new one to begin.',
                        style: theme.textTheme.bodyMedium?.copyWith(
                            color: AppTheme.fhTextSecondary,
                            fontStyle: FontStyle.italic),
                        textAlign: TextAlign.center,
                      ),
                    ),
                  )
                : ListView.builder(
                    padding: EdgeInsets.zero,
                    itemCount: gameProvider.mainTasks.length,
                    itemBuilder: (context, index) {
                      final task = gameProvider.mainTasks[index];
                      final isSelected = gameProvider.selectedTaskId == task.id;
                      final taskColor = Color(int.parse("0x${task.colorHex}"));

                      return Material(
                        color: isSelected
                            ? taskColor.withOpacity(0.25)
                            : Colors.transparent,
                        child: ListTile(
                          leading: Icon(
                            _getThemeIcon(task.theme),
                            color: isSelected
                                ? taskColor
                                : AppTheme.fhTextSecondary,
                            size: 22,
                          ),
                          title: Text(
                            task.name,
                            style: theme.textTheme.titleMedium?.copyWith(
                              color: isSelected
                                  ? taskColor
                                  : AppTheme.fhTextPrimary,
                              fontWeight: isSelected
                                  ? FontWeight.bold
                                  : FontWeight.w500,
                            ),
                            overflow: TextOverflow.ellipsis,
                          ),
                          trailing: Wrap(
                              spacing: 0,
                              children: [
                                if (task.streak > 0)
                                  Chip(
                                    avatar: Icon(MdiIcons.fire,
                                        color: AppTheme.fhAccentOrange,
                                        size: 14),
                                    label: Text('${task.streak}',
                                        style: TextStyle(
                                            color: AppTheme.fhAccentOrange,
                                            fontSize: 11,
                                            fontWeight: FontWeight.bold)),
                                    backgroundColor:
                                        Color.fromARGB(55, 0, 0, 0),
                                    padding: const EdgeInsets.symmetric(
                                        horizontal: 6, vertical: 0),
                                    visualDensity: VisualDensity.compact,
                                  ),
                                IconButton(
                                  icon: Icon(MdiIcons.pencilOutline,
                                      size: 18,
                                      color: AppTheme.fhTextSecondary
                                          .withOpacity(0.7)),
                                  onPressed: () => _showEditTaskDialog(
                                      context, gameProvider, task),
                                  tooltip: 'Edit Mission',
                                  padding: const EdgeInsets.symmetric(
                                      horizontal: 6, vertical: 6),
                                  constraints: BoxConstraints(),
                                ),
                              ]),
                          selected: isSelected,
                          onTap: () {
                            FocusScope.of(context).unfocus(); // Unfocus on task selection
                            gameProvider.setSelectedTaskId(task.id);
                            if (gameProvider.currentView != 'task-details') {
                              gameProvider.setCurrentView('task-details');
                            }
                            if (MediaQuery.of(context).size.width < 900) {
                              Navigator.pop(context);
                            }
                          },
                          selectedTileColor: taskColor.withOpacity(0.15),
                          contentPadding: const EdgeInsets.symmetric(
                              horizontal: 16, vertical: 8),
                        ),
                      );
                    },
                  ),
          ),
        ],
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/task_navigation_drawer.dart ---

--- START OF FILE lib/src/widgets/ui/artifact_card.dart ---
// lib/src/widgets/ui/artifact_card.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class ArtifactCardWidget extends StatelessWidget {
  final ArtifactTemplate template;
  final OwnedArtifact? ownedArtifact;
  final Widget? actionSection;
  final int? cost;

  const ArtifactCardWidget({
    super.key,
    required this.template,
    this.ownedArtifact,
    this.actionSection,
    this.cost,
  });

  Map<String, IconData> get _statIcons => {
        'att': MdiIcons.sword,
        'def': MdiIcons.shieldOutline,
        'health': MdiIcons.heartFlash,
        'runic': MdiIcons.fireAlert,
        'luck': MdiIcons.cloverOutline,
        'cooldown': MdiIcons.clockFast,
        'bonusXPMod': MdiIcons.schoolOutline,
        'direct_damage': MdiIcons.laserPointer,
        'heal_player': MdiIcons.bottleTonicPlusOutline,
        'uses': MdiIcons.repeatVariant,
      };

  Widget _buildStatsList(BuildContext context,
      ArtifactTemplate effectiveTemplate, OwnedArtifact? currentOwned) {
    final theme = Theme.of(context);
    final List<Widget> statWidgets = [];
    final Color dynamicAccent =
        Provider.of<GameProvider>(context, listen: false)
                .getSelectedTask()
                ?.taskColor ??
            Theme.of(context).colorScheme.secondary;

    Widget statChip(IconData icon, String value, Color color,
        {bool isBright = false}) {
      final Color textColor =
          isBright ? AppTheme.fhBgDark : AppTheme.fhTextPrimary;
      return Container(
        padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 2),
        decoration: BoxDecoration(
            color: isBright
                ? color.withOpacity(0.85)
                : AppTheme.fhBgDark.withOpacity(0.5),
            borderRadius: BorderRadius.circular(4),
            border: Border.all(color: color.withOpacity(0.5), width: 0.5)),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon,
                size: 12,
                color: isBright ? AppTheme.fhBgDark.withOpacity(0.8) : color),
            const SizedBox(width: 4),
            Text(value,
                style: theme.textTheme.labelSmall?.copyWith(
                    color: textColor,
                    fontSize: 10,
                    fontWeight: FontWeight.w600)),
          ],
        ),
      );
    }

    if (effectiveTemplate.type == 'powerup') {
      if (effectiveTemplate.effectType == 'direct_damage' &&
          effectiveTemplate.effectValue != null &&
          effectiveTemplate.effectValue! > 0) {
        statWidgets.add(statChip(_statIcons['direct_damage']!,
            '${effectiveTemplate.effectValue}', AppTheme.fhAccentRed,
            isBright: true));
      }
      if (effectiveTemplate.effectType == 'heal_player' &&
          effectiveTemplate.effectValue != null &&
          effectiveTemplate.effectValue! > 0) {
        statWidgets.add(statChip(_statIcons['heal_player']!,
            '+${effectiveTemplate.effectValue} HP', AppTheme.fhAccentGreen,
            isBright: true));
      }
      final usesValue = currentOwned?.uses ?? template.uses;
      if (usesValue != null) {
        statWidgets.add(statChip(
            _statIcons['uses']!, '$usesValue Uses', AppTheme.fhTextSecondary));
      }
    } else {
      // Use dynamicAccent for primary stats if applicable, or specific colors for others
      if (effectiveTemplate.baseAtt != null && effectiveTemplate.baseAtt! > 0) {
        statWidgets.add(statChip(_statIcons['att']!,
            '+${effectiveTemplate.baseAtt}', AppTheme.fhAccentOrange));
      }
      if (effectiveTemplate.baseDef != null && effectiveTemplate.baseDef! > 0) {
        statWidgets.add(statChip(_statIcons['def']!,
            '+${effectiveTemplate.baseDef}', dynamicAccent));
      }
      if (effectiveTemplate.baseHealth != null &&
          effectiveTemplate.baseHealth! > 0) {
        statWidgets.add(statChip(_statIcons['health']!,
            '+${effectiveTemplate.baseHealth}', AppTheme.fhAccentGreen));
      }
      if (effectiveTemplate.baseRunic != null &&
          effectiveTemplate.baseRunic! > 0) {
        statWidgets.add(statChip(_statIcons['runic']!,
            '+${effectiveTemplate.baseRunic}', AppTheme.fhAccentPurple));
      }
      if (effectiveTemplate.baseLuck != null && effectiveTemplate.baseLuck! > 0) {
        statWidgets.add(statChip(_statIcons['luck']!,
            '+${effectiveTemplate.baseLuck}%', dynamicAccent));
      }
      if (effectiveTemplate.baseCooldown != null &&
          effectiveTemplate.baseCooldown! > 0) {
        statWidgets.add(statChip(
            _statIcons['cooldown']!,
            '-${effectiveTemplate.baseCooldown}% CD',
            AppTheme.fhTextSecondary));
      }
      if (effectiveTemplate.bonusXPMod != null &&
          effectiveTemplate.bonusXPMod! > 0) {
        statWidgets.add(statChip(
            _statIcons['bonusXPMod']!,
            '+${(effectiveTemplate.bonusXPMod! * 100).toStringAsFixed(0)}% XP',
            AppTheme.fhAccentGreen));
      }
    }

    if (statWidgets.isEmpty) {
      return Padding(
        padding: const EdgeInsets.symmetric(vertical: 8.0),
        child: Text(
          template.type == 'powerup'
              ? "Single-use tactical item."
              : "No direct combat bonuses.",
          style: theme.textTheme.bodySmall?.copyWith(
              fontStyle: FontStyle.italic,
              color: AppTheme.fhTextSecondary.withOpacity(0.7),
              fontSize: 10),
        ),
      );
    }

    return Padding(
      padding: const EdgeInsets.only(top: 6, bottom: 8),
      child: Wrap(
        spacing: 6.0,
        runSpacing: 4.0,
        children: statWidgets,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    final ArtifactTemplate displayTemplate = ownedArtifact != null
        ? gameProvider.getArtifactEffectiveStats(ownedArtifact!)
        : template;

    final Color dynamicAccent = gameProvider.getSelectedTask()?.taskColor ??
        theme.colorScheme.secondary;
    final Color cardTitleColor = dynamicAccent;
    final Color cardTextColorOnAccent =
        ThemeData.estimateBrightnessForColor(dynamicAccent) == Brightness.dark
            ? AppTheme.fhTextPrimary
            : AppTheme.fhBgDark;

    Color borderColor = AppTheme.fhBorderColor.withOpacity(0.5);
    if (ownedArtifact != null) {
      borderColor = dynamicAccent.withOpacity(0.7);
    } else if (cost != null && gameProvider.coins >= cost!) {
      borderColor = dynamicAccent.withOpacity(0.5);
    }

    Widget itemIcon;
    if (displayTemplate.icon.length == 1 || displayTemplate.icon.length == 2) {
      itemIcon = Text(displayTemplate.icon,
          style: const TextStyle(fontSize: 32)); // Larger icon
    } else {
      final iconData =
          MdiIcons.fromString(displayTemplate.icon.replaceAll('mdi-', '')) ??
              MdiIcons.treasureChest;
      itemIcon = Icon(iconData, size: 32, color: AppTheme.fhTextSecondary);
    }

    return Card(
      elevation: 0,
      color: AppTheme.fhBgLight.withOpacity(0.8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(6.0),
        side: BorderSide(color: borderColor, width: 1),
      ),
      child: Padding(
        padding: const EdgeInsets.all(10.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisAlignment: MainAxisAlignment
              .spaceBetween, // Ensure action button is at bottom
          children: [
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Container(
                      width: 50, // Fixed size for icon container
                      height: 50,
                      padding: const EdgeInsets.all(4),
                      decoration: BoxDecoration(
                          color: AppTheme.fhBgDark.withOpacity(0.6),
                          borderRadius: BorderRadius.circular(4)),
                      child: Center(child: itemIcon),
                    ),
                    const SizedBox(width: 10),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            displayTemplate.name,
                            style: theme.textTheme.titleMedium?.copyWith(
                                fontFamily: AppTheme.fontDisplay,
                                color: cardTitleColor, // Dynamic color
                                fontWeight: FontWeight.bold,
                                fontSize: 15), // Slightly larger title
                            maxLines: 2, // Allow two lines for name
                            overflow: TextOverflow.ellipsis,
                          ),
                          if (ownedArtifact != null &&
                              displayTemplate.type != 'powerup' &&
                              displayTemplate.maxLevel != null)
                            Container(
                              margin: const EdgeInsets.only(top: 2),
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 5, vertical: 1.5),
                              decoration: BoxDecoration(
                                  color: cardTitleColor.withOpacity(0.85),
                                  borderRadius: BorderRadius.circular(3)),
                              child: Text(
                                'LEVEL ${ownedArtifact!.currentLevel} / ${displayTemplate.maxLevel}',
                                style: theme.textTheme.labelSmall?.copyWith(
                                    color: cardTextColorOnAccent,
                                    fontWeight: FontWeight.bold,
                                    letterSpacing: 0.5,
                                    fontSize: 9),
                              ),
                            )
                          else
                            Text(
                              displayTemplate.type.toUpperCase(),
                              style: theme.textTheme.labelSmall?.copyWith(
                                  color:
                                      AppTheme.fhTextSecondary.withOpacity(0.8),
                                  letterSpacing: 0.5,
                                  fontWeight: FontWeight.w500,
                                  fontSize: 10),
                            ),
                        ],
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                if (displayTemplate.theme != null) ...[
                  Row(
                    children: [
                      Icon(MdiIcons.paletteSwatchOutline,
                          size: 12,
                          color: AppTheme.fhTextSecondary.withOpacity(0.7)),
                      const SizedBox(width: 4),
                      Text("System Alignment: ${displayTemplate.theme!}",
                          style: theme.textTheme.labelSmall?.copyWith(
                              color: AppTheme.fhTextSecondary.withOpacity(0.7),
                              fontSize: 10,
                              fontStyle: FontStyle.italic)),
                    ],
                  ),
                  const SizedBox(height: 6),
                ],
                Text(
                  displayTemplate.description,
                  style: theme.textTheme.bodySmall?.copyWith(
                      color: AppTheme.fhTextSecondary.withOpacity(0.9),
                      fontStyle: FontStyle.italic,
                      fontSize: 11,
                      height: 1.3),
                  maxLines: 3, // Allow more lines for description
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 4),
                _buildStatsList(context, displayTemplate, ownedArtifact),
              ],
            ),
            if (actionSection != null) ...[
              const Spacer(), // Push action to bottom if there's space
              Padding(
                padding: const EdgeInsets.only(top: 4.0),
                child: Divider(
                    color: AppTheme.fhBorderColor.withOpacity(0.3),
                    height: 1,
                    thickness: 0.5),
              ),
              Padding(
                padding:
                    const EdgeInsets.only(top: 6.0), // Add padding above action
                child: actionSection!,
              ),
            ]
          ],
        ),
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/ui/artifact_card.dart ---

--- START OF FILE lib/src/widgets/ui/enemy_info_card.dart ---
// lib/src/widgets/ui/enemy_info_card.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/models/game_models.dart'; // For EnemyTemplate
import 'package:arcane/src/theme/app_theme.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:provider/provider.dart';
import 'package:arcane/src/providers/game_provider.dart';

class EnemyInfoCardWidget extends StatelessWidget {
  final EnemyTemplate enemy;
  final int playerLevel;
  final VoidCallback onStartGame;

  const EnemyInfoCardWidget({
    super.key,
    required this.enemy,
    required this.playerLevel,
    required this.onStartGame,
  });

  Map<String, dynamic> _getEnemyDifficulty(int enemyMinLevel, int pLevel) {
    final levelDiff = enemyMinLevel - pLevel;
    if (levelDiff <= -3) {
      return {
        'text': "Trivial",
        'color': AppTheme.fhAccentGreen.withOpacity(0.7)
      };
    }
    if (levelDiff <= -1) {
      return {'text': "Easy", 'color': AppTheme.fhAccentGreen};
    }
    if (levelDiff == 0) {
      return {'text': "Moderate", 'color': AppTheme.fhAccentTeal};
    }
    if (levelDiff == 1) {
      return {'text': "Challenging", 'color': AppTheme.fhAccentOrange};
    }
    return {'text': "Deadly", 'color': AppTheme.fhAccentRed, 'isBold': true};
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final difficulty = _getEnemyDifficulty(enemy.minPlayerLevel, playerLevel);
    final Color dynamicAccent =
        Provider.of<GameProvider>(context, listen: false)
                .getSelectedTask()
                ?.taskColor ??
            theme.colorScheme.secondary;
    final Color cardTextColorOnAccent =
        ThemeData.estimateBrightnessForColor(dynamicAccent) == Brightness.dark
            ? AppTheme.fhTextPrimary
            : AppTheme.fhBgDark;

    // Placeholder for enemy icon/image. Using MDI icon for now.
    IconData enemyVisualIcon = MdiIcons.skullCrossbonesOutline;
    if (enemy.theme == 'nature') enemyVisualIcon = MdiIcons.treeOutline;
    if (enemy.theme == 'ancient') enemyVisualIcon = MdiIcons.templeHinduOutline;
    if (enemy.theme == 'tech') enemyVisualIcon = MdiIcons.robotOutline;

    return Card(
      elevation: 0,
      color: AppTheme.fhBgLight.withOpacity(0.8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(6.0),
        side: BorderSide(
            color: AppTheme.fhBorderColor.withOpacity(0.7), width: 1),
      ),
      child: InkWell(
        onTap: onStartGame,
        borderRadius: BorderRadius.circular(6.0),
        hoverColor: dynamicAccent.withOpacity(0.05),
        child: Padding(
          padding: const EdgeInsets.all(10.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Container(
                        width: 50,
                        height: 50,
                        padding: const EdgeInsets.all(4),
                        decoration: BoxDecoration(
                            color: AppTheme.fhBgDark.withOpacity(0.6),
                            borderRadius: BorderRadius.circular(4)),
                        child: Center(
                            child: Icon(enemyVisualIcon,
                                size: 30,
                                color:
                                    AppTheme.fhTextSecondary.withOpacity(0.7))),
                      ),
                      const SizedBox(width: 10),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              enemy.name,
                              style: theme.textTheme.titleMedium?.copyWith(
                                  fontFamily: AppTheme.fontDisplay,
                                  fontWeight: FontWeight.bold,
                                  color: AppTheme.fhTextPrimary,
                                  fontSize: 15),
                              maxLines: 2,
                              overflow: TextOverflow.ellipsis,
                            ),
                            if (enemy.theme != null)
                              Text(
                                "${enemy.theme!.toUpperCase()} ENTITY",
                                style: theme.textTheme.labelSmall?.copyWith(
                                    color: AppTheme.fhAccentPurple
                                        .withOpacity(0.8),
                                    fontSize: 9,
                                    letterSpacing: 0.5,
                                    fontWeight: FontWeight.w600),
                              ),
                          ],
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Flexible(
                          child: _StatChip(
                              icon: MdiIcons.heartOutline,
                              value: enemy.health.toString(),
                              color: AppTheme.fhAccentGreen)),
                      Flexible(
                          child: _StatChip(
                              icon: MdiIcons.sword,
                              value: enemy.attack.toString(),
                              color: AppTheme.fhAccentOrange)),
                      Flexible(
                          child: _StatChip(
                              icon: MdiIcons.shieldOutline,
                              value: enemy.defense.toString(),
                              color: AppTheme.fhAccentTeal)),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    enemy.description,
                    style: theme.textTheme.bodySmall?.copyWith(
                        color: AppTheme.fhTextSecondary.withOpacity(0.8),
                        fontStyle: FontStyle.italic,
                        fontSize: 11,
                        height: 1.3),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 8),
                  Container(
                    padding:
                        const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                    decoration: BoxDecoration(
                        color: (difficulty['color'] as Color).withOpacity(0.15),
                        borderRadius: BorderRadius.circular(4),
                        border: Border.all(
                            color:
                                (difficulty['color'] as Color).withOpacity(0.5),
                            width: 0.5)),
                    child: Text(
                      "Threat Level: ${difficulty['text'] as String}",
                      style: theme.textTheme.labelSmall?.copyWith(
                        color: difficulty['color'] as Color,
                        fontWeight: (difficulty['isBold'] as bool? ?? false)
                            ? FontWeight.bold
                            : FontWeight.w600,
                        fontSize: 10,
                      ),
                    ),
                  ),
                ],
              ),
              const Spacer(), // Push button to bottom
              Padding(
                padding: const EdgeInsets.only(top: 10.0),
                child: ElevatedButton(
                  onPressed: onStartGame,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: dynamicAccent,
                    foregroundColor: cardTextColorOnAccent,
                    padding: const EdgeInsets.symmetric(vertical: 10),
                    textStyle: const TextStyle(
                        fontSize: 12,
                        fontFamily: AppTheme.fontBody,
                        fontWeight: FontWeight.bold),
                  ),
                  child: const Text(
                    'ENGAGE TARGET',
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _StatChip extends StatelessWidget {
  final IconData icon;
  final String value;
  final Color color;

  const _StatChip(
      {required this.icon, required this.value, required this.color});

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(icon, size: 13, color: color.withOpacity(0.8)),
        const SizedBox(width: 4),
        Flexible(
          child: Text(
            value,
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                fontSize: 12,
                color: AppTheme.fhTextPrimary.withOpacity(0.9),
                fontWeight: FontWeight.w500),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }
}

--- END OF FILE lib/src/widgets/ui/enemy_info_card.dart ---

--- START OF FILE lib/src/widgets/ui/rhombus_checkbox.dart ---
// lib/src/widgets/ui/rhombus_checkbox.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'dart:math' as math;
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:provider/provider.dart';

enum CheckboxSize { small, medium }

class RhombusCheckbox extends StatelessWidget {
  final bool checked;
  final ValueChanged<bool?>? onChanged;
  final bool disabled;
  final CheckboxSize size;

  const RhombusCheckbox({
    super.key,
    required this.checked,
    required this.onChanged,
    this.disabled = false,
    this.size = CheckboxSize.medium,
  });

  @override
  Widget build(BuildContext context) {
    final double dimension =
        size == CheckboxSize.small ? 18.0 : 22.0; // Overall tap target
    final double iconSize = size == CheckboxSize.small ? 12.0 : 14.0;
    final double visualDimension =
        size == CheckboxSize.small ? 15.0 : 18.0; // Visual size of rhombus
    final gameProvider = Provider.of<GameProvider>(context, listen: false);

    Color bgColor = checked
        ? (gameProvider.getSelectedTask()?.taskColor ??
            AppTheme.fhAccentTealFixed)
        : AppTheme.fhBgMedium;
    Color borderColor = disabled
        ? (checked
            ? (gameProvider.getSelectedTask()?.taskColor ??
                    AppTheme.fhAccentTealFixed)
                .withOpacity(0.5)
            : AppTheme.fhBorderColor.withOpacity(0.5))
        : (checked
            ? (gameProvider.getSelectedTask()?.taskColor ??
                AppTheme.fhAccentTealFixed)
            : AppTheme.fhBorderColor);

    if (disabled && checked) {
      bgColor = (gameProvider.getSelectedTask()?.taskColor ??
              AppTheme.fhAccentTealFixed)
          .withOpacity(0.6);
    } else if (disabled && !checked) {
      bgColor = AppTheme.fhBgLight.withOpacity(0.4);
    }

    return InkWell(
      onTap: disabled ? null : () => onChanged?.call(!checked),
      borderRadius: BorderRadius.circular(
          dimension / 4), // Make tap effect slightly rounded
      child: SizedBox(
        width: dimension,
        height: dimension,
        child: Stack(
          alignment: Alignment.center,
          children: [
            Transform.rotate(
              angle: math.pi / 4, // 45 degrees
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 150),
                height: visualDimension *
                    0.9, // Make it slightly smaller than container for padding
                width: visualDimension * 0.9,
                decoration: BoxDecoration(
                  color: bgColor,
                  border: Border.all(
                    color: borderColor,
                    width: 1.5, // Slightly thicker border
                  ),
                  // No boxShadow for flatter screenshot-like style
                  // borderRadius: BorderRadius.circular(2), // Optional: slight rounding of corners
                ),
              ),
            ),
            if (checked)
              Icon(
                MdiIcons.checkBold, // Using MDI check for a bolder look
                size: iconSize,
                color: disabled
                    ? AppTheme.fhTextSecondary.withOpacity(0.7)
                    : AppTheme.fhBgDark, // Dark check on light teal
              ),
          ],
        ),
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/ui/rhombus_checkbox.dart ---

--- START OF FILE lib/src/widgets/views/artifact_shop_view.dart ---
// lib/src/widgets/views/artifact_shop_view.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:arcane/src/widgets/ui/artifact_card.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class ArtifactShopView extends StatelessWidget {
  const ArtifactShopView({super.key});

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    final currentTask = gameProvider.getSelectedTask();
    final String? currentTaskTheme = currentTask?.theme;
    final Color dynamicAccent =
        currentTask?.taskColor ?? theme.colorScheme.secondary;
    final Color buttonTextColor =
        ThemeData.estimateBrightnessForColor(dynamicAccent) == Brightness.dark
            ? AppTheme.fhTextPrimary
            : AppTheme.fhBgDark;

    final itemsToShow = gameProvider.artifactTemplatesList.where((template) {
      final bool themeMatch = currentTaskTheme == null ||
          template.theme == null ||
          template.theme == currentTaskTheme ||
          template.theme == 'general'; // Added general theme
      return !template.type.contains("powerup_dev") && themeMatch;
    }).toList()
      ..sort((a, b) {
        if (currentTaskTheme != null) {
          final bool aIsThemed = a.theme == currentTaskTheme;
          final bool bIsThemed = b.theme == currentTaskTheme;
          if (aIsThemed && !bIsThemed) return -1;
          if (!aIsThemed && bIsThemed) return 1;
        }
        if (a.cost != b.cost) return a.cost.compareTo(b.cost);
        return a.name.compareTo(b.name);
      });

    return SingleChildScrollView(
      padding: const EdgeInsets.only(
          bottom: 16, right: 4, left: 4), // Added left padding
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 16.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(MdiIcons.storefrontOutline,
                    color: dynamicAccent, size: 32),
                const SizedBox(width: 12),
                Text(
                  "Brok & Sindri's Wares",
                  style: theme.textTheme.headlineSmall?.copyWith(
                      fontFamily: AppTheme.fontDisplay,
                      color: AppTheme
                          .fhTextPrimary), // Primary text color for title
                ),
              ],
            ),
          ),
          if (itemsToShow.isEmpty)
            Padding(
              padding: const EdgeInsets.all(24.0),
              child: Text(
                "No wares currently matching your quest's focus. Perhaps try a different quest or generate more content via Settings?",
                textAlign: TextAlign.center,
                style: theme.textTheme.bodyMedium
                    ?.copyWith(color: AppTheme.fhTextSecondary),
              ),
            )
          else
            LayoutBuilder(builder: (context, constraints) {
              int crossAxisCount = 2;
              if (constraints.maxWidth > 900) {
                crossAxisCount = 4; // Adjusted breakpoints
              } else if (constraints.maxWidth > 600)
                crossAxisCount = 3;
              else if (constraints.maxWidth < 400) crossAxisCount = 1;

              double itemWidth =
                  (constraints.maxWidth - (crossAxisCount + 1) * 10) /
                      crossAxisCount; // 10 for padding
              double childAspectRatio =
                  itemWidth / 270; // Adjusted height for better card display

              return GridView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                padding: const EdgeInsets.all(10.0),
                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: crossAxisCount,
                  crossAxisSpacing: 10.0,
                  mainAxisSpacing: 10.0,
                  childAspectRatio:
                      childAspectRatio.clamp(0.65, 0.9), // Adjusted clamp
                ),
                itemCount: itemsToShow.length,
                itemBuilder: (context, index) {
                  final template = itemsToShow[index];
                  final bool canAfford = gameProvider.coins >= template.cost;
                  final bool isOwned = template.type != 'powerup' &&
                      gameProvider.artifacts
                          .any((art) => art.templateId == template.id);

                  return ArtifactCardWidget(
                    template: template,
                    cost: template.cost,
                    actionSection: SizedBox(
                      width: double.infinity,
                      child: ElevatedButton.icon(
                        icon: Icon(
                            isOwned
                                ? MdiIcons.checkCircleOutline
                                : (canAfford
                                    ? MdiIcons.cartPlus
                                    : MdiIcons.cartOff),
                            size: 16),
                        label: Text(isOwned
                            ? 'ACQUIRED'
                            : (canAfford
                                ? '${template.cost} Ø'
                                : 'Cost: ${template.cost} Ø')),
                        onPressed: (!canAfford || isOwned)
                            ? null
                            : () => gameProvider.buyArtifact(template.id),
                        style: ElevatedButton.styleFrom(
                            backgroundColor: isOwned
                                ? AppTheme.fhBgDark.withOpacity(0.6)
                                : (canAfford
                                    ? dynamicAccent
                                    : AppTheme.fhAccentRed.withOpacity(0.7)),
                            foregroundColor: isOwned
                                ? AppTheme.fhTextSecondary.withOpacity(0.7)
                                : (canAfford
                                    ? buttonTextColor
                                    : AppTheme.fhTextPrimary),
                            padding: const EdgeInsets.symmetric(
                                horizontal: 12,
                                vertical: 8), // Adjusted padding
                            textStyle: const TextStyle(
                                fontSize: 11,
                                fontFamily: AppTheme.fontBody,
                                fontWeight: FontWeight.bold),
                            disabledBackgroundColor:
                                AppTheme.fhBgDark.withOpacity(0.5),
                            disabledForegroundColor:
                                AppTheme.fhTextSecondary.withOpacity(0.5),
                            shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(4))),
                      ),
                    ),
                  );
                },
              );
            }),
        ],
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/views/artifact_shop_view.dart ---

--- START OF FILE lib/src/widgets/views/blacksmith_view.dart ---
// lib/src/widgets/views/blacksmith_view.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/utils/constants.dart';
import 'package:arcane/src/utils/helpers.dart' as helper;
import 'package:arcane/src/widgets/ui/artifact_card.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class BlacksmithView extends StatelessWidget {
  const BlacksmithView({super.key});

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    final Color dynamicAccent = gameProvider.getSelectedTask()?.taskColor ??
        theme.colorScheme.secondary;
    final Color buttonTextColor =
        ThemeData.estimateBrightnessForColor(dynamicAccent) == Brightness.dark
            ? AppTheme.fhTextPrimary
            : AppTheme.fhBgDark;

    final upgradableArtifacts = gameProvider.artifacts.where((art) {
      final template = gameProvider.artifactTemplatesList.firstWhere(
          (t) => t.id == art.templateId,
          orElse: () => ArtifactTemplate(
              id: '', name: '', type: '', description: '', cost: 0, icon: ''));
      return template.id.isNotEmpty;
    }).toList();

    if (upgradableArtifacts.isEmpty) {
      return Center(
          child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(MdiIcons.hammerSickle, size: 48, color: dynamicAccent),
            const SizedBox(height: 16),
            Text("Hephaestus' Forge",
                style: theme.textTheme.headlineSmall?.copyWith(
                    fontFamily: AppTheme.fontDisplay,
                    color: AppTheme
                        .fhTextPrimary)), // Use primary text color for title
            const SizedBox(height: 8),
            Text(
              "Your satchel is empty, warrior. Acquire some artifacts to enhance or sell!",
              textAlign: TextAlign.center,
              style: theme.textTheme.bodyMedium
                  ?.copyWith(color: AppTheme.fhTextSecondary),
            ),
          ],
        ),
      ));
    }

    int getUpgradeCost(ArtifactTemplate template, int currentLevel) {
      if (template.type == 'powerup' ||
          template.maxLevel == null ||
          currentLevel >= template.maxLevel!) {
        return 9999999; // effectively infinity
      }
      return (template.cost *
              blacksmithUpgradeCostMultiplier *
              helper.xpLevelMultiplierPow(
                  1.2, currentLevel - 1)) // Keep 1.2 for blacksmith logic
          .floor();
    }

    int getSellPrice(ArtifactTemplate template, OwnedArtifact ownedArtifact) {
      double sellMultiplier = 1.0;
      if (template.type == 'powerup' &&
          template.uses != null &&
          template.uses! > 0 &&
          ownedArtifact.uses != null) {
        sellMultiplier = (ownedArtifact.uses! / template.uses!);
      }
      return (template.cost * artifactSellPercentage * sellMultiplier).floor();
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.only(
          bottom: 16, right: 4, left: 4), // Added left padding
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 16.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(MdiIcons.hammerWrench, color: dynamicAccent, size: 32),
                const SizedBox(width: 12),
                Text(
                  "Hephaestus' Forge",
                  style: theme.textTheme.headlineSmall?.copyWith(
                      fontFamily: AppTheme.fontDisplay,
                      color: AppTheme
                          .fhTextPrimary), // Use primary text color for title
                ),
              ],
            ),
          ),
          LayoutBuilder(builder: (context, constraints) {
            int crossAxisCount = 2;
            if (constraints.maxWidth > 900) {
              crossAxisCount = 4; // Adjusted breakpoints
            } else if (constraints.maxWidth > 600)
              crossAxisCount = 3;
            else if (constraints.maxWidth < 400) crossAxisCount = 1;

            double itemWidth =
                (constraints.maxWidth - (crossAxisCount + 1) * 10) /
                    crossAxisCount; // 10 for padding
            double childAspectRatio = itemWidth /
                280; // Adjusted for potentially taller cards with more actions

            return GridView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              padding: const EdgeInsets.all(10.0),
              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: crossAxisCount,
                crossAxisSpacing: 10.0,
                mainAxisSpacing: 10.0,
                childAspectRatio:
                    childAspectRatio.clamp(0.6, 0.85), // Adjusted clamp
              ),
              itemCount: upgradableArtifacts.length,
              itemBuilder: (context, index) {
                final ownedArt = upgradableArtifacts[index];
                final template = gameProvider.artifactTemplatesList.firstWhere(
                    (t) => t.id == ownedArt.templateId,
                    orElse: () => ArtifactTemplate(
                        id: '',
                        name: '',
                        type: '',
                        description: '',
                        cost: 0,
                        icon: ''));
                if (template.id == '') return const SizedBox.shrink();

                final upgradeCost =
                    getUpgradeCost(template, ownedArt.currentLevel);
                final sellPrice = getSellPrice(template, ownedArt);
                final bool canUpgrade = template.type != 'powerup' &&
                    template.maxLevel != null &&
                    ownedArt.currentLevel < template.maxLevel!;
                final bool canAffordUpgrade = gameProvider.coins >= upgradeCost;

                return ArtifactCardWidget(
                  template: template,
                  ownedArtifact: ownedArt,
                  actionSection: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      if (template.type != 'powerup')
                        Padding(
                          padding: const EdgeInsets.only(bottom: 6.0, top: 4.0),
                          child: Center(
                            // Center the sell price
                            child: Text(
                              'Sell Value: $sellPrice Ø',
                              style: theme.textTheme.labelSmall?.copyWith(
                                  color:
                                      AppTheme.fhTextSecondary.withOpacity(0.8),
                                  fontSize: 10),
                            ),
                          ),
                        ),
                      Row(
                        children: [
                          if (template.type != 'powerup' &&
                              template.maxLevel != null)
                            Expanded(
                              child: ElevatedButton.icon(
                                icon: Icon(
                                    canUpgrade
                                        ? MdiIcons.arrowUpBoldCircleOutline
                                        : MdiIcons.checkCircleOutline,
                                    size: 14),
                                label: Text(
                                    canUpgrade
                                        ? (canAffordUpgrade
                                            ? 'UPGRADE ($upgradeCost Ø)'
                                            : '$upgradeCost Ø')
                                        : 'MAX LEVEL',
                                    style: TextStyle(fontSize: 10)),
                                onPressed: (canUpgrade && canAffordUpgrade)
                                    ? () => gameProvider
                                        .upgradeArtifact(ownedArt.uniqueId)
                                    : null,
                                style: ElevatedButton.styleFrom(
                                    backgroundColor: dynamicAccent,
                                    foregroundColor: buttonTextColor,
                                    padding: const EdgeInsets.symmetric(
                                        horizontal: 6,
                                        vertical: 6), // Adjusted padding
                                    textStyle: const TextStyle(
                                        fontFamily: AppTheme.fontBody,
                                        fontWeight: FontWeight.bold),
                                    disabledBackgroundColor:
                                        AppTheme.fhBgDark.withOpacity(0.5),
                                    disabledForegroundColor: AppTheme
                                        .fhTextSecondary
                                        .withOpacity(0.5),
                                    shape: RoundedRectangleBorder(
                                        borderRadius:
                                            BorderRadius.circular(4))),
                              ),
                            ),
                          if (template.type != 'powerup' &&
                              template.maxLevel != null)
                            const SizedBox(width: 6.0), // Gap
                          if (template.type != 'powerup')
                            Expanded(
                              child: OutlinedButton.icon(
                                icon: Icon(MdiIcons.cashMinus, size: 14),
                                label: const Text('SELL',
                                    style: TextStyle(fontSize: 10)),
                                onPressed: () => gameProvider
                                    .sellArtifact(ownedArt.uniqueId),
                                style: OutlinedButton.styleFrom(
                                    foregroundColor: AppTheme.fhAccentOrange,
                                    side: const BorderSide(
                                        color: AppTheme.fhAccentOrange,
                                        width: 1), // Thicker border
                                    padding: const EdgeInsets.symmetric(
                                        horizontal: 6,
                                        vertical: 6), // Adjusted padding
                                    textStyle: const TextStyle(
                                        fontFamily: AppTheme.fontBody,
                                        fontWeight: FontWeight.bold),
                                    shape: RoundedRectangleBorder(
                                        borderRadius:
                                            BorderRadius.circular(4))),
                              ),
                            ),
                        ],
                      ),
                    ],
                  ),
                );
              },
            );
          }),
        ],
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/views/blacksmith_view.dart ---

--- START OF FILE lib/src/widgets/views/chatbot_view.dart ---
// lib/src/widgets/views/chatbot_view.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';


class ChatbotView extends StatefulWidget {
  const ChatbotView({super.key});

  @override
  State<ChatbotView> createState() => _ChatbotViewState();
}

class _ChatbotViewState extends State<ChatbotView> {
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  bool _isSending = false;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      // Ensure chatbot memory is initialized/loaded when view is first shown
      Provider.of<GameProvider>(context, listen: false).initializeChatbotMemory();
      _scrollToBottom();
    });
  }

  @override
  void didUpdateWidget(covariant ChatbotView oldWidget) {
    super.didUpdateWidget(oldWidget);
    WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());
  }

  void _scrollToBottom() {
    if (_scrollController.hasClients) {
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  Future<void> _sendMessage() async {
    if (_messageController.text.trim().isEmpty) return;
    final messageText = _messageController.text.trim();
    _messageController.clear();
    FocusScope.of(context).unfocus(); // Unfocus after sending

    setState(() => _isSending = true);

    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    await gameProvider.sendMessageToChatbot(messageText);

    if (mounted) {
      setState(() => _isSending = false);
      WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom());
    }
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    final chatbotMemory = gameProvider.chatbotMemory;
    final Color dynamicAccent = gameProvider.getSelectedTask()?.taskColor ?? theme.colorScheme.secondary;


    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Column(
        children: [
          // Restart Session Button
          Padding(
            padding: const EdgeInsets.only(bottom: 8.0),
            child: Align(
              alignment: Alignment.centerRight,
              child: TextButton.icon(
                icon: Icon(MdiIcons.refresh, size: 16, color: AppTheme.fhTextSecondary),
                label: Text("Restart Session", style: TextStyle(color: AppTheme.fhTextSecondary, fontSize: 12)),
                onPressed: () async {
                  final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                            title: Text("Restart Chat?", style: TextStyle(color: dynamicAccent)),
                            content: const Text("This will clear the current conversation history, but remembered items and summaries will remain. Continue?"),
                            actions: [
                              TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text("Cancel")),
                              ElevatedButton(
                                onPressed: () => Navigator.of(ctx).pop(true),
                                style: ElevatedButton.styleFrom(backgroundColor: dynamicAccent),
                                child: Text("Restart", style: TextStyle(color: ThemeData.estimateBrightnessForColor(dynamicAccent) == Brightness.dark ? AppTheme.fhTextPrimary : AppTheme.fhBgDark)),
                              ),
                            ],
                          ));
                  if (confirm == true) {
                    gameProvider.chatbotMemory.conversationHistory.clear();
                    // Re-initialize with the welcome message
                    gameProvider.initializeChatbotMemory();
                  }
                },
              ),
            ),
          ),
          Expanded(
            child: chatbotMemory.conversationHistory.isEmpty && !_isSending
                ? Center(
                    child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(MdiIcons.robotHappyOutline, size: 48, color: dynamicAccent.withOpacity(0.7)),
                      const SizedBox(height: 16),
                      Text(
                        "Arcane Advisor Online",
                        style: theme.textTheme.headlineSmall?.copyWith(color: dynamicAccent),
                      ),
                       const SizedBox(height: 8),
                      Text(
                        "Ask about your past week's summary, completed goals, or tell me things to 'Remember'.",
                        textAlign: TextAlign.center,
                        style: theme.textTheme.bodyMedium?.copyWith(color: AppTheme.fhTextSecondary),
                      ),
                    ],
                  ))
                : ListView.builder(
                    controller: _scrollController,
                    itemCount: chatbotMemory.conversationHistory.length + (_isSending ? 1 : 0),
                    itemBuilder: (context, index) {
                       if (_isSending && index == chatbotMemory.conversationHistory.length) {
                        return _buildMessageBubble(
                          ChatbotMessage(
                            id: 'typing',
                            text: '...',
                            sender: MessageSender.bot,
                            timestamp: DateTime.now(),
                          ),
                          theme,
                          dynamicAccent,
                          true 
                        );
                      }
                      final message = chatbotMemory.conversationHistory[index];
                      return _buildMessageBubble(message, theme, dynamicAccent, false);
                    },
                  ),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0, horizontal: 4.0),
            child: Row(
              children: [
                Expanded(
                  child: TextField(
                    controller: _messageController,
                    decoration: InputDecoration(
                      hintText: 'Send a message to Arcane Advisor...',
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(25.0),
                        borderSide: BorderSide(color: AppTheme.fhBorderColor),
                      ),
                      focusedBorder: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(25.0),
                        borderSide: BorderSide(color: dynamicAccent, width: 1.5),
                      ),
                      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
                    ),
                    onSubmitted: (_) => _sendMessage(),
                    style: TextStyle(color: AppTheme.fhTextPrimary, fontSize: 14),
                  ),
                ),
                const SizedBox(width: 8),
                IconButton(
                  icon: _isSending
                      ? SizedBox(width: 24, height: 24, child: CircularProgressIndicator(strokeWidth: 2.5, color: dynamicAccent))
                      : Icon(MdiIcons.sendCircleOutline, color: dynamicAccent),
                  onPressed: _isSending ? null : _sendMessage,
                  iconSize: 28,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMessageBubble(ChatbotMessage message, ThemeData theme, Color dynamicAccent, bool isTyping) {
    final bool isUser = message.sender == MessageSender.user;
    final Color bubbleColor = isUser ? dynamicAccent : AppTheme.fhBgMedium;
    final Color textColor = isUser 
        ? (ThemeData.estimateBrightnessForColor(dynamicAccent) == Brightness.dark ? AppTheme.fhTextPrimary : AppTheme.fhBgDark) 
        : AppTheme.fhTextPrimary;
    
    final CrossAxisAlignment crossAxisAlignment = isUser ? CrossAxisAlignment.end : CrossAxisAlignment.start;
    final MainAxisAlignment mainAxisAlignment = isUser ? MainAxisAlignment.end : MainAxisAlignment.start;


    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        mainAxisAlignment: mainAxisAlignment,
        children: [
          Flexible( // Makes sure the bubble doesn't overflow
            child: Container(
              constraints: BoxConstraints(maxWidth: MediaQuery.of(context).size.width * 0.75), // Max width for bubble
              padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
              decoration: BoxDecoration(
                color: bubbleColor,
                borderRadius: BorderRadius.only(
                  topLeft: const Radius.circular(18),
                  topRight: const Radius.circular(18),
                  bottomLeft: isUser ? const Radius.circular(18) : const Radius.circular(4),
                  bottomRight: isUser ? const Radius.circular(4) : const Radius.circular(18),
                ),
                border: Border.all(color: bubbleColor.withOpacity(0.5), width: 0.5)
              ),
              child: Column(
                crossAxisAlignment: crossAxisAlignment,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    message.text,
                    style: theme.textTheme.bodyMedium?.copyWith(color: textColor, fontSize: 13.5, height: 1.4),
                  ),
                  if (!isTyping) ...[
                    const SizedBox(height: 4),
                    Text(
                      DateFormat('HH:mm').format(message.timestamp.toLocal()),
                      style: theme.textTheme.labelSmall?.copyWith(color: textColor.withOpacity(0.7), fontSize: 9),
                    ),
                  ]
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }


   @override
  void dispose() {
    _messageController.dispose();
    _scrollController.dispose();
    super.dispose();
  }
}
--- END OF FILE lib/src/widgets/views/chatbot_view.dart ---

--- START OF FILE lib/src/widgets/views/daily_summary_view.dart ---
// lib/src/widgets/views/daily_summary_view.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:provider/provider.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:intl/intl.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class DailySummaryView extends StatefulWidget {
  const DailySummaryView({super.key});

  @override
  State<DailySummaryView> createState() => _DailySummaryViewState();
}

class _DailySummaryViewState extends State<DailySummaryView> {
  String? _selectedDate;
  int _touchedPieIndex = -1;
  int _hoveredEmotionRating = 0; // For emotion logging UI

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    final availableDates = gameProvider.completedByDay.keys.toList();
    availableDates.sort((a, b) => b.compareTo(a)); // Sort descending
    if (_selectedDate == null && availableDates.isNotEmpty) {
      _selectedDate = availableDates.first;
    } else if (_selectedDate != null &&
        !availableDates.contains(_selectedDate)) {
      // If current selection is no longer valid (e.g. data cleared)
      _selectedDate = availableDates.isNotEmpty ? availableDates.first : null;
    }
  }

  Widget _buildEmotionLoggingRow(
      GameProvider gameProvider, String date, ThemeData theme) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: List.generate(5, (index) {
        final rating = index + 1;
        return MouseRegion(
          onEnter: (_) => setState(() => _hoveredEmotionRating = rating),
          onExit: (_) => setState(() => _hoveredEmotionRating = 0),
          child: GestureDetector(
            onTap: () {
              gameProvider.logEmotion(date, rating);
              setState(() => _hoveredEmotionRating = 0);
            },
            child: AnimatedScale(
              scale: _hoveredEmotionRating == rating ? 1.2 : 1.0,
              duration: const Duration(milliseconds: 150),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    _getEmotionIcon(rating),
                    size: 32,
                    color: _hoveredEmotionRating >= rating
                        ? _getEmotionColor(rating, theme)
                        : AppTheme.fhTextDisabled,
                  ),
                  const SizedBox(height: 4),
                  Text(_getEmotionLabel(rating),
                      style: theme.textTheme.labelSmall?.copyWith(
                          color: _hoveredEmotionRating >= rating
                              ? _getEmotionColor(rating, theme)
                              : AppTheme.fhTextDisabled,
                          fontWeight: _hoveredEmotionRating == rating
                              ? FontWeight.bold
                              : FontWeight.normal))
                ],
              ),
            ),
          ),
        );
      }),
    );
  }

  IconData _getEmotionIcon(int rating) {
    switch (rating) {
      case 1:
        return MdiIcons.emoticonSadOutline;
      case 2:
        return MdiIcons.emoticonConfusedOutline;
      case 3:
        return MdiIcons.emoticonNeutralOutline;
      case 4:
        return MdiIcons.emoticonHappyOutline;
      case 5:
        return MdiIcons.emoticonExcitedOutline;
      default:
        return MdiIcons.emoticonOutline;
    }
  }

  String _getEmotionLabel(int rating) {
    switch (rating) {
      case 1:
        return "Awful";
      case 2:
        return "Bad";
      case 3:
        return "Okay";
      case 4:
        return "Good";
      case 5:
        return "Great";
      default:
        return "";
    }
  }

  Color _getEmotionColor(int rating, ThemeData theme) {
    // Use theme accents for consistency where appropriate
    switch (rating) {
      case 1:
        return AppTheme.fhAccentRed;
      case 2:
        return AppTheme.fhAccentOrange;
      case 3:
        return AppTheme.fhAccentGold;
      case 4:
        return AppTheme.fhAccentGreen;
      case 5:
        return theme
            .colorScheme.primary; // Use dynamic primary accent for best rating
      default:
        return AppTheme.fhTextDisabled;
    }
  }

  Widget _buildEmotionCurveChart(
      List<EmotionLog> logs, ThemeData theme, Color dynamicAccent) {
    if (logs.length < 2) {
      return SizedBox(
        height: 200,
        child: Center(
            child: Text(
          "Not enough emotion data for a trend line yet (need at least 2 logs for the day).",
          textAlign: TextAlign.center,
          style: theme.textTheme.bodyMedium?.copyWith(
              color: AppTheme.fhTextSecondary, fontStyle: FontStyle.italic),
        )),
      );
    }

    // Calculate FlSpot data. X-value is hours from midnight of the log's day.
    List<FlSpot> spots = logs.map((log) {
      final DateTime logDayMidnight =
          DateTime(log.timestamp.year, log.timestamp.month, log.timestamp.day);
      final Duration timeSinceMidnight =
          log.timestamp.difference(logDayMidnight);
      double xValue =
          timeSinceMidnight.inMinutes / 60.0; // e.g., 10.5 for 10:30 AM
      return FlSpot(xValue, log.rating.toDouble());
    }).toList();

    double minX, maxX;

    // Determine the actual min/max X values from the data points.
    // Note: logs.length is guaranteed to be >= 2 here, so spots will not be empty.
    double dataMinX = spots.map((s) => s.x).reduce((a, b) => a < b ? a : b);
    double dataMaxX = spots.map((s) => s.x).reduce((a, b) => a > b ? a : b);

    if (dataMaxX == dataMinX) {
      // If all points have the same x-coordinate, create a default window (e.g., +/- 1 hour).
      minX = dataMinX - 1.0;
      maxX = dataMaxX + 1.0;
    } else {
      // Add padding (e.g., 5% of the data range) to each side.
      double range = dataMaxX - dataMinX;
      minX = dataMinX - range * 0.05;
      maxX = dataMaxX + range * 0.05;
    }

    // Clamp the calculated min/max X to the valid 24-hour range [0.0, 23.99].
    // Ensure minX doesn't go too high, allowing some space for maxX.
    minX = minX.clamp(0.0,
        23.49); // Max value for minX, allowing at least ~30min for maxX (0.5h).
    // Ensure maxX is greater than minX and within the upper boundary.
    maxX = maxX.clamp(
        minX + 0.1, 23.99); // Ensure at least a 6-minute (0.1 hour) range.

    // Fallback for very small or invalid ranges after clamping.
    if (maxX - minX < 0.2) {
      // If range is less than 12 minutes (0.2 hours).
      // Try to center a 1-hour window around the original data midpoint.
      double midDataX = (dataMinX + dataMaxX) / 2.0;
      minX = (midDataX - 0.5).clamp(0.0,
          23.0); // Clamp minX to allow a 1-hour window up to 23.99 for maxX.
      maxX = (midDataX + 0.5).clamp(minX + 0.1, 23.99); // Ensure minX < maxX.

      // If still problematic (e.g., data was at extreme edges or 1-hour window failed),
      // use the full day as a last resort.
      if (maxX <= minX) {
        minX = 0.0;
        maxX = 23.99;
      }
    }

    // --- The rest of the method uses the calculated minX and maxX ---

    return SizedBox(
      height: 200,
      child: LineChart(
        LineChartData(
          minX: minX,
          maxX: maxX,
          minY: 0.5,
          maxY: 5.5,
          gridData: FlGridData(
            show: true,
            drawVerticalLine: true,
            horizontalInterval: 1,
            // Dynamic vertical grid based on the calculated time range
            verticalInterval: ((maxX - minX) / 5)
                .clamp(0.2, 6.0), // Allow smaller intervals for zoomed views
            getDrawingHorizontalLine: (value) => FlLine(
                color: AppTheme.fhBorderColor.withOpacity(0.1),
                strokeWidth: 0.8),
            getDrawingVerticalLine: (value) => FlLine(
                color: AppTheme.fhBorderColor.withOpacity(0.1),
                strokeWidth: 0.8),
          ),
          titlesData: FlTitlesData(
            leftTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true,
                interval: 1,
                reservedSize: 30,
                getTitlesWidget: (value, meta) {
                  if (value >= 1 && value <= 5)
                    return Text(value.toInt().toString(),
                        style: TextStyle(
                            color: AppTheme.fhTextSecondary, fontSize: 10));
                  return const Text('');
                },
              ),
            ),
            bottomTitles: AxisTitles(
              sideTitles: SideTitles(
                showTitles: true,
                reservedSize: 30,
                // Dynamic bottom titles based on the calculated time range
                interval: ((maxX - minX) / 4)
                    .ceilToDouble()
                    .clamp(0.5, 6.0), // Allow smaller intervals
                getTitlesWidget: (value, meta) {
                  final hour = value.truncate().clamp(0, 23);
                  final minute = ((value - hour) * 60).round().clamp(0, 59);
                  return Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(
                        DateFormat('HH:mm')
                            .format(DateTime(2000, 1, 1, hour, minute)),
                        style: TextStyle(
                            color: AppTheme.fhTextSecondary,
                            fontSize: 10,
                            fontWeight: FontWeight.bold)),
                  );
                },
              ),
            ),
            topTitles:
                const AxisTitles(sideTitles: SideTitles(showTitles: false)),
            rightTitles:
                const AxisTitles(sideTitles: SideTitles(showTitles: false)),
          ),
          borderData: FlBorderData(
              show: true,
              border:
                  Border.all(color: AppTheme.fhBorderColor.withOpacity(0.2))),
          lineBarsData: [
            LineChartBarData(
              spots: spots,
              isCurved: true,
              color: dynamicAccent,
              barWidth: 3,
              isStrokeCapRound: true,
              dotData: FlDotData(
                show: true,
                getDotPainter: (spot, percent, barData, index) =>
                    FlDotCirclePainter(
                        radius: 4,
                        color: dynamicAccent.withOpacity(0.8),
                        strokeWidth: 1.5,
                        strokeColor: AppTheme.fhBgMedium),
              ),
              belowBarData: BarAreaData(
                  show: true, color: dynamicAccent.withOpacity(0.1)),
            ),
          ],
          lineTouchData: LineTouchData(
            touchTooltipData: LineTouchTooltipData(
              getTooltipColor: (touchedSpot) => AppTheme.fhBgMedium,
              getTooltipItems: (List<LineBarSpot> touchedSpots) {
                return touchedSpots
                    .map((LineBarSpot touchedSpot) {
                      final spotIndex = touchedSpot.spotIndex;
                      if (spotIndex < 0 || spotIndex >= logs.length)
                        return null; // Safety check
                      final logEntry = logs[spotIndex];
                      final DateTime time = logEntry.timestamp;

                      return LineTooltipItem(
                        '${_getEmotionLabel(touchedSpot.y.toInt())} (${touchedSpot.y.toInt()}/5) at ${DateFormat('HH:mm').format(time)}',
                        TextStyle(
                            color: dynamicAccent,
                            fontWeight: FontWeight.bold,
                            fontFamily: AppTheme.fontDisplay),
                      );
                    })
                    .where((item) => item != null)
                    .map((item) => item!)
                    .toList();
              },
            ),
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);

    final availableDates = gameProvider.completedByDay.keys.toList();
    availableDates.sort((a, b) => b.compareTo(a));

    if (_selectedDate == null && availableDates.isNotEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) setState(() => _selectedDate = availableDates.first);
      });
    } else if (_selectedDate != null &&
        !availableDates.contains(_selectedDate) &&
        availableDates.isNotEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) setState(() => _selectedDate = availableDates.first);
      });
    } else if (availableDates.isEmpty && _selectedDate != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) setState(() => _selectedDate = null);
      });
    }

    final summaryData = _selectedDate != null
        ? gameProvider.completedByDay[_selectedDate!]
        : null;
    final taskTimes = summaryData?['taskTimes'] as Map<String, dynamic>? ?? {};
    final subtasksCompleted =
        summaryData?['subtasksCompleted'] as List<dynamic>? ?? [];
    final checkpointsCompleted =
        summaryData?['checkpointsCompleted'] as List<dynamic>? ?? [];

    final List<EmotionLog> emotionLogsForSelectedDate = _selectedDate != null
        ? gameProvider.getEmotionLogsForDate(_selectedDate!)
        : [];

    final double totalMinutesToday = taskTimes.values
        .fold(0.0, (sum, time) => sum + (time as num).toDouble());

    final List<PieChartSectionData> pieChartSections = [];
    final List<Widget> legendItems = [];
    if (taskTimes.isNotEmpty) {
      taskTimes.forEach((taskId, time) {
        final task = gameProvider.mainTasks.firstWhere((t) => t.id == taskId,
            orElse: () => MainTask(
                id: '',
                name: 'Unknown Quest',
                description: '',
                theme: '',
                colorHex: AppTheme.fhTextDisabled.value
                    .toRadixString(16)
                    .substring(2)));
        final taskColor = task.taskColor;

        if (task.id != '') {
          final isTouched = pieChartSections.length == _touchedPieIndex;
          final fontSize = isTouched ? 13.0 : 11.0;
          final radius = isTouched ? 65.0 : 55.0;
          final titlePercentage = totalMinutesToday > 0
              ? ((time as num).toDouble() / totalMinutesToday * 100)
              : 0.0;

          pieChartSections.add(PieChartSectionData(
            color: taskColor,
            value: (time).toDouble(),
            title: '${titlePercentage.toStringAsFixed(0)}%',
            radius: radius,
            titleStyle: TextStyle(
                fontSize: fontSize,
                fontWeight: FontWeight.bold,
                color: AppTheme.fhBgDark,
                fontFamily: AppTheme.fontDisplay,
                shadows: const [Shadow(color: Colors.black38, blurRadius: 2)]),
            titlePositionPercentageOffset: 0.6,
          ));
          legendItems.add(Padding(
            padding: const EdgeInsets.symmetric(vertical: 3.0),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                    width: 12,
                    height: 12,
                    decoration: BoxDecoration(
                        color: taskColor,
                        border: Border.all(
                            color: AppTheme.fhBorderColor.withOpacity(0.5),
                            width: 0.5))),
                const SizedBox(width: 8),
                Text(task.name.split(' ')[0],
                    style: TextStyle(
                        fontSize: 12,
                        color: AppTheme.fhTextSecondary,
                        fontFamily: AppTheme.fontBody)),
              ],
            ),
          ));
        }
      });
    }

    final List<BarChartGroupData> weeklyBarGroups = [];
    final today = DateTime.now();
    final List<String> last7DaysFormatted = [];
    for (int i = 6; i >= 0; i--) {
      final d = today.subtract(Duration(days: i));
      final dateStr = DateFormat('yyyy-MM-dd').format(d);
      final dayData = gameProvider.completedByDay[dateStr];
      final Map<String, dynamic> dailyTaskTimes =
          dayData != null && dayData['taskTimes'] != null
              ? dayData['taskTimes'] as Map<String, dynamic>
              : {};

      double dailyTotalMins = 0;
      String? dominantTaskId;
      int maxTime = 0;

      dailyTaskTimes.forEach((taskId, time) {
        final int currentTime = (time as num).toInt();
        dailyTotalMins += currentTime;
        if (currentTime > maxTime) {
          maxTime = currentTime;
          dominantTaskId = taskId;
        }
      });

      Color barColor = (gameProvider.getSelectedTask()?.taskColor ??
          AppTheme.fhAccentTealFixed);
      if (dominantTaskId != null) {
        final dominantTask = gameProvider.mainTasks.firstWhere(
            (t) => t.id == dominantTaskId,
            orElse: () => MainTask(
                id: '',
                name: '',
                description: '',
                theme: '',
                colorHex: (gameProvider.getSelectedTask()?.taskColor ??
                        AppTheme.fhAccentTealFixed)
                    .value
                    .toRadixString(16)
                    .substring(2)));
        barColor = dominantTask.taskColor;
      }

      weeklyBarGroups.add(BarChartGroupData(
        x: 6 - i,
        barRods: [
          BarChartRodData(
              toY: dailyTotalMins,
              color: barColor.withOpacity(0.85),
              width: 18,
              borderRadius: const BorderRadius.only(
                  topLeft: Radius.circular(3), topRight: Radius.circular(3)))
        ],
      ));
      last7DaysFormatted.add(DateFormat('EEE, MMM d').format(d));
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (availableDates.isEmpty)
            Center(
                child: Padding(
              padding: const EdgeInsets.symmetric(vertical: 32.0),
              child: Text("No mission logs recorded yet.",
                  style: theme.textTheme.bodyLarge?.copyWith(
                      color: AppTheme.fhTextSecondary,
                      fontStyle: FontStyle.italic)),
            ))
          else ...[
            DropdownButtonFormField<String>(
              value: _selectedDate,
              decoration: const InputDecoration(labelText: 'Select Date'),
              dropdownColor: AppTheme.fhBgMedium,
              items: availableDates.map((date) {
                return DropdownMenuItem(
                  value: date,
                  child: Text(DateFormat('MMMM d, yyyy (EEEE)')
                      .format(DateTime.parse(date))),
                );
              }).toList(),
              onChanged: (value) => setState(() => _selectedDate = value),
            ),
            const SizedBox(height: 24),
            if (_selectedDate != null) ...[
              Card(
                color: AppTheme.fhBgMedium,
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Text(
                    'Total Time Logged on ${DateFormat('MMMM d, yyyy').format(DateTime.parse(_selectedDate!))}: ${totalMinutesToday.toStringAsFixed(0)}m',
                    style: theme.textTheme.titleLarge?.copyWith(
                        color: AppTheme.fhAccentGreen,
                        fontWeight: FontWeight.bold),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              Padding(
                  padding: const EdgeInsets.symmetric(vertical: 12),
                  child: Text("How are you feeling?",
                      style: theme.textTheme.headlineSmall)),
              const SizedBox(height: 10),
              _buildEmotionLoggingRow(gameProvider, _selectedDate!, theme),
              const SizedBox(height: 8),
              if (emotionLogsForSelectedDate.isNotEmpty)
                Align(
                  alignment: Alignment.centerRight,
                  child: TextButton.icon(
                    icon: Icon(MdiIcons.deleteSweepOutline,
                        size: 16, color: AppTheme.fhAccentRed.withOpacity(0.7)),
                    label: Text("Delete Latest",
                        style: TextStyle(
                            color: AppTheme.fhAccentRed.withOpacity(0.7),
                            fontSize: 12)),
                    onPressed: () {
                      gameProvider.deleteLatestEmotionLog(_selectedDate!);
                    },
                  ),
                ),
              const SizedBox(height: 16),
              if (emotionLogsForSelectedDate.isNotEmpty) ...[
                Text("Emotion Trend:", style: theme.textTheme.headlineSmall),
                const SizedBox(height: 16),
                _buildEmotionCurveChart(
                    emotionLogsForSelectedDate,
                    theme,
                    gameProvider.getSelectedTask()?.taskColor ??
                        AppTheme.fhAccentTealFixed),
                const SizedBox(height: 30),
              ],
            ],
            if (pieChartSections.isNotEmpty) ...[
              Text("Time Distribution by Mission:",
                  style: theme.textTheme.headlineSmall),
              const SizedBox(height: 16),
              Row(
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
                  Expanded(
                    flex: 3,
                    child: SizedBox(
                      height: 220,
                      child: PieChart(
                        PieChartData(
                          pieTouchData: PieTouchData(
                            touchCallback:
                                (FlTouchEvent event, pieTouchResponse) {
                              setState(() {
                                if (!event.isInterestedForInteractions ||
                                    pieTouchResponse == null ||
                                    pieTouchResponse.touchedSection == null) {
                                  _touchedPieIndex = -1;
                                  return;
                                }
                                _touchedPieIndex = pieTouchResponse
                                    .touchedSection!.touchedSectionIndex;
                              });
                            },
                          ),
                          borderData: FlBorderData(show: false),
                          sectionsSpace: 2,
                          centerSpaceRadius: 50,
                          sections: pieChartSections,
                        ),
                      ),
                    ),
                  ),
                  if (legendItems.isNotEmpty)
                    Expanded(
                        flex: 2,
                        child: Padding(
                          padding: const EdgeInsets.only(left: 20.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: legendItems,
                          ),
                        ))
                ],
              ),
              const SizedBox(height: 30),
            ],
            Text("Last 7 Days Activity (Total Minutes):",
                style: theme.textTheme.headlineSmall),
            const SizedBox(height: 20),
            SizedBox(
              height: 280,
              child: BarChart(
                BarChartData(
                  alignment: BarChartAlignment.spaceAround,
                  maxY: weeklyBarGroups
                              .map((g) => g.barRods.first.toY)
                              .reduce((a, b) => a > b ? a : b) *
                          1.2 +
                      15,
                  barTouchData: BarTouchData(
                    touchTooltipData: BarTouchTooltipData(
                      getTooltipColor: (BarChartGroupData group) =>
                          AppTheme.fhBgMedium,
                      getTooltipItem: (group, groupIndex, rod, rodIndex) {
                        return BarTooltipItem(
                          '${last7DaysFormatted[group.x]}\n',
                          TextStyle(
                              color: AppTheme.fhTextPrimary,
                              fontWeight: FontWeight.bold,
                              fontFamily: AppTheme.fontDisplay),
                          children: <TextSpan>[
                            TextSpan(
                              text: '${rod.toY.toStringAsFixed(0)} min',
                              style: TextStyle(
                                  color: rod.color ??
                                      (gameProvider
                                              .getSelectedTask()
                                              ?.taskColor ??
                                          AppTheme.fhAccentTealFixed),
                                  fontWeight: FontWeight.w500,
                                  fontFamily: AppTheme.fontBody),
                            ),
                          ],
                        );
                      },
                    ),
                  ),
                  titlesData: FlTitlesData(
                    show: true,
                    rightTitles: const AxisTitles(
                        sideTitles: SideTitles(showTitles: false)),
                    topTitles: const AxisTitles(
                        sideTitles: SideTitles(showTitles: false)),
                    bottomTitles: AxisTitles(
                      sideTitles: SideTitles(
                        showTitles: true,
                        getTitlesWidget: (double value, TitleMeta meta) {
                          return SideTitleWidget(
                            meta: meta,
                            space: 10.0,
                            child: Text(
                                last7DaysFormatted[value.toInt()]
                                    .substring(0, 3)
                                    .toUpperCase(),
                                style: TextStyle(
                                    color: AppTheme.fhTextSecondary,
                                    fontWeight: FontWeight.bold,
                                    fontSize: 11,
                                    fontFamily: AppTheme.fontDisplay)),
                          );
                        },
                        reservedSize: 38,
                      ),
                    ),
                    leftTitles: AxisTitles(
                      sideTitles: SideTitles(
                          showTitles: true,
                          reservedSize: 45,
                          getTitlesWidget: (double value, TitleMeta meta) {
                            if (value == meta.max ||
                                (value == 0 && meta.max > 20)) {
                              return SideTitleWidget(
                                  meta: meta, child: Container());
                            }
                            return SideTitleWidget(
                                meta: meta,
                                child: Text('${value.toInt()}',
                                    style: TextStyle(
                                        color: AppTheme.fhTextSecondary,
                                        fontSize: 11,
                                        fontFamily: AppTheme.fontBody)));
                          }),
                    ),
                  ),
                  borderData: FlBorderData(
                      show: true,
                      border: Border.all(
                          color: AppTheme.fhBorderColor.withOpacity(0.2),
                          width: 1)),
                  barGroups: weeklyBarGroups,
                  gridData: FlGridData(
                    show: true,
                    drawVerticalLine: true,
                    verticalInterval: 1,
                    horizontalInterval: (weeklyBarGroups
                                .map((g) => g.barRods.first.toY)
                                .reduce((a, b) => a > b ? a : b) /
                            5)
                        .clamp(10, 1000),
                    getDrawingHorizontalLine: (value) => FlLine(
                        color: AppTheme.fhBorderColor.withOpacity(0.1),
                        strokeWidth: 0.8),
                    getDrawingVerticalLine: (value) => FlLine(
                        color: AppTheme.fhBorderColor.withOpacity(0.1),
                        strokeWidth: 0.8),
                  ),
                ),
              ),
            ),
            const SizedBox(height: 30),
            if (_selectedDate != null) ...[
              Text(
                  'Activity Details for ${DateFormat('MMMM d').format(DateTime.parse(_selectedDate!))}:',
                  style: theme.textTheme.headlineSmall),
              const SizedBox(height: 12),
              Card(
                color: AppTheme.fhBgMedium,
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      if (taskTimes.isEmpty &&
                          subtasksCompleted.isEmpty &&
                          checkpointsCompleted.isEmpty &&
                          emotionLogsForSelectedDate
                              .isEmpty) // Check emotion logs too
                        Text("No specific activity recorded for this day.",
                            style: theme.textTheme.bodyMedium?.copyWith(
                                color: AppTheme.fhTextSecondary,
                                fontStyle: FontStyle.italic))
                      else ...[
                        if (emotionLogsForSelectedDate.isNotEmpty) ...[
                          Text('Emotion Logs:',
                              style: theme.textTheme.titleMedium
                                  ?.copyWith(fontWeight: FontWeight.bold)),
                          ...emotionLogsForSelectedDate.map((log) => Padding(
                                padding:
                                    const EdgeInsets.only(left: 16.0, top: 3.0),
                                child: Text(
                                    '- Rated ${_getEmotionLabel(log.rating)} (${log.rating}/5) at ${DateFormat('HH:mm').format(log.timestamp.toLocal())}',
                                    style: theme.textTheme.bodySmall?.copyWith(
                                        color: _getEmotionColor(
                                            log.rating, theme))),
                              )),
                          const SizedBox(height: 10),
                        ],
                        ...taskTimes.entries.map((entry) {
                          final task = gameProvider.mainTasks.firstWhere(
                              (t) => t.id == entry.key,
                              orElse: () => MainTask(
                                  id: '',
                                  name: 'Unknown Task',
                                  description: '',
                                  theme: '',
                                  colorHex: AppTheme.fhTextDisabled.value
                                      .toRadixString(16)
                                      .substring(2)));
                          return Padding(
                            padding: const EdgeInsets.symmetric(vertical: 3.0),
                            child: Text('${task.name}: ${entry.value}m',
                                style: theme.textTheme.bodyMedium
                                    ?.copyWith(color: task.taskColor)),
                          );
                        }),
                        if (subtasksCompleted.isNotEmpty) ...[
                          const SizedBox(height: 10),
                          Text('Sub-Missions Completed:',
                              style: theme.textTheme.titleMedium
                                  ?.copyWith(fontWeight: FontWeight.bold)),
                          ...subtasksCompleted.map((subEntryMap) {
                            final subEntry =
                                subEntryMap as Map<String, dynamic>;
                            final parentTask = gameProvider.mainTasks
                                .firstWhere(
                                    (t) => t.id == subEntry['parentTaskId'],
                                    orElse: () => MainTask(
                                        id: '',
                                        name: 'Unknown Task',
                                        description: '',
                                        theme: ''));
                            return Padding(
                              padding:
                                  const EdgeInsets.only(left: 16.0, top: 3.0),
                              child: Text(
                                '- ${subEntry['name']} (for ${parentTask.name}) - Logged: ${subEntry['timeLogged']}m, Count: ${subEntry['currentCount']}/${subEntry['targetCount']}',
                                style: theme.textTheme.bodySmall
                                    ?.copyWith(color: AppTheme.fhTextSecondary),
                              ),
                            );
                          }),
                        ],
                        if (checkpointsCompleted.isNotEmpty) ...[
                          const SizedBox(height: 10),
                          Text('Checkpoints Completed:',
                              style: theme.textTheme.titleMedium
                                  ?.copyWith(fontWeight: FontWeight.bold)),
                          ...checkpointsCompleted.map((cpEntryMap) {
                            final cpEntry = cpEntryMap as Map<String, dynamic>;
                            final String mainTaskName =
                                cpEntry['mainTaskName'] as String? ?? 'N/A';
                            final String parentSubtaskName =
                                cpEntry['parentSubtaskName'] as String? ??
                                    'N/A';
                            final String countableInfo = (cpEntry['isCountable']
                                        as bool? ??
                                    false)
                                ? " (${cpEntry['currentCount']}/${cpEntry['targetCount']})"
                                : "";
                            return Padding(
                              padding:
                                  const EdgeInsets.only(left: 16.0, top: 3.0),
                              child: Text(
                                '- ${cpEntry['name']}$countableInfo (Sub-Mission: "$parentSubtaskName" in "$mainTaskName")',
                                style: theme.textTheme.bodySmall?.copyWith(
                                    color: (gameProvider
                                                .getSelectedTask()
                                                ?.taskColor ??
                                            AppTheme.fhAccentTealFixed)
                                        .withOpacity(0.85)),
                              ),
                            );
                          }),
                        ]
                      ],
                    ],
                  ),
                ),
              ),
            ],
          ],
        ],
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/views/daily_summary_view.dart ---

--- START OF FILE lib/src/widgets/views/game_view.dart ---
// lib/src/widgets/views/game_view.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/utils/constants.dart';
import 'package:arcane/src/widgets/ui/enemy_info_card.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:collection/collection.dart';

class GameView extends StatefulWidget {
  const GameView({super.key});

  @override
  State<GameView> createState() => _GameViewState();
}

class _GameViewState extends State<GameView> {
  String? _selectedLocationId;
  bool _zoneClearedDialogShown = false;

  @override
  void initState() {
    super.initState();
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    print("[GameView] initState called.");

    _initializeSelectedLocation(gameProvider);
    gameProvider.addListener(_handleProviderChange);
    print(
        "[GameView] Final _selectedLocationId in initState: $_selectedLocationId");
  }

  void _handleProviderChange() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    if (!mounted) return;

    // Check if current selected location is cleared
    if (_selectedLocationId != null &&
        gameProvider.clearedLocationIds.contains(_selectedLocationId!) &&
        !_zoneClearedDialogShown) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          _showZoneClearedDialog(gameProvider, _selectedLocationId!);
          _zoneClearedDialogShown =
              true; // Prevent multiple dialogs for same clear
          // Attempt to switch to a new location
          final availableUnclearedLocations = gameProvider.gameLocationsList
              .where((loc) =>
                  gameProvider.isLocationUnlocked(loc.id) &&
                  !gameProvider.clearedLocationIds.contains(loc.id))
              .toList();
          setState(() {
            _selectedLocationId = availableUnclearedLocations.isNotEmpty
                ? availableUnclearedLocations.first.id
                : null;
          });
          if (_selectedLocationId != null) {
            gameProvider.setProviderState(
                currentGame: CurrentGame(
                  playerCurrentHp: gameProvider.currentGame.playerCurrentHp,
                  log: gameProvider.currentGame.log,
                  currentPlaceKey: _selectedLocationId,
                ),
                doPersist: false);
          } else {
             // If no new location could be selected, ensure currentPlaceKey is also nullified if it was the cleared one
            if (gameProvider.currentGame.currentPlaceKey != null && gameProvider.clearedLocationIds.contains(gameProvider.currentGame.currentPlaceKey!)) {
                 gameProvider.setProviderState(
                    currentGame: CurrentGame(
                      playerCurrentHp: gameProvider.currentGame.playerCurrentHp,
                      log: gameProvider.currentGame.log,
                      currentPlaceKey: null,
                    ),
                    doPersist: false);
            }
          }
        }
      });
    } else if (_selectedLocationId != null &&
        !gameProvider.clearedLocationIds.contains(_selectedLocationId!)) {
      // Reset if location becomes uncleared (e.g. daily reset)
      _zoneClearedDialogShown = false;
    }

    // Re-evaluate selected location if it becomes invalid (e.g. due to external changes)
    final availableLocations = gameProvider.gameLocationsList
        .where((loc) =>
            gameProvider.isLocationUnlocked(loc.id) &&
            !gameProvider.clearedLocationIds.contains(loc.id))
        .toList();

    if (_selectedLocationId != null &&
        !availableLocations.any((loc) => loc.id == _selectedLocationId)) {
      // Current selection is no longer valid or is cleared
      _initializeSelectedLocation(gameProvider);
    } else if (_selectedLocationId == null && availableLocations.isNotEmpty) {
      // No selection, but locations are available
      _initializeSelectedLocation(gameProvider);
    }
  }

  void _initializeSelectedLocation(GameProvider gameProvider) {
    final availableLocations = gameProvider.gameLocationsList
        .where((loc) =>
            gameProvider.isLocationUnlocked(loc.id) &&
            !gameProvider.clearedLocationIds.contains(loc.id))
        .toList();
    print(
        "[GameView] _initializeSelectedLocation: Available unlocked & uncleared locations: ${availableLocations.map((l) => l.name).join(', ')}");

    String? newSelectedLocationId;
    if (gameProvider.currentGame.currentPlaceKey != null &&
        availableLocations
            .any((l) => l.id == gameProvider.currentGame.currentPlaceKey)) {
      newSelectedLocationId = gameProvider.currentGame.currentPlaceKey;
    } else if (availableLocations.isNotEmpty) {
      newSelectedLocationId = availableLocations.first.id;
    }
    // If no available uncleared locations, newSelectedLocationId will be null

    if (mounted) {
      setState(() {
        _selectedLocationId = newSelectedLocationId;
      });
    } else {
      _selectedLocationId = newSelectedLocationId;
    }

    if (newSelectedLocationId != null && // Use newSelectedLocationId for the check as _selectedLocationId might not be updated yet by setState
        gameProvider.currentGame.currentPlaceKey != newSelectedLocationId) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          print(
              "[GameView] Updating provider with selectedLocationId in _initializeSelectedLocation: $newSelectedLocationId");
          gameProvider.setProviderState(
              currentGame: CurrentGame(
                enemy: gameProvider.currentGame.enemy, // Preserve enemy if one exists (though unlikely if changing place key)
                playerCurrentHp: gameProvider.currentGame.playerCurrentHp,
                log: gameProvider.currentGame.log,
                currentPlaceKey: newSelectedLocationId,
              ),
              doPersist: false);
        }
      });
    } else if (newSelectedLocationId == null && gameProvider.currentGame.currentPlaceKey != null) {
       // If no location is selected (e.g. all cleared/locked) ensure provider reflects this
       WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          print(
              "[GameView] Updating provider, no selected location, clearing currentPlaceKey.");
          gameProvider.setProviderState(
              currentGame: CurrentGame(
                enemy: gameProvider.currentGame.enemy,
                playerCurrentHp: gameProvider.currentGame.playerCurrentHp,
                log: gameProvider.currentGame.log,
                currentPlaceKey: null,
              ),
              doPersist: false);
        }
      });
    }
  }

  Future<void> _showZoneClearedDialog(
      GameProvider gameProvider, String clearedLocationId) async {
    final clearedLocation = gameProvider.gameLocationsList
        .firstWhereOrNull((loc) => loc.id == clearedLocationId);
    if (clearedLocation == null) return;

    await showDialog(
      context: context,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: Row(
            children: [
              Icon(MdiIcons.partyPopper,
                  color: AppTheme.fhAccentGold, size: 28),
              const SizedBox(width: 10),
              Text('Zone Pacified!',
                  style: TextStyle(color: AppTheme.fhAccentGold)),
            ],
          ),
          content: Text(
              'Congratulations! You have pacified all threats in ${clearedLocation.name}. This zone is now safe.'),
          actions: <Widget>[
            ElevatedButton(
              child: const Text('Awesome!'),
              onPressed: () {
                Navigator.of(dialogContext).pop();
              },
            ),
          ],
        );
      },
    );
  }

  @override
  void dispose() {
    Provider.of<GameProvider>(context, listen: false)
        .removeListener(_handleProviderChange);
    super.dispose();
  }

  Widget _renderCharacterStats(BuildContext context, dynamic character,
      bool isPlayer, GameProvider gameProvider) {
    final theme = Theme.of(context);
    final Color dynamicAccent = gameProvider.getSelectedTask()?.taskColor ??
        theme.colorScheme.secondary;
    final double maxHp = isPlayer
        ? gameProvider.playerGameStats['vitality']!.value
        : (character as EnemyTemplate).health.toDouble();
    double currentHp;

    String characterName = "Your Stats";
    String? description;
    int attackStat = 0;
    int defenseStat = 0;
    List<Widget> runeEffectsDisplay = [];

    if (isPlayer) {
      currentHp = gameProvider.currentGame.playerCurrentHp;
      characterName = gameProvider.currentUser?.displayName ?? "Adventurer";
      attackStat = gameProvider.playerGameStats['strength']!.value.toInt();
      defenseStat = gameProvider.playerGameStats['defense']!.value.toInt();
    } else if (character is EnemyTemplate) {
      characterName = character.name;
      description = character.description;
      attackStat = character.attack;
      defenseStat = character.defense;
      if (gameProvider.currentGame.enemy != null &&
          gameProvider.currentGame.enemy!.id == character.id) {
        currentHp = gameProvider.currentGame.enemy!.hp.toDouble();
      } else {
        currentHp = character.hp.toDouble();
      }
    } else {
      currentHp = 0;
    }

    final double hpPercent = maxHp > 0 ? (currentHp / maxHp) : 0.0;
    Color hpBarColor;
    if (hpPercent * 100 > 60) {
      hpBarColor = AppTheme.fhAccentGreen;
    } else if (hpPercent * 100 > 30) {
      hpBarColor = AppTheme.fhAccentOrange;
    } else {
      hpBarColor = AppTheme.fhAccentRed;
    }

    return Card(
      elevation: 1,
      color: AppTheme.fhBgMedium.withOpacity(0.7),
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              characterName,
              style: theme.textTheme.titleLarge?.copyWith(
                  color: isPlayer ? dynamicAccent : AppTheme.fhAccentRed,
                  fontWeight: FontWeight.bold,
                  fontSize: 17),
              overflow: TextOverflow.ellipsis,
            ),
            const SizedBox(height: 8),
            SizedBox(
                height: 12,
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(3),
                  child: LinearProgressIndicator(
                    value: hpPercent,
                    backgroundColor: AppTheme.fhBgDark,
                    valueColor: AlwaysStoppedAnimation<Color>(hpBarColor),
                  ),
                )),
            const SizedBox(height: 6),
            Text(
                'HP: ${currentHp.toStringAsFixed(0)} / ${maxHp.toStringAsFixed(0)}',
                style: theme.textTheme.bodyMedium
                    ?.copyWith(color: AppTheme.fhTextSecondary, fontSize: 13)),
            const SizedBox(height: 4),
            Row(
              children: [
                Icon(MdiIcons.sword,
                    size: 14, color: AppTheme.fhAccentOrange.withOpacity(0.8)),
                Text(' ATK: $attackStat  ',
                    style: theme.textTheme.bodyMedium?.copyWith(fontSize: 13)),
                Icon(MdiIcons.shield,
                    size: 14,
                    color: AppTheme.fhAccentTealFixed.withOpacity(
                        0.8)), // Use fixed teal for clarity
                Text(' DEF: $defenseStat',
                    style: theme.textTheme.bodyMedium?.copyWith(fontSize: 13)),
              ],
            ),
            if (isPlayer && runeEffectsDisplay.isNotEmpty) ...[
              const SizedBox(height: 6),
              Wrap(spacing: 4, runSpacing: 4, children: runeEffectsDisplay),
            ],
            if (!isPlayer && description != null && description.isNotEmpty) ...[
              const SizedBox(height: 6),
              Tooltip(
                message: description,
                preferBelow: false,
                child: Text(
                  description,
                  style: theme.textTheme.bodySmall?.copyWith(
                      fontStyle: FontStyle.italic,
                      color: AppTheme.fhTextSecondary.withOpacity(0.7),
                      fontSize: 11),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              )
            ]
          ],
        ),
      ),
    );
  }

  Widget _buildLocationList(BuildContext context, GameProvider gameProvider) {
    
    final availableLocations = gameProvider.gameLocationsList
        .where((loc) => gameProvider.isLocationUnlocked(loc.id))
        .toList()
      ..sort((a, b) =>
          a.minPlayerLevelToUnlock.compareTo(b.minPlayerLevelToUnlock));

    if (availableLocations.isEmpty) {
      return const Padding(
        padding: EdgeInsets.all(24.0),
        child: Center(
            child: Text(
                "No combat zones accessible at your current level or all zones pacified.",
                textAlign: TextAlign.center)),
      );
    }

    return ListView.builder(
      shrinkWrap: true,
      physics:
          const NeverScrollableScrollPhysics(), // Parent SingleChildScrollView handles scroll
      itemCount: availableLocations.length,
      itemBuilder: (context, index) {
        final location = availableLocations[index];
        final isSelected = _selectedLocationId == location.id;
        final isCleared =
            gameProvider.clearedLocationIds.contains(location.id);
        final Color tileColor = isSelected
            ? (gameProvider.getSelectedTask()?.taskColor ??
                    AppTheme.fhAccentTealFixed)
                .withOpacity(0.2)
            : AppTheme.fhBgLight;
        final Color borderColor = isSelected
            ? (gameProvider.getSelectedTask()?.taskColor ??
                AppTheme.fhAccentTealFixed)
            : AppTheme.fhBorderColor.withOpacity(0.5);

        return Card(
          margin: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          color: tileColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(6),
            side: BorderSide(color: borderColor, width: isSelected ? 1.5 : 1),
          ),
          child: ListTile(
            leading: Text(location.iconEmoji,
                style: const TextStyle(fontSize: 24)),
            title: Text(location.name,
                style:
                    TextStyle(fontWeight: isSelected ? FontWeight.bold : null)),
            subtitle: Text(
              isCleared
                  ? "Zone Pacified"
                  : "Lvl ${location.minPlayerLevelToUnlock}+",
              style: TextStyle(
                  color: isCleared
                      ? AppTheme.fhAccentGreen
                      : AppTheme.fhTextSecondary,
                  fontSize: 11),
            ),
            trailing: isCleared
                ? Icon(MdiIcons.shieldCheckOutline,
                    color: AppTheme.fhAccentGreen)
                : Icon(MdiIcons.chevronRight, color: AppTheme.fhTextSecondary),
            onTap: isCleared
                ? null
                : () {
                    if (_selectedLocationId != location.id) {
                      print(
                          "[GameView] Location selected from list: ${location.name}");
                      setState(() {
                        _selectedLocationId = location.id;
                        _zoneClearedDialogShown = false;
                      });
                      gameProvider.setProviderState(
                          currentGame: CurrentGame(
                            playerCurrentHp:
                                gameProvider.currentGame.playerCurrentHp,
                            log: gameProvider.currentGame.log,
                            currentPlaceKey: location.id,
                            enemy:
                                null // Clear current enemy when changing location
                            ),
                          doPersist: false);
                    }
                  },
          ),
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    final Color dynamicAccent = gameProvider.getSelectedTask()?.taskColor ??
        theme.colorScheme.secondary;
    final Color buttonTextColor =
        ThemeData.estimateBrightnessForColor(dynamicAccent) == Brightness.dark
            ? AppTheme.fhTextPrimary
            : AppTheme.fhBgDark;

    print(
        "[GameView] build called. SelectedLocationId: $_selectedLocationId, currentPlaceKey from provider: ${gameProvider.currentGame.currentPlaceKey}");

    final List<EnemyTemplate> availableEnemies = _selectedLocationId != null
        ? (gameProvider.enemyTemplatesList
            .where((enemyTmpl) =>
                enemyTmpl.locationKey == _selectedLocationId &&
                gameProvider.playerLevel >= enemyTmpl.minPlayerLevel &&
                !gameProvider.defeatedEnemyIds.contains(enemyTmpl.id))
            .toList()
          ..sort((a, b) {
            int lvlCompare = a.minPlayerLevel.compareTo(b.minPlayerLevel);
            if (lvlCompare != 0) return lvlCompare;
            return a.name.compareTo(b.name);
          }))
        : [];

    final ownedPowerUps = gameProvider.artifacts
        .map((ownedArt) {
          final template =
              gameProvider.getArtifactTemplateById(ownedArt.templateId);
          return (template != null &&
                  template.type == 'powerup' &&
                  (ownedArt.uses ?? 0) > 0)
              ? {'owned': ownedArt, 'template': template}
              : null;
        })
        .where((item) => item != null)
        .cast<Map<String, dynamic>>()
        .toList();

    GameLocation? displayedLocation;
    if (_selectedLocationId != null) {
      displayedLocation = gameProvider.gameLocationsList
          .firstWhereOrNull((loc) => loc.id == _selectedLocationId);
    }

    // Fallback for displayedLocation title if _selectedLocationId is null but there are discoverable locations.
    // This doesn't change _selectedLocationId, just what's shown in the title if nothing is strictly selected.
    if (displayedLocation == null) {
        final anyUnlocked = gameProvider.gameLocationsList
            .firstWhereOrNull((loc) => gameProvider.isLocationUnlocked(loc.id) && !gameProvider.clearedLocationIds.contains(loc.id));
        if (anyUnlocked != null) {
            // Do not set displayedLocation here if _selectedLocationId is meant to be the source of truth for "current selection"
            // The title logic will handle `displayedLocation?.name ?? "No Zone Selected"`
        } else {
            final anyLocationAtAll = gameProvider.gameLocationsList.firstOrNull;
            if(anyLocationAtAll != null && _selectedLocationId == null && gameProvider.gameLocationsList.where((loc) => gameProvider.isLocationUnlocked(loc.id)).isEmpty) {
                // If no location is selected and no locations are unlocked,
                // we might show a generic name or the first game location if it makes sense.
                // For now, "No Zone Selected" is fine.
            }
        }
    }


    return SingleChildScrollView(
      padding: const EdgeInsets.only(bottom: 16, right: 4, left: 4),
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 16.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text(displayedLocation?.iconEmoji ?? '🗺️',
                    style: const TextStyle(fontSize: 28)),
                const SizedBox(width: 12),
                Text(
                  displayedLocation?.name ?? "No Zone Selected",
                  style: theme.textTheme.displaySmall?.copyWith(
                      color: AppTheme.fhTextPrimary,
                      fontSize: 24), // Slightly smaller title
                ),
              ],
            ),
          ),
          if (gameProvider.currentGame.enemy == null)
            Padding(
                padding: const EdgeInsets.symmetric(
                    horizontal: 16.0, vertical: 8.0),
                child: _buildLocationList(context, gameProvider)),
          
          if (gameProvider.currentGame.enemy == null &&
              _selectedLocationId != null) ...[
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 16.0),
              child: Text('Choose Your Opponent:',
                  style: theme.textTheme.headlineSmall
                      ?.copyWith(color: AppTheme.fhTextPrimary, fontSize: 20)),
            ),
            if (gameProvider.clearedLocationIds.contains(_selectedLocationId!))
              Padding(
                padding: const EdgeInsets.all(24.0),
                child: Column(
                  children: [
                    Icon(MdiIcons.shieldCheckOutline,
                        color: AppTheme.fhAccentGreen, size: 48),
                    const SizedBox(height: 16),
                    Text(
                      "${displayedLocation?.name ?? 'This zone'} has been pacified!",
                      textAlign: TextAlign.center,
                      style: theme.textTheme.titleLarge
                          ?.copyWith(color: AppTheme.fhAccentGreen),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      "No threats remain here. Explore other zones.",
                      textAlign: TextAlign.center,
                      style: theme.textTheme.bodyMedium
                          ?.copyWith(color: AppTheme.fhTextSecondary),
                    ),
                  ],
                ),
              )
            else if (availableEnemies.isEmpty)
              Padding(
                padding: const EdgeInsets.all(24.0),
                child: Text(
                  // _selectedLocationId is guaranteed non-null here by the outer if condition.
                  // So, the "Please select a combat zone." part of a ternary is not needed.
                  "No suitable opponents found in ${displayedLocation?.name ?? 'this zone'} for your current level (${gameProvider.playerLevel}). Try another zone or await new threats.",
                  textAlign: TextAlign.center,
                  style: theme.textTheme.bodyMedium
                      ?.copyWith(color: AppTheme.fhTextSecondary),
                ),
              )
            else
              LayoutBuilder(builder: (context, constraints) {
                int crossAxisCount = constraints.maxWidth > 900
                    ? 3
                    : (constraints.maxWidth > 600 ? 2 : 1); // Adjusted counts
                double itemWidth =
                    (constraints.maxWidth - (crossAxisCount + 1) * 10) /
                        crossAxisCount;
                double childAspectRatio =
                    itemWidth / 260; // Adjusted for new card height

                return GridView.builder(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  padding: const EdgeInsets.all(10),
                  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                    crossAxisCount: crossAxisCount,
                    crossAxisSpacing: 10.0,
                    mainAxisSpacing: 10.0,
                    childAspectRatio:
                        childAspectRatio.clamp(0.8, 1.1), // Adjusted clamp
                  ),
                  itemCount: availableEnemies.length,
                  itemBuilder: (context, index) {
                    final enemyTmpl = availableEnemies[index];
                    return EnemyInfoCardWidget(
                      enemy: enemyTmpl,
                      playerLevel: gameProvider.playerLevel,
                      onStartGame: () => gameProvider.startGame(enemyTmpl.id),
                    );
                  },
                );
              })
          ] else if (gameProvider.currentGame.enemy == null && _selectedLocationId == null) ...[
            // This block explicitly handles the case where no enemy is selected AND no location is selected.
            // _buildLocationList already shows "No combat zones accessible..." if availableLocations is empty.
            // If a user *could* select a location but hasn't, this space could prompt them.
            // For now, if _buildLocationList handles empty states, this might not need much more,
            // unless a specific message for "please select a zone from above" is desired.
            if (gameProvider.gameLocationsList.where((loc) => gameProvider.isLocationUnlocked(loc.id)).isNotEmpty)
              Padding(
                padding: const EdgeInsets.symmetric(vertical: 24.0, horizontal: 16.0),
                child: Text(
                  "Select a combat zone from the list above to see available opponents.",
                  textAlign: TextAlign.center,
                  style: theme.textTheme.bodyMedium?.copyWith(color: AppTheme.fhTextSecondary),
                ),
              )
            // If no locations are unlocked/available at all, _buildLocationList covers this.

          ] else if (gameProvider.currentGame.enemy != null) ...[ // Enemy is present
            Padding(
              padding:
                  const EdgeInsets.symmetric(vertical: 16.0, horizontal: 8.0),
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                      child: _renderCharacterStats(context,
                          gameProvider.playerGameStats, true, gameProvider)),
                  const SizedBox(width: 12),
                  Expanded(
                      child: _renderCharacterStats(
                          context,
                          gameProvider.currentGame.enemy!,
                          false,
                          gameProvider)),
                ],
              ),
            ),
            Padding(
              padding:
                  const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
              child: ElevatedButton.icon(
                icon: Icon(MdiIcons.sword, size: 20),
                label: Text('ATTACK! (${energyPerAttack.toInt()}⚡)'),
                onPressed: gameProvider.playerEnergy < energyPerAttack
                    ? null
                    : gameProvider.handleFight,
                style: ElevatedButton.styleFrom(
                  backgroundColor: dynamicAccent,
                  foregroundColor: buttonTextColor,
                  minimumSize: const Size(double.infinity, 52),
                  textStyle: theme.textTheme.labelLarge
                      ?.copyWith(color: buttonTextColor),
                ),
              ),
            ),
            if (gameProvider.playerEnergy < energyPerAttack)
              Text('Not enough energy! Complete sub-quests.',
                  style: theme.textTheme.bodySmall
                      ?.copyWith(color: AppTheme.fhAccentOrange)),
            Padding(
              padding:
                  const EdgeInsets.symmetric(horizontal: 16.0, vertical: 4.0),
              child: OutlinedButton(
                onPressed: gameProvider.forfeitMatch,
                style: OutlinedButton.styleFrom(
                  foregroundColor: AppTheme.fhAccentOrange,
                  side: const BorderSide(
                      color: AppTheme.fhAccentOrange, width: 1),
                  minimumSize: const Size(double.infinity, 44),
                  textStyle: theme.textTheme.labelMedium
                      ?.copyWith(color: AppTheme.fhAccentOrange),
                ),
                child: const Text('Forfeit Match (-10% Ø, 0⚡)'),
              ),
            ),
            if (ownedPowerUps.isNotEmpty) ...[
              const SizedBox(height: 16),
              const Divider(),
              Padding(
                padding: const EdgeInsets.only(top: 12.0, bottom: 8.0),
                child: Text('Power-ups:',
                    style: theme.textTheme.titleSmall
                        ?.copyWith(color: AppTheme.fhTextSecondary)),
              ),
              Wrap(
                spacing: 8.0,
                runSpacing: 8.0,
                alignment: WrapAlignment.center,
                children: ownedPowerUps.map((powerUpData) {
                  final OwnedArtifact owned =
                      powerUpData['owned'] as OwnedArtifact;
                  final ArtifactTemplate template =
                      powerUpData['template'] as ArtifactTemplate;

                  Widget powerUpIcon;
                  if (template.icon.length == 1 || template.icon.length == 2) {
                    powerUpIcon = Text(template.icon,
                        style: const TextStyle(fontSize: 22));
                  } else {
                    powerUpIcon = Icon(
                        MdiIcons.fromString(
                                template.icon.replaceAll('mdi-', '')) ??
                            MdiIcons.flashAlert,
                        size: 22);
                  }

                  return Tooltip(
                    message:
                        '${template.name}: ${template.description} (Uses: ${owned.uses})',
                    child: OutlinedButton(
                      onPressed: () => gameProvider.usePowerUp(owned.uniqueId),
                      style: OutlinedButton.styleFrom(
                        foregroundColor: AppTheme.fhAccentPurple,
                        side: const BorderSide(
                            color: AppTheme.fhAccentPurple, width: 1),
                        padding: const EdgeInsets.all(10),
                        minimumSize: const Size(48, 48),
                        shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(4)),
                      ),
                      child: powerUpIcon,
                    ),
                  );
                }).toList(),
              ),
            ],
          ],
          const SizedBox(height: 24),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0),
            child: Text('Combat Log:',
                style: theme.textTheme.titleSmall
                    ?.copyWith(color: AppTheme.fhTextSecondary)),
          ),
          const SizedBox(height: 8),
          Container(
            height: 180,
            margin: const EdgeInsets.symmetric(horizontal: 16.0),
            padding: const EdgeInsets.all(12.0),
            decoration: BoxDecoration(
              color: AppTheme.fhBgMedium.withOpacity(0.6),
              border:
                  Border.all(color: AppTheme.fhBorderColor.withOpacity(0.5)),
              borderRadius: BorderRadius.circular(4),
            ),
            child: gameProvider.currentGame.log.isEmpty
                ? Text('No actions yet...',
                    style: theme.textTheme.bodySmall?.copyWith(
                        fontStyle: FontStyle.italic,
                        color: AppTheme.fhTextSecondary.withOpacity(0.7)))
                : ListView.builder(
                    reverse: true,
                    itemCount: gameProvider.currentGame.log.length,
                    itemBuilder: (context, index) {
                      final entry =
                          gameProvider.currentGame.log.reversed.toList()[index];
                      Color entryColor = AppTheme.fhTextSecondary;
                      String cleanEntry =
                          entry.replaceAll(RegExp(r'<span[^>]*>|<\/span>'), "");

                      final colorMatch =
                          RegExp(r'color:#([0-9a-fA-F]{6})').firstMatch(entry);
                      if (colorMatch != null) {
                        try {
                          entryColor = Color(
                              int.parse('FF${colorMatch.group(1)}', radix: 16));
                        } catch (e) {/* fallback */}
                      } else if (entry.contains('var(--fh-accent-green)')) {
                        entryColor = AppTheme.fhAccentGreen;
                      } else if (entry.contains('var(--fh-accent-red)')) {
                        entryColor = AppTheme.fhAccentRed;
                      } else if (entry.contains('var(--fh-accent-orange)')) {
                        entryColor = AppTheme.fhAccentOrange;
                      } else if (entry.contains('var(--fh-accent-purple)')) {
                        entryColor = AppTheme.fhAccentPurple;
                      } else if (entry.contains('font-weight:bold')) {
                        entryColor = AppTheme.fhTextPrimary;
                      }

                      return Padding(
                        padding: const EdgeInsets.only(bottom: 6.0),
                        child: Text(
                          cleanEntry,
                          style: theme.textTheme.bodySmall
                              ?.copyWith(color: entryColor, height: 1.4),
                        ),
                      );
                    },
                  ),
          ),
        ],
      ),
    );
  }
}
--- END OF FILE lib/src/widgets/views/game_view.dart ---

--- START OF FILE lib/src/widgets/views/park_view.dart ---
// lib/src/widgets/views/park_view.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/utils/constants.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:collection/collection.dart';

enum _ParkSubView {
  menu,
  parkOverview,
  construction,
  fossilCenter,
  hatchery,
  enclosures,
  ownedBuildingsManagement
}

class ParkView extends StatefulWidget {
  const ParkView({super.key});

  @override
  State<ParkView> createState() => _ParkViewState();
}

class _ParkViewState extends State<ParkView> {
  _ParkSubView _currentSubView = _ParkSubView.menu;
  String? _selectedOwnedDinoId;

  Widget _buildMenuButton(BuildContext context,
      {required IconData icon,
      required String label,
      required _ParkSubView subView,
      required Color color}) {
    final theme = Theme.of(context);
    return Card(
      elevation: 2,
      color: AppTheme.fhBgMedium,
      child: InkWell(
        onTap: () => setState(() => _currentSubView = subView),
        borderRadius: BorderRadius.circular(4.0),
        child: Padding(
          padding: const EdgeInsets.all(12.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(icon, size: 36, color: color),
              const SizedBox(height: 8),
              Text(label,
                  textAlign: TextAlign.center,
                  style: theme.textTheme.titleMedium
                      ?.copyWith(color: AppTheme.fhTextPrimary)),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSubViewAppBar(
      BuildContext context, String title, Color dynamicAccent) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16.0),
      child: Row(
        children: [
          IconButton(
            icon: Icon(MdiIcons.arrowLeftCircleOutline,
                color: dynamicAccent, size: 28),
            onPressed: () =>
                setState(() => _currentSubView = _ParkSubView.menu),
            tooltip: "Back to Park Menu",
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(title,
                style: Theme.of(context)
                    .textTheme
                    .headlineSmall
                    ?.copyWith(color: AppTheme.fhTextPrimary)),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);
    final Color dynamicAccent = gameProvider.getSelectedTask()?.taskColor ??
        theme.colorScheme.secondary;

    if (_currentSubView == _ParkSubView.menu) {
      return _buildParkMenu(context, gameProvider, dynamicAccent);
    }

    Widget currentViewWidget;
    String viewTitle = "";

    switch (_currentSubView) {
      case _ParkSubView.construction:
        viewTitle = "Construction Blueprints";
        currentViewWidget =
            _buildConstructionView(context, gameProvider, dynamicAccent);
        break;
      case _ParkSubView.ownedBuildingsManagement:
        viewTitle = "Park Infrastructure";
        currentViewWidget =
            _buildOwnedBuildingsSection(context, gameProvider, dynamicAccent);
        break;
      case _ParkSubView.fossilCenter:
        viewTitle = "Expedition Center";
        currentViewWidget =
            _buildFossilCenterSection(context, gameProvider, dynamicAccent);
        break;
      case _ParkSubView.hatchery:
        viewTitle = "Hammond Creation Lab";
        currentViewWidget =
            _buildHatcherySection(context, gameProvider, dynamicAccent);
        break;
      case _ParkSubView.enclosures:
        viewTitle = "Dinosaur Paddocks";
        currentViewWidget =
            _buildEnclosuresSection(context, gameProvider, dynamicAccent);
        break;
      default: // menu handled above
        currentViewWidget =
            const Center(child: Text("Section not implemented."));
    }

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildSubViewAppBar(context, viewTitle, dynamicAccent),
          SingleChildScrollView(
            child: Column(
              children: [
                _buildParkStatsCard(context, gameProvider, dynamicAccent),
                const SizedBox(height: 16),
                _buildParkActionsCard(context, gameProvider, dynamicAccent),
              ],
            ),
          ),
          currentViewWidget,
          if (_selectedOwnedDinoId != null &&
              _currentSubView == _ParkSubView.enclosures)
            _buildOwnedDinosaurDetails(
                context, gameProvider, dynamicAccent, _selectedOwnedDinoId!),
        ],
      ),
    );
  }

  Widget _buildParkMenu(
      BuildContext context, GameProvider gameProvider, Color dynamicAccent) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(bottom: 24.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(MdiIcons.island, color: dynamicAccent, size: 36),
                const SizedBox(width: 12),
                Text("Isla Nublar Dynamics",
                    style: Theme.of(context)
                        .textTheme
                        .displaySmall
                        ?.copyWith(color: AppTheme.fhTextPrimary)),
              ],
            ),
          ),
          SingleChildScrollView(
            child: Column(
              children: [
                _buildParkStatsCard(context, gameProvider, dynamicAccent),
                const SizedBox(height: 16),
                _buildParkActionsCard(context, gameProvider, dynamicAccent),
              ],
            ),
          ),
          GridView.count(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            crossAxisCount: 1,
            crossAxisSpacing: 12,
            mainAxisSpacing: 12,
            childAspectRatio: 3,
            children: [
              _buildMenuButton(context,
                  icon: MdiIcons.hardHat,
                  label: "Construction",
                  subView: _ParkSubView.construction,
                  color: AppTheme.fhAccentOrange),
              _buildMenuButton(context,
                  icon: MdiIcons.officeBuildingCogOutline,
                  label: "Manage Infrastructure",
                  subView: _ParkSubView.ownedBuildingsManagement,
                  color: AppTheme.fhAccentTeal),
              _buildMenuButton(context,
                  icon: MdiIcons.compassRose,
                  label: "Expedition Center",
                  subView: _ParkSubView.fossilCenter,
                  color: AppTheme.fhAccentGold),
              _buildMenuButton(context,
                  icon: MdiIcons.dna,
                  label: "Creation Lab",
                  subView: _ParkSubView.hatchery,
                  color: AppTheme.fhAccentPurple),
              _buildMenuButton(context,
                  icon: MdiIcons.fence,
                  label: "Paddocks",
                  subView: _ParkSubView.enclosures,
                  color: AppTheme.fhAccentGreen),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildConditionalPlaceholder(
      ThemeData theme, String message, IconData icon) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 16.0),
      color: AppTheme.fhBgMedium.withOpacity(0.7),
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(icon,
                  size: 32, color: AppTheme.fhTextSecondary.withOpacity(0.5)),
              const SizedBox(height: 12),
              Text(
                message,
                textAlign: TextAlign.center,
                style: theme.textTheme.bodyMedium?.copyWith(
                    fontStyle: FontStyle.italic,
                    color: AppTheme.fhTextSecondary.withOpacity(0.7)),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSectionTitle(ThemeData theme, String title, IconData icon) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12.0, top: 20.0),
      child: Row(
        children: [
          Icon(icon, color: AppTheme.fhTextSecondary, size: 20),
          const SizedBox(width: 8),
          Text(title, style: theme.textTheme.headlineSmall),
        ],
      ),
    );
  }

  Widget _buildParkStatsCard(
      BuildContext context, GameProvider gameProvider, Color dynamicAccent) {
    final theme = Theme.of(context);
    final parkManager = gameProvider.parkManager;
    final int starRating =
        (parkManager.parkRating / (MAX_PARK_RATING_FOR_STARS / 5.0))
            .round()
            .clamp(0, 5);

    return Card(
      color: AppTheme.fhBgMedium,
      elevation: 2,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Removed title from here as it's in the sub-view app bar
            _buildStatRow(theme, MdiIcons.starCircleOutline, "Park Rating:",
                parkManager.parkRating.toString(), AppTheme.fhAccentGold),
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 4.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Row(
                    children: [
                      Icon(MdiIcons.trophyOutline,
                          size: 18, color: AppTheme.fhTextSecondary),
                      const SizedBox(width: 8),
                      Text("Appeal:",
                          style: theme.textTheme.bodyMedium
                              ?.copyWith(color: AppTheme.fhTextSecondary)),
                    ],
                  ),
                  Row(
                    children: List.generate(5, (index) {
                      return Icon(
                        index < starRating
                            ? MdiIcons.star
                            : MdiIcons.starOutline,
                        color: AppTheme.fhAccentGold,
                        size: 22,
                      );
                    }),
                  ),
                ],
              ),
            ),
            _buildStatRow(
                theme,
                MdiIcons.cash,
                "Park Funds:",
                "\$${parkManager.parkDollars.toStringAsFixed(0)}",
                AppTheme.fhAccentGreen),
            _buildStatRow(
                theme,
                MdiIcons.lightningBoltOutline,
                "Player Energy (Park Use):",
                "${gameProvider.playerEnergy.toStringAsFixed(0)} / ${gameProvider.calculatedMaxEnergy.toStringAsFixed(0)}",
                AppTheme.fhAccentTealFixed),
            _buildStatRow(
              theme,
              MdiIcons.powerPlugOutline,
              "Total Power:",
              "${parkManager.currentPowerGenerated} / ${parkManager.currentPowerConsumed}",
              parkManager.currentPowerGenerated >=
                      parkManager.currentPowerConsumed
                  ? AppTheme.fhAccentGreen
                  : AppTheme.fhAccentOrange,
            ),
            _buildStatRow(
                theme,
                MdiIcons.arrowUpCircleOutline,
                "Income / Min:",
                "\$${parkManager.incomePerMinuteDollars}",
                AppTheme.fhAccentGreen),
            _buildStatRow(
                theme,
                MdiIcons.arrowDownCircleOutline,
                "Costs / Min:",
                "\$${parkManager.operationalCostPerMinuteDollars}",
                AppTheme.fhAccentRed),
            const SizedBox(height: 8),
            SizedBox(
              height: 8,
              child: ClipRRect(
                borderRadius: BorderRadius.circular(4),
                child: LinearProgressIndicator(
                  value: gameProvider.calculatedMaxEnergy > 0
                      ? (gameProvider.playerEnergy /
                          gameProvider.calculatedMaxEnergy)
                      : 0,
                  backgroundColor: AppTheme.fhBorderColor.withOpacity(0.3),
                  valueColor: AlwaysStoppedAnimation<Color>(
                      AppTheme.fhAccentTealFixed.withOpacity(0.7)),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildParkActionsCard(
      BuildContext context, GameProvider gameProvider, Color dynamicAccent) {
    final theme = Theme.of(context);
    final Color buttonTextColor =
        ThemeData.estimateBrightnessForColor(dynamicAccent) == Brightness.dark
            ? AppTheme.fhTextPrimary
            : AppTheme.fhBgDark;

    return Card(
      color: AppTheme.fhBgMedium,
      elevation: 1,
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            ElevatedButton.icon(
              icon: Icon(MdiIcons.runFast, size: 18),
              label: Text("Fast Forward 1 Min ($SKIP_MINUTE_ENERGY_COST⚡)"),
              onPressed: gameProvider.playerEnergy >= SKIP_MINUTE_ENERGY_COST
                  ? () => gameProvider.skipOneMinute()
                  : null,
              style: ElevatedButton.styleFrom(
                backgroundColor: dynamicAccent,
                foregroundColor: buttonTextColor,
                disabledBackgroundColor: AppTheme.fhBgDark.withOpacity(0.5),
                disabledForegroundColor:
                    AppTheme.fhTextSecondary.withOpacity(0.5),
              ),
            ),
            if (gameProvider.playerEnergy < SKIP_MINUTE_ENERGY_COST)
              Padding(
                padding: const EdgeInsets.only(top: 4.0),
                child: Text(
                  "Not enough energy to fast forward.",
                  style: theme.textTheme.labelSmall
                      ?.copyWith(color: AppTheme.fhAccentOrange),
                  textAlign: TextAlign.center,
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildStatRow(ThemeData theme, IconData icon, String label,
      String value, Color valueColor) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Row(
            children: [
              Icon(icon, size: 18, color: AppTheme.fhTextSecondary),
              const SizedBox(width: 8),
              Text(label,
                  style: theme.textTheme.bodyMedium
                      ?.copyWith(color: AppTheme.fhTextSecondary)),
            ],
          ),
          Text(value,
              style: theme.textTheme.bodyMedium
                  ?.copyWith(color: valueColor, fontWeight: FontWeight.bold)),
        ],
      ),
    );
  }

  Widget _buildConstructionView(
      BuildContext context, GameProvider gameProvider, Color dynamicAccent) {
    final theme = Theme.of(context);
    final allTemplates = gameProvider.buildingTemplatesList;

    Map<String, List<BuildingTemplate>> categorizedTemplates = {
      "Enclosures": allTemplates.where((t) => t.type == "enclosure").toList(),
      "Operations": allTemplates
          .where((t) => ["fossil_center", "hatchery", "research_outpost"]
              .contains(t.type))
          .toList(),
      "Guest Facilities": allTemplates
          .where((t) => ["visitor_center", "amenity_shop"].contains(t.type))
          .toList(),
      "Feeders": allTemplates.where((t) => t.type == "food_station").toList(),
      "Power": allTemplates.where((t) => t.type == "power_plant").toList(),
    };

    categorizedTemplates.removeWhere((key, value) => value.isEmpty);

    if (allTemplates.isEmpty) {
      return const Center(
          child: Text("No building blueprints available.",
              style: TextStyle(fontStyle: FontStyle.italic)));
    }

    // --- MODIFICATION START ---
    // Replace ListView with Column if this view is part of a larger scrollable area
    return Column(
      // Was: ListView
      children: categorizedTemplates.entries.map((entry) {
        String categoryName = entry.key;
        List<BuildingTemplate> templatesInCategory = entry.value;

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildSectionTitle(theme, categoryName,
                MdiIcons.formatListChecks), // Generic icon for category
            GridView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: MediaQuery.of(context).size.width > 600 ? 2 : 1,
                childAspectRatio: 1.2, // Adjusted for better info display
                crossAxisSpacing: 10,
                mainAxisSpacing: 10,
              ),
              itemCount: templatesInCategory.length,
              itemBuilder: (ctx, index) {
                final template = templatesInCategory[index];
                final canAfford = gameProvider.canAffordBuilding(template);
                final Color buttonTextColor =
                    ThemeData.estimateBrightnessForColor(dynamicAccent) ==
                            Brightness.dark
                        ? AppTheme.fhTextPrimary
                        : AppTheme.fhBgDark;
                return Card(
                  color: AppTheme.fhBgLight,
                  child: Padding(
                    padding: const EdgeInsets.all(12.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Row(
                          children: [
                            Icon(
                                MdiIcons.fromString(template.icon) ??
                                    MdiIcons.domain,
                                size: 28,
                                color: dynamicAccent),
                            const SizedBox(width: 10),
                            Expanded(
                                child: Text(
                              template.name,
                              style: theme.textTheme.titleLarge?.copyWith(
                                  fontWeight: FontWeight.w600), // Bolder title
                              overflow: TextOverflow.ellipsis,
                              maxLines: 2,
                            )),
                          ],
                        ),
                        const SizedBox(height: 8),
                        Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text("Cost: \$${template.costDollars}",
                                style: theme.textTheme.bodyMedium?.copyWith(
                                    color: AppTheme.fhTextSecondary)),
                            if (template.sizeX != null &&
                                template.sizeY != null)
                              Text("Size: ${template.sizeX}x${template.sizeY}",
                                  style: theme.textTheme.bodyMedium?.copyWith(
                                      color: AppTheme.fhTextSecondary)),
                            if (template.incomePerMinuteDollars != null &&
                                template.incomePerMinuteDollars! > 0)
                              Text(
                                  "Income: \$${template.incomePerMinuteDollars}/min",
                                  style: theme.textTheme.bodyMedium?.copyWith(
                                      color: AppTheme.fhAccentGreen)),
                            if (template.operationalCostPerMinuteDollars !=
                                    null &&
                                template.operationalCostPerMinuteDollars! > 0)
                              Text(
                                  "Upkeep: \$${template.operationalCostPerMinuteDollars}/min",
                                  style: theme.textTheme.bodyMedium?.copyWith(
                                      color: AppTheme.fhAccentOrange)),
                            if (template.parkRatingBoost != null &&
                                template.parkRatingBoost! > 0)
                              Text("Rating: +${template.parkRatingBoost}",
                                  style: theme.textTheme.bodyMedium
                                      ?.copyWith(color: AppTheme.fhAccentGold)),
                            if (template.capacity != null)
                              Text("Capacity: ${template.capacity}",
                                  style: theme.textTheme.bodyMedium?.copyWith(
                                      color: AppTheme.fhTextSecondary)),
                            if (template.powerRequired != null &&
                                template.powerRequired! > 0)
                              Text("Power Req: ${template.powerRequired}",
                                  style: theme.textTheme.bodyMedium?.copyWith(
                                      color: AppTheme.fhAccentOrange)),
                            if (template.powerOutput != null &&
                                template.powerOutput! > 0)
                              Text("Power Gen: ${template.powerOutput}",
                                  style: theme.textTheme.bodyMedium?.copyWith(
                                      color: AppTheme.fhAccentGreen)),
                          ],
                        ),
                        const Spacer(),
                        SizedBox(
                          width: double.infinity,
                          child: ElevatedButton.icon(
                            icon: Icon(MdiIcons.hammerScrewdriver, size: 16),
                            label: const Text("CONSTRUCT"),
                            style: ElevatedButton.styleFrom(
                                backgroundColor: canAfford
                                    ? dynamicAccent
                                    : AppTheme.fhTextDisabled,
                                foregroundColor: buttonTextColor,
                                padding: const EdgeInsets.symmetric(
                                    vertical: 10), // Increased padding
                                textStyle: const TextStyle(
                                    fontSize: 13,
                                    fontWeight:
                                        FontWeight.bold)), // Bolder text
                            onPressed: canAfford
                                ? () => gameProvider
                                    .buyAndPlaceBuilding(template.id)
                                : null,
                          ),
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
            const SizedBox(height: 20), // Space between categories
          ],
        );
      }).toList(),
    );
    // --- MODIFICATION END ---
  }

  Widget _buildOwnedBuildingsSection(
      BuildContext context, GameProvider gameProvider, Color dynamicAccent) {
    final theme = Theme.of(context);
    final ownedBuildings = gameProvider.ownedBuildings;

    if (ownedBuildings.isEmpty) {
      return const Center(
          child: Padding(
        padding: EdgeInsets.symmetric(vertical: 16.0),
        child: Text("No structures built yet.",
            style: TextStyle(fontStyle: FontStyle.italic)),
      ));
    }

    return ListView.builder(
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(),
      itemCount: ownedBuildings.length,
      itemBuilder: (ctx, index) {
        final owned = ownedBuildings[index];
        final template = gameProvider.buildingTemplatesList.firstWhere(
            (t) => t.id == owned.templateId,
            orElse: () => BuildingTemplate(
                id: 'unknown',
                name: 'Unknown Building',
                type: 'unknown',
                costDollars: 0,
                icon: 'mdi-help-rhombus'));

        String statusText = owned.isOperational ? 'Online' : 'Offline';
        Color statusColor = owned.isOperational
            ? AppTheme.fhAccentGreen
            : AppTheme.fhAccentOrange;
        String tooltipAction =
            owned.isOperational ? "Take Offline" : "Bring Online";

        if (!owned.isOperational && (template.powerRequired ?? 0) > 0) {
          int totalPowerGenerated =
              gameProvider.parkManager.currentPowerGenerated;
          int totalPowerConsumedExcludingThis =
              gameProvider.parkManager.currentPowerConsumed -
                  (owned.isOperational ? (template.powerRequired ?? 0) : 0);

          if (totalPowerGenerated <
              totalPowerConsumedExcludingThis + (template.powerRequired ?? 0)) {
            statusText = 'Offline - No Power';
            statusColor = AppTheme.fhAccentRed;
            tooltipAction = "Needs Power";
          }
        }

        return Card(
          margin: const EdgeInsets.symmetric(vertical: 4),
          color: AppTheme.fhBgLight,
          child: ListTile(
            leading: Icon(MdiIcons.fromString(template.icon) ?? MdiIcons.domain,
                color: dynamicAccent),
            title: Text(template.name, style: theme.textTheme.titleMedium),
            subtitle: Text(
                "Type: ${template.type.replaceAll('_', ' ').toUpperCase()} - Status: $statusText",
                style: theme.textTheme.bodySmall?.copyWith(color: statusColor)),
            trailing: Wrap(
              spacing: 0,
              children: [
                IconButton(
                  icon: Icon(
                      owned.isOperational
                          ? MdiIcons.powerPlugOffOutline
                          : MdiIcons.powerPlugOutline,
                      size: 20,
                      color: AppTheme.fhTextSecondary),
                  tooltip: tooltipAction,
                  onPressed: () => gameProvider
                      .toggleBuildingOperationalStatus(owned.uniqueId),
                ),
                IconButton(
                  icon: Icon(MdiIcons.deleteOutline,
                      size: 20, color: AppTheme.fhAccentRed),
                  tooltip: "Demolish",
                  onPressed: () => gameProvider.sellBuilding(owned.uniqueId),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildFossilCenterSection(
      BuildContext context, GameProvider gameProvider, Color dynamicAccent) {
    final theme = Theme.of(context);
    final availableSpeciesForExcavation = gameProvider.dinosaurSpeciesList
        .where((species) =>
            gameProvider.playerLevel >= species.minPlayerLevelToUnlock)
        .toList();

    final fossilRecords =
        gameProvider.fossilRecords; // Using the local GameProvider instance

    final bool fossilCenterOperational = gameProvider.ownedBuildings.any((b) {
      final template = gameProvider.buildingTemplatesList
          .firstWhereOrNull((t) => t.id == b.templateId);
      return template?.type == "fossil_center" && b.isOperational;
    });

    if (!fossilCenterOperational) {
      return _buildConditionalPlaceholder(
          theme,
          "Build and operate an Expedition Center to start fossil hunts.",
          MdiIcons.compassOffOutline);
    }
    if (availableSpeciesForExcavation.isEmpty) {
      return const Center(
          child: Text(
              "No dinosaur species currently available for excavation at your level.",
              style: TextStyle(fontStyle: FontStyle.italic)));
    }

    return Card(
      color: AppTheme.fhBgMedium,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            if (availableSpeciesForExcavation.isEmpty)
              const Text("No active fossil expeditions. Start discovering!",
                  style: TextStyle(fontStyle: FontStyle.italic)),
            ListView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: availableSpeciesForExcavation.length,
              itemBuilder: (ctx, index) {
                final species = availableSpeciesForExcavation[index];
                final record = fossilRecords
                        .firstWhereOrNull((fr) => fr.speciesId == species.id) ??
                    FossilRecord(
                        speciesId:
                            species.id); // Handle if record doesn't exist yet

                return Padding(
                  padding: const EdgeInsets.symmetric(vertical: 8.0),
                  child: Row(
                    children: [
                      Icon(MdiIcons.fromString(species.icon) ?? MdiIcons.bone,
                          size: 24, color: dynamicAccent),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(species.name,
                                style: theme.textTheme.titleMedium),
                            LinearProgressIndicator(
                              value: record.excavationProgress / 100,
                              backgroundColor:
                                  AppTheme.fhBorderColor.withOpacity(0.3),
                              valueColor:
                                  AlwaysStoppedAnimation<Color>(dynamicAccent),
                            ),
                            Text(
                                "Genome: ${record.excavationProgress.toStringAsFixed(1)}% ${record.isGenomeComplete ? '(Complete)' : ''}",
                                style: theme.textTheme.bodySmall),
                          ],
                        ),
                      ),
                      const SizedBox(width: 12),
                      ElevatedButton(
                        style: ElevatedButton.styleFrom(
                            backgroundColor: dynamicAccent,
                            padding: const EdgeInsets.symmetric(
                                horizontal: 8, vertical: 4),
                            textStyle: const TextStyle(fontSize: 10)),
                        onPressed: record.isGenomeComplete ||
                                gameProvider.playerEnergy <
                                    species.fossilExcavationEnergyCost
                            ? null
                            : () => gameProvider.excavateFossil(species.id),
                        child: Text(record.isGenomeComplete
                            ? "COMPLETE"
                            : "EXCAVATE (${species.fossilExcavationEnergyCost}⚡)"),
                      ),
                    ],
                  ),
                );
              },
            )
          ],
        ),
      ),
    );
  }

  Widget _buildHatcherySection(
      BuildContext context, GameProvider gameProvider, Color dynamicAccent) {
    final theme = Theme.of(context);

    final bool hatcheryOperational = gameProvider.ownedBuildings.any((b) {
      final template = gameProvider.buildingTemplatesList
          .firstWhereOrNull((t) => t.id == b.templateId);
      return template?.type == "hatchery" && b.isOperational;
    });

    if (!hatcheryOperational) {
      return _buildConditionalPlaceholder(
          theme,
          "Build and operate a Hammond Creation Lab to incubate dinosaurs.",
          MdiIcons.eggOffOutline);
    }

    final completableFossils = gameProvider.fossilRecords.where((fr) {
      final species = gameProvider.dinosaurSpeciesList
          .firstWhereOrNull((s) => s.id == fr.speciesId);
      return species != null &&
          gameProvider.playerLevel >= species.minPlayerLevelToUnlock &&
          fr.isGenomeComplete &&
          !gameProvider.ownedDinosaurs.any((od) =>
              od.speciesId == fr.speciesId && od.name.contains("(Incubating)"));
    }).toList();

    final incubatingDinos = gameProvider.ownedDinosaurs
        .where((d) => d.name.contains("(Incubating)"))
        .toList();

    return Card(
      color: AppTheme.fhBgMedium,
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (completableFossils.isEmpty && incubatingDinos.isEmpty)
              const Center(
                  child: Text(
                      "No complete genomes ready for incubation or none currently incubating. Keep excavating!",
                      style: TextStyle(fontStyle: FontStyle.italic))),
            if (completableFossils.isNotEmpty) ...[
              Text("Ready for Incubation:",
                  style: theme.textTheme.titleLarge
                      ?.copyWith(color: dynamicAccent)),
              const SizedBox(height: 8),
            ],
            ...completableFossils.map((record) {
              final species = gameProvider.dinosaurSpeciesList
                  .firstWhereOrNull((s) => s.id == record.speciesId);
              if (species == null) return const SizedBox.shrink();
              final canAffordIncubation =
                  gameProvider.parkManager.parkDollars >=
                          species.incubationCostDollars &&
                      gameProvider.playerEnergy >= incubationEnergyCost;

              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 8.0),
                child: Row(
                  children: [
                    Icon(
                        MdiIcons.fromString(species.icon) ??
                            MdiIcons.eggOutline,
                        size: 24,
                        color: dynamicAccent),
                    const SizedBox(width: 12),
                    Expanded(
                        child: Text("${species.name} Genome Ready",
                            style: theme.textTheme.titleMedium)),
                    ElevatedButton(
                      style: ElevatedButton.styleFrom(
                          backgroundColor: dynamicAccent,
                          padding: const EdgeInsets.symmetric(
                              horizontal: 8, vertical: 4),
                          textStyle: const TextStyle(fontSize: 10)),
                      onPressed: canAffordIncubation
                          ? () => gameProvider.incubateDinosaur(species.id)
                          : null,
                      child: Text(canAffordIncubation
                          ? "INCUBATE (\$${species.incubationCostDollars}, $incubationEnergyCost⚡)"
                          : "CAN'T AFFORD"),
                    ),
                  ],
                ),
              );
            }),
            if (incubatingDinos.isNotEmpty) ...[
              const Divider(height: 20),
              Text("Currently Incubating:",
                  style: theme.textTheme.titleLarge
                      ?.copyWith(color: dynamicAccent)),
              const SizedBox(height: 8),
            ],
            ...incubatingDinos.map((dino) {
              final species = gameProvider.dinosaurSpeciesList
                  .firstWhereOrNull((s) => s.id == dino.speciesId);
              final double incubationProgress =
                  (dino.age / baseIncubationDuration.toDouble())
                      .clamp(0.0, 1.0);
              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 8.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(
                            MdiIcons.fromString(species?.icon ?? "") ??
                                MdiIcons.timerSand,
                            color: dynamicAccent,
                            size: 24),
                        const SizedBox(width: 12),
                        Expanded(
                            child: Text(species?.name ?? "Dinosaur",
                                style: theme.textTheme.titleMedium)),
                      ],
                    ),
                    const SizedBox(height: 4),
                    LinearProgressIndicator(
                      value: incubationProgress,
                      backgroundColor: AppTheme.fhBorderColor.withOpacity(0.3),
                      valueColor: AlwaysStoppedAnimation<Color>(
                          dynamicAccent.withOpacity(0.7)),
                    ),
                    const SizedBox(height: 2),
                    Text(
                        "Progress: ${(incubationProgress * 100).toStringAsFixed(0)}% (Time: ${dino.age}/$baseIncubationDuration units)",
                        style: theme.textTheme.bodySmall),
                  ],
                ),
              );
            }),
          ],
        ),
      ),
    );
  }

  Widget _buildEnclosuresSection(
      BuildContext context, GameProvider gameProvider, Color dynamicAccent) {
    final theme = Theme.of(context);
    final enclosures = gameProvider.ownedBuildings.where((b) {
      final template = gameProvider.buildingTemplatesList
          .firstWhereOrNull((t) => t.id == b.templateId);
      return template?.type == "enclosure" && b.isOperational;
    }).toList();

    if (enclosures.isEmpty) {
      return _buildConditionalPlaceholder(
          theme,
          "Build and operate Enclosures to house your dinosaurs.",
          MdiIcons.fence);
    }

    final hatchedDinosaursNotInEnclosures =
        gameProvider.ownedDinosaurs.where((dino) {
      return !gameProvider.ownedBuildings.any((building) =>
              building.dinosaurUniqueIds.contains(dino.uniqueId)) &&
          !dino.name.contains("(Incubating)");
    }).toList();

    return ListView(
      // Changed to ListView for better scrolling if many enclosures
      shrinkWrap: true,
      physics: const NeverScrollableScrollPhysics(), // Parent handles scrolling
      children: [
        ...enclosures.map((enclosure) {
          final template = gameProvider.buildingTemplatesList
              .firstWhereOrNull((t) => t.id == enclosure.templateId)!;
          final dinosaursInEnclosure = gameProvider.ownedDinosaurs
              .where((d) => enclosure.dinosaurUniqueIds.contains(d.uniqueId))
              .toList();
          final foodStation = gameProvider.ownedBuildings.firstWhereOrNull((b) {
            final foodTemplate = gameProvider.buildingTemplatesList
                .firstWhereOrNull((t) => t.id == b.templateId);
            // This is a simplified assumption: any operational food station can feed any enclosure.
            // A more complex system might link specific feeders to enclosures.
            return foodTemplate?.type == "food_station" && b.isOperational;
          });

          return Card(
            margin: const EdgeInsets.symmetric(vertical: 8.0),
            color: AppTheme.fhBgMedium,
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(template.name,
                      style: theme.textTheme.headlineSmall
                          ?.copyWith(color: dynamicAccent)),
                  Text(
                      "Capacity: ${dinosaursInEnclosure.length} / ${template.capacity ?? 'N/A'}",
                      style: theme.textTheme.bodySmall),
                  if (foodStation != null)
                    Text(
                        "Food Level in Park: ${foodStation.currentFoodLevel ?? 0} / $enclosureBaseFoodCapacity",
                        style: theme.textTheme.bodySmall),
                  const SizedBox(height: 10),
                  Wrap(
                    spacing: 8,
                    children: [
                      if (foodStation != null)
                        ElevatedButton.icon(
                          icon: Icon(MdiIcons.foodAppleOutline, size: 16),
                          label: Text("Add Food ($feedDinoEnergyCost⚡)",
                              style: const TextStyle(fontSize: 10)),
                          onPressed:
                              gameProvider.playerEnergy >= feedDinoEnergyCost
                                  ? () => gameProvider.feedDinosaursInEnclosure(
                                      enclosure.uniqueId, 50)
                                  : null,
                          style: ElevatedButton.styleFrom(
                              backgroundColor: dynamicAccent,
                              padding:
                                  const EdgeInsets.symmetric(horizontal: 8)),
                        ),
                      if (hatchedDinosaursNotInEnclosures.isNotEmpty &&
                          (template.capacity == null ||
                              dinosaursInEnclosure.length < template.capacity!))
                        PopupMenuButton<String>(
                            onSelected: (dinoUniqueId) =>
                                gameProvider.addDinosaurToEnclosure(
                                    dinoUniqueId, enclosure.uniqueId),
                            enabled: enclosure.isOperational,
                            itemBuilder: (BuildContext context) {
                              return hatchedDinosaursNotInEnclosures
                                  .map((dino) {
                                final species = gameProvider.dinosaurSpeciesList
                                    .firstWhereOrNull(
                                        (s) => s.id == dino.speciesId);
                                return PopupMenuItem<String>(
                                  value: dino.uniqueId,
                                  child: Text(species?.name ?? dino.name),
                                );
                              }).toList();
                            },
                            child: ElevatedButton.icon(
                              icon: Icon(MdiIcons.plusBoxOutline, size: 16),
                              label: Text("Add Dino",
                                  style: const TextStyle(fontSize: 10)),
                              onPressed: enclosure.isOperational ? null : () {},
                              style: ElevatedButton.styleFrom(
                                  backgroundColor: enclosure.isOperational
                                      ? dynamicAccent
                                      : AppTheme.fhTextDisabled,
                                  padding: const EdgeInsets.symmetric(
                                      horizontal: 8)),
                            )),
                    ],
                  ),
                  const SizedBox(height: 10),
                  if (dinosaursInEnclosure.isEmpty)
                    const Text("This enclosure is empty.",
                        style: TextStyle(fontStyle: FontStyle.italic)),
                  ...dinosaursInEnclosure.map((dino) {
                    final species = gameProvider.dinosaurSpeciesList
                        .firstWhereOrNull((s) => s.id == dino.speciesId);
                    return ListTile(
                      leading: Icon(
                          MdiIcons.fromString(species?.icon ?? "") ??
                              MdiIcons.paw,
                          color: dynamicAccent),
                      title: Text(dino.name),
                      subtitle: Text(
                          "${species?.name ?? "Dinosaur"} - Comfort: ${dino.currentComfort.toStringAsFixed(0)}% Food: ${dino.currentFood.toStringAsFixed(0)}%"),
                      onTap: () {
                        setState(() {
                          _selectedOwnedDinoId = dino.uniqueId;
                        });
                      },
                    );
                  }),
                ],
              ),
            ),
          );
        }),
      ],
    );
  }

  Widget _buildOwnedDinosaurDetails(BuildContext context,
      GameProvider gameProvider, Color dynamicAccent, String dinoUniqueId) {
    final theme = Theme.of(context);
    final ownedDino = gameProvider.ownedDinosaurs
        .firstWhereOrNull((d) => d.uniqueId == dinoUniqueId);
    if (ownedDino == null) return const SizedBox.shrink();
    final species = gameProvider.dinosaurSpeciesList
        .firstWhereOrNull((s) => s.id == ownedDino.speciesId);
    if (species == null) return const SizedBox.shrink();

    return Dialog(
      backgroundColor: AppTheme.fhBgMedium,
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(ownedDino.name,
                      style: theme.textTheme.headlineMedium
                          ?.copyWith(color: dynamicAccent)),
                  IconButton(
                      icon: Icon(MdiIcons.closeCircleOutline,
                          color: AppTheme.fhTextSecondary),
                      onPressed: () =>
                          setState(() => _selectedOwnedDinoId = null))
                ],
              ),
              Text("Species: ${species.name}",
                  style: theme.textTheme.titleMedium),
              const Divider(height: 20),
              _buildStatRow(
                  theme,
                  MdiIcons.heartPulse,
                  "Health:",
                  "${ownedDino.currentHealth.toStringAsFixed(0)}%",
                  ownedDino.currentHealth > 60
                      ? AppTheme.fhAccentGreen
                      : (ownedDino.currentHealth > 30
                          ? AppTheme.fhAccentOrange
                          : AppTheme.fhAccentRed)),
              _buildStatRow(
                  theme,
                  MdiIcons.emoticonHappyOutline,
                  "Comfort:",
                  "${ownedDino.currentComfort.toStringAsFixed(0)}%",
                  ownedDino.currentComfort > species.comfortThreshold * 100
                      ? AppTheme.fhAccentGreen
                      : AppTheme.fhAccentOrange),
              _buildStatRow(
                  theme,
                  MdiIcons.foodDrumstickOutline,
                  "Food:",
                  "${ownedDino.currentFood.toStringAsFixed(0)}%",
                  ownedDino.currentFood > 50
                      ? AppTheme.fhAccentGreen
                      : (ownedDino.currentFood > 20
                          ? AppTheme.fhAccentOrange
                          : AppTheme.fhAccentRed)),
              _buildStatRow(theme, MdiIcons.cakeVariantOutline, "Age:",
                  "${ownedDino.age} days", AppTheme.fhTextSecondary),
              _buildStatRow(theme, MdiIcons.scaleBalance, "Diet:", species.diet,
                  AppTheme.fhTextSecondary),
              const SizedBox(height: 10),
              Text("Needs:", style: theme.textTheme.titleSmall),
              Padding(
                padding: const EdgeInsets.only(left: 16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                        "- Social Group: ${species.socialNeedsMin}-${species.socialNeedsMax}",
                        style: theme.textTheme.bodySmall),
                    Text("- Paddock Size: ${species.enclosureSizeNeeds} units",
                        style: theme.textTheme.bodySmall),
                  ],
                ),
              ),
              const SizedBox(height: 20),
              Text(species.description,
                  style: theme.textTheme.bodyMedium?.copyWith(
                      fontStyle: FontStyle.italic,
                      color: AppTheme.fhTextSecondary)),
            ],
          ),
        ),
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/views/park_view.dart ---

--- START OF FILE lib/src/widgets/views/settings_view.dart ---
// lib/src/widgets/views/settings_view.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:intl/intl.dart';

class SettingsView extends StatefulWidget {
  const SettingsView({super.key});

  @override
  State<SettingsView> createState() => _SettingsViewState();
}

class _SettingsViewState extends State<SettingsView> {
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  final _newUsernameController = TextEditingController(); // For username change
  bool _passwordChangeLoading = false;
  String _passwordChangeError = '';
  String _passwordChangeSuccess = '';
  bool _usernameChangeLoading = false; // For username change
  String _usernameChangeError = ''; // For username change
  String _usernameChangeSuccess = ''; // For username change
  bool _logoutLoading = false;

  @override
  void initState() {
    super.initState();
    // Initialize username controller if user is available
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    _newUsernameController.text = gameProvider.currentUser?.displayName ?? '';
  }

  @override
  void dispose() {
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    _newUsernameController.dispose();
    super.dispose();
  }

  Future<void> _handleChangePassword(GameProvider gameProvider) async {
    if (_newPasswordController.text != _confirmPasswordController.text) {
      setState(() => _passwordChangeError = "Passwords do not match.");
      return;
    }
    if (_newPasswordController.text.length < 6) {
      setState(() => _passwordChangeError =
          "Password should be at least 6 characters long.");
      return;
    }
    setState(() {
      _passwordChangeLoading = true;
      _passwordChangeError = '';
      _passwordChangeSuccess = '';
    });
    try {
      await gameProvider.changePasswordHandler(_newPasswordController.text);
      setState(() {
        _passwordChangeSuccess = "Password changed successfully!";
        _newPasswordController.clear();
        _confirmPasswordController.clear();
      });
    } catch (e) {
      if (e is FirebaseAuthException) {
        setState(() =>
            _passwordChangeError = e.message ?? "Failed to change password.");
      } else {
        setState(() => _passwordChangeError =
            "An unexpected error occurred while changing password.");
      }
    } finally {
      if (mounted) {
        setState(() => _passwordChangeLoading = false);
      }
    }
  }

  Future<void> _handleChangeUsername(GameProvider gameProvider) async {
    if (_newUsernameController.text.trim().isEmpty) {
      setState(() => _usernameChangeError = "Username cannot be empty.");
      return;
    }
    if (_newUsernameController.text.trim().length < 3) {
      setState(() =>
          _usernameChangeError = "Username must be at least 3 characters.");
      return;
    }
    setState(() {
      _usernameChangeLoading = true;
      _usernameChangeError = '';
      _usernameChangeSuccess = '';
    });
    try {
      await gameProvider
          .updateUserDisplayName(_newUsernameController.text.trim());
      setState(() {
        _usernameChangeSuccess = "Username updated successfully!";
      });
    } catch (e) {
      if (e is FirebaseAuthException) {
        setState(() =>
            _usernameChangeError = e.message ?? "Failed to update username.");
      } else {
        setState(() => _usernameChangeError =
            "An unexpected error occurred while updating username.");
      }
    } finally {
      if (mounted) {
        setState(() => _usernameChangeLoading = false);
      }
    }
  }

  Future<void> _handleLogout(
      GameProvider gameProvider, BuildContext pageContext) async {
    setState(() {
      _logoutLoading = true;
    });
    try {
      await gameProvider.logoutUser();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(pageContext).showSnackBar(SnackBar(
          content: Text('Logout failed: ${e.toString()}'),
          backgroundColor: AppTheme.fhAccentRed));
    } finally {
      if (mounted) {
        setState(() {
          _logoutLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);

    String lastSavedString = "Not synced yet.";
    if (gameProvider.lastSuccessfulSaveTimestamp != null) {
      lastSavedString =
          "Last synced: ${DateFormat('MMM d, yyyy, hh:mm:ss a').format(gameProvider.lastSuccessfulSaveTimestamp!.toLocal())}";
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
         
          _buildSettingsSection(gameProvider, theme,
              icon: MdiIcons.cloudSyncOutline,
              title: 'Cloud Synchronization',
              children: [
                ElevatedButton.icon(
                  icon: gameProvider.isManuallySaving
                      ? const SizedBox(
                          width: 18,
                          height: 18,
                          child: CircularProgressIndicator(
                              strokeWidth: 2, color: AppTheme.fhTextPrimary))
                      : Icon(MdiIcons.cloudUploadOutline, size: 18),
                  label: const Text('SAVE TO CLOUD NOW'),
                  onPressed: gameProvider.isManuallySaving ||
                          gameProvider.isManuallyLoading
                      ? null
                      : () async {
                          try {
                            await gameProvider.manuallySaveToCloud();
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                  const SnackBar(
                                      content: Text('Data saved to cloud.'),
                                      backgroundColor: AppTheme.fhAccentGreen));
                            }
                          } catch (e) {
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                      content: Text(
                                          'Cloud save failed: ${e.toString()}'),
                                      backgroundColor: AppTheme.fhAccentRed));
                            }
                          }
                        },
                  style: ElevatedButton.styleFrom(
                      minimumSize: const Size(double.infinity, 44),
                      backgroundColor:
                          (gameProvider.getSelectedTask()?.taskColor ??
                              AppTheme.fhAccentTealFixed),
                      foregroundColor: AppTheme.fhBgDark),
                ),
                const SizedBox(height: 12),
                ElevatedButton.icon(
                  icon: gameProvider.isManuallyLoading
                      ? const SizedBox(
                          width: 18,
                          height: 18,
                          child: CircularProgressIndicator(
                              strokeWidth: 2, color: AppTheme.fhTextPrimary))
                      : Icon(MdiIcons.cloudDownloadOutline, size: 18),
                  label: const Text('LOAD FROM CLOUD NOW'),
                  onPressed: gameProvider.isManuallySaving ||
                          gameProvider.isManuallyLoading
                      ? null
                      : () async {
                          final confirm = await showDialog<bool>(
                            context: context,
                            builder: (ctx) => AlertDialog(
                              title: Row(children: [
                                Icon(MdiIcons.cloudQuestionOutline,
                                    color: AppTheme.fhAccentOrange),
                                const SizedBox(width: 10),
                                const Text('Confirm Load')
                              ]),
                              content: const Text(
                                  'This will overwrite any local unsaved changes with data from the cloud. Are you sure?'),
                              actionsAlignment: MainAxisAlignment.spaceBetween,
                              actions: [
                                TextButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(false),
                                    child: const Text('CANCEL')),
                                ElevatedButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(true),
                                    style: ElevatedButton.styleFrom(
                                        backgroundColor:
                                            AppTheme.fhAccentOrange),
                                    child: const Text('CONFIRM LOAD')),
                              ],
                            ),
                          );
                          if (confirm == true) {
                            try {
                              await gameProvider.manuallyLoadFromCloud();
                              if (mounted) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                    const SnackBar(
                                        content:
                                            Text('Data loaded from cloud.'),
                                        backgroundColor:
                                            AppTheme.fhAccentGreen));
                              }
                            } catch (e) {
                              if (mounted) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                        content: Text(
                                            'Cloud load failed: ${e.toString()}'),
                                        backgroundColor: AppTheme.fhAccentRed));
                              }
                            }
                          }
                        },
                  style: ElevatedButton.styleFrom(
                      minimumSize: const Size(double.infinity, 44),
                      backgroundColor:
                          (gameProvider.getSelectedTask()?.taskColor ??
                              AppTheme.fhAccentTealFixed),
                      foregroundColor: AppTheme.fhBgDark),
                ),
                const SizedBox(height: 12),
                Center(
                  child: Text(
                    lastSavedString,
                    style: theme.textTheme.labelSmall?.copyWith(
                        color: AppTheme.fhTextSecondary.withOpacity(0.8),
                        fontSize: 11,
                        fontStyle: FontStyle.italic),
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  "Note: Game progress is auto-saved to the cloud periodically (approx. every minute if changes are detected). Use these options for immediate synchronization or recovery.",
                  style: theme.textTheme.bodySmall?.copyWith(
                      color: AppTheme.fhTextSecondary.withOpacity(0.8),
                      fontSize: 10),
                ),
              ]),
          _buildSettingsSection(gameProvider, theme,
              icon: MdiIcons.accountEditOutline,
              title: 'User Profile',
              children: [
                TextFormField(
                  controller: _newUsernameController,
                  decoration: InputDecoration(
                      labelText: 'Display Name',
                      prefixIcon: Icon(MdiIcons.accountBadgeOutline, size: 20)),
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Display name cannot be empty.';
                    }
                    if (value.trim().length < 3) {
                      return 'Must be at least 3 characters.';
                    }
                    return null;
                  },
                ),
                if (_usernameChangeError.isNotEmpty)
                  Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(_usernameChangeError,
                        style: const TextStyle(
                            color: AppTheme.fhAccentRed, fontSize: 12)),
                  ),
                if (_usernameChangeSuccess.isNotEmpty)
                  Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(_usernameChangeSuccess,
                        style: const TextStyle(
                            color: AppTheme.fhAccentGreen, fontSize: 12)),
                  ),
                const SizedBox(height: 16),
                ElevatedButton.icon(
                  icon: _usernameChangeLoading
                      ? const SizedBox(
                          width: 18,
                          height: 18,
                          child: CircularProgressIndicator(
                              strokeWidth: 2, color: AppTheme.fhTextPrimary))
                      : Icon(MdiIcons.contentSaveOutline, size: 18),
                  label: const Text('UPDATE DISPLAY NAME'),
                  onPressed: _usernameChangeLoading
                      ? null
                      : () => _handleChangeUsername(gameProvider),
                  style: ElevatedButton.styleFrom(
                      minimumSize: const Size(double.infinity, 44)),
                ),
              ]),
          _buildSettingsSection(
            gameProvider,
            theme,
            icon: MdiIcons.brain,
            title: 'Cognitive Matrix (AI)',
            children: [
              SwitchListTile.adaptive(
                title: const Text('Daily Auto-Generate Content'),
                subtitle: const Text(
                    'Each day, automatically generate new challenges (enemies, and a new realm if current one is pacified).'),
                value: gameProvider.settings.dailyAutoGenerateContent,
                onChanged: (value) => gameProvider.setSettings(
                    gameProvider.settings..dailyAutoGenerateContent = value),
                activeColor: (gameProvider.getSelectedTask()?.taskColor ??
                    AppTheme.fhAccentTealFixed),
                contentPadding: EdgeInsets.zero,
              ),
              const SizedBox(height: 12),
              Text(
                'Manually initiate content generation protocols for current operational level (${gameProvider.playerLevel}). This may consume significant resources.',
                style: theme.textTheme.bodySmall
                    ?.copyWith(color: AppTheme.fhTextSecondary),
              ),
              const SizedBox(height: 12),
              ElevatedButton.icon(
                icon: gameProvider.isGeneratingContent &&
                        gameProvider.aiGenerationStatusMessage
                            .contains("Adversaries")
                    ? const SizedBox(
                        width: 18,
                        height: 18,
                        child: CircularProgressIndicator(
                            strokeWidth: 2.5, color: AppTheme.fhTextPrimary))
                    : Icon(MdiIcons.skullCrossbonesOutline, size: 18),
                label: Text(gameProvider.isGeneratingContent &&
                        gameProvider.aiGenerationStatusMessage
                            .contains("Adversaries")
                    ? 'GENERATING ADVERSARIES...'
                    : 'GENERATE NEW ADVERSARIES'),
                onPressed: gameProvider.isGeneratingContent
                    ? null
                    : () => gameProvider.generateGameContent(
                        gameProvider.playerLevel,
                        isManual: true,
                        isInitial: false,
                        contentType: "enemies"),
                style: ElevatedButton.styleFrom(
                    minimumSize: const Size(double.infinity, 44)),
              ),
              const SizedBox(height: 12),
              ElevatedButton.icon(
                icon: gameProvider.isGeneratingContent &&
                        gameProvider.aiGenerationStatusMessage
                            .contains("Artifacts")
                    ? const SizedBox(
                        width: 18,
                        height: 18,
                        child: CircularProgressIndicator(
                            strokeWidth: 2.5, color: AppTheme.fhTextPrimary))
                    : Icon(MdiIcons.swordCross, size: 18),
                label: Text(gameProvider.isGeneratingContent &&
                        gameProvider.aiGenerationStatusMessage
                            .contains("Artifacts")
                    ? 'FORGING ARTIFACTS...'
                    : 'FORGE NEW ARTIFACTS'),
                onPressed: gameProvider.isGeneratingContent
                    ? null
                    : () => gameProvider.generateGameContent(
                        gameProvider.playerLevel,
                        isManual: true,
                        isInitial: false,
                        contentType: "artifacts"),
                style: ElevatedButton.styleFrom(
                    minimumSize: const Size(double.infinity, 44)),
              ),
              const SizedBox(height: 12),
              ElevatedButton.icon(
                icon: gameProvider.isGeneratingContent &&
                        gameProvider.aiGenerationStatusMessage.contains("Realms")
                    ? const SizedBox(
                        width: 18,
                        height: 18,
                        child: CircularProgressIndicator(
                            strokeWidth: 2.5, color: AppTheme.fhTextPrimary))
                    : Icon(MdiIcons.mapSearchOutline, size: 18),
                label: Text(gameProvider.isGeneratingContent &&
                        gameProvider.aiGenerationStatusMessage.contains("Realms")
                    ? 'DISCOVERING REALMS...'
                    : 'DISCOVER NEW REALMS'),
                onPressed: gameProvider.isGeneratingContent
                    ? null
                    : () => gameProvider.generateGameContent(
                        gameProvider.playerLevel,
                        isManual: true,
                        isInitial: false,
                        contentType: "locations"),
                style: ElevatedButton.styleFrom(
                    minimumSize: const Size(double.infinity, 44)),
              ),
              if (gameProvider.isGeneratingContent)
                Padding(
                  padding: const EdgeInsets.only(top: 10.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      LinearProgressIndicator(
                        value: gameProvider.aiGenerationProgress,
                        backgroundColor:
                            AppTheme.fhBorderColor.withOpacity(0.2),
                        valueColor: AlwaysStoppedAnimation<Color>(
                            (gameProvider.getSelectedTask()?.taskColor ??
                                    AppTheme.fhAccentTealFixed)
                                .withOpacity(0.7)),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        gameProvider.aiGenerationStatusMessage.isNotEmpty
                            ? gameProvider.aiGenerationStatusMessage
                            : 'Cognitive matrix recalculating... please standby.',
                        style: theme.textTheme.bodySmall?.copyWith(
                            fontStyle: FontStyle.italic,
                            color: (gameProvider.getSelectedTask()?.taskColor ??
                                    AppTheme.fhAccentTealFixed)
                                .withOpacity(0.8)),
                      ),
                    ],
                  ),
                ),
            ],
          ),
          _buildSettingsSection(gameProvider, theme,
              icon: MdiIcons.mapLegend,
              title: "Manage Realms (Combat Zones)",
              children: [
                if (gameProvider.gameLocationsList.isEmpty)
                  const Text("No combat zones discovered yet.",
                      style: TextStyle(fontStyle: FontStyle.italic)),
                ListView.builder(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  itemCount: gameProvider.gameLocationsList.length,
                  itemBuilder: (context, index) {
                    final location = gameProvider.gameLocationsList[index];
                    return ListTile(
                      leading: Text(location.iconEmoji,
                          style: const TextStyle(fontSize: 20)),
                      title: Text(location.name),
                      subtitle: Text(
                          "Lvl ${location.minPlayerLevelToUnlock}+. ${location.description}",
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis),
                      trailing: IconButton(
                        icon: Icon(MdiIcons.mapMarkerRemoveVariant,
                            color: AppTheme.fhAccentRed),
                        tooltip: "Decommission Realm",
                        onPressed: () async {
                          final confirm = await showDialog<bool>(
                            context: context,
                            builder: (ctx) => AlertDialog(
                              title: Row(children: [
                                Icon(MdiIcons.alertOutline,
                                    color: AppTheme.fhAccentRed),
                                const SizedBox(width: 10),
                                const Text('Confirm Decommission')
                              ]),
                              content: Text(
                                  'Are you sure you want to decommission the realm "${location.name}"? This cannot be undone.'),
                              actionsAlignment: MainAxisAlignment.spaceBetween,
                              actions: [
                                TextButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(false),
                                    child: const Text('CANCEL')),
                                ElevatedButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(true),
                                    style: ElevatedButton.styleFrom(
                                        backgroundColor: AppTheme.fhAccentRed),
                                    child: const Text('DECOMMISSION REALM')),
                              ],
                            ),
                          );
                          if (confirm == true) {
                            gameProvider.deleteGameLocation(location.id);
                          }
                        },
                      ),
                    );
                  },
                )
              ]),
          _buildSettingsSection(gameProvider, theme,
              icon: MdiIcons.layersTripleOutline,
              title: 'Content Matrix Control',
              children: [
                Text(
                  'Manage generated game content. These actions are specific and do not affect player progress directly, but may alter game balance or availability of items/enemies.',
                  style: theme.textTheme.bodySmall
                      ?.copyWith(color: AppTheme.fhTextSecondary, height: 1.4),
                ),
                const SizedBox(height: 16),
                ElevatedButton.icon(
                  icon: Icon(MdiIcons.archiveRemoveOutline,
                      size: 18, color: AppTheme.fhTextPrimary),
                  label: const Text('CLEAR ARTIFACTS & BLUEPRINTS'),
                  onPressed: () async {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: Row(children: [
                          Icon(MdiIcons.alertOutline,
                              color: AppTheme.fhAccentOrange),
                          const SizedBox(width: 10),
                          const Text('Confirm Artifact Purge')
                        ]),
                        content: const Text(
                            'This will remove ALL owned artifacts from your inventory (equipped items will be unequipped) AND all artifact blueprints/templates. This action cannot be undone. Are you sure?'),
                        actionsAlignment: MainAxisAlignment.spaceBetween,
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.of(ctx).pop(false),
                              child: const Text('CANCEL')),
                          ElevatedButton(
                              onPressed: () => Navigator.of(ctx).pop(true),
                              style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.fhAccentOrange),
                              child: const Text('CONFIRM PURGE')),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      gameProvider.clearAllArtifactsAndTemplates(); // Updated method name
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                            content: Text(
                                'All owned artifacts and blueprints purged.'),
                            backgroundColor: AppTheme.fhAccentGreen));
                      }
                    }
                  },
                  style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.fhAccentOrange,
                      foregroundColor: AppTheme.fhTextPrimary,
                      minimumSize: const Size(double.infinity, 44)),
                ),
                const SizedBox(height: 12),
                ElevatedButton.icon(
                  icon: Icon(MdiIcons.skullCrossbonesOutline,
                      size: 18, color: AppTheme.fhTextPrimary),
                  label: const Text('DECOMMISSION ENEMIES'),
                  onPressed: () async {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: Row(children: [
                          Icon(MdiIcons.alertOutline,
                              color: AppTheme.fhAccentOrange),
                          const SizedBox(width: 10),
                          const Text('Confirm Decommission')
                        ]),
                        content: const Text(
                            'This removes all enemy templates. The Arena might be empty until new content is generated. This action cannot be undone. Are you sure?'),
                        actionsAlignment: MainAxisAlignment.spaceBetween,
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.of(ctx).pop(false),
                              child: const Text('CANCEL')),
                          ElevatedButton(
                              onPressed: () => Navigator.of(ctx).pop(true),
                              style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.fhAccentOrange,
                                  foregroundColor: AppTheme.fhTextPrimary),
                              child: const Text('CONFIRM DECOMMISSION')),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      gameProvider.removeAllEnemyTemplates();
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content: Text(
                                    'All enemy signatures decommissioned.'),
                                backgroundColor: AppTheme.fhAccentGreen));
                      }
                    }
                  },
                  style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.fhAccentOrange,
                      foregroundColor: AppTheme.fhTextPrimary,
                      minimumSize: const Size(double.infinity, 44)),
                ),
                const SizedBox(height: 12),
                ElevatedButton.icon( 
                  icon: Icon(MdiIcons.earthRemove,
                      size: 18, color: AppTheme.fhTextPrimary),
                  label: const Text('DECOMMISSION ALL REALMS'),
                  onPressed: () async {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: Row(children: [
                          Icon(MdiIcons.alertOutline,
                              color: AppTheme.fhAccentOrange),
                          const SizedBox(width: 10),
                          const Text('Confirm Realm Decommission')
                        ]),
                        content: const Text(
                            'This removes ALL combat zones (realms). The Arena will be inaccessible until new realms are discovered/generated. This action cannot be undone. Are you sure?'),
                        actionsAlignment: MainAxisAlignment.spaceBetween,
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.of(ctx).pop(false),
                              child: const Text('CANCEL')),
                          ElevatedButton(
                              onPressed: () => Navigator.of(ctx).pop(true),
                              style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.fhAccentOrange,
                                  foregroundColor: AppTheme.fhTextPrimary),
                              child: const Text('CONFIRM DECOMMISSION')),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      gameProvider.removeAllGameLocations();
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content: Text(
                                    'All realms decommissioned.'),
                                backgroundColor: AppTheme.fhAccentGreen));
                      }
                    }
                  },
                  style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.fhAccentOrange,
                      foregroundColor: AppTheme.fhTextPrimary,
                      minimumSize: const Size(double.infinity, 44)),
                ),
                 const SizedBox(height: 12),
                ElevatedButton.icon( // Reset Park Data button
                  icon: Icon(MdiIcons.island, // Changed icon to MdiIcons.island
                      size: 18, color: AppTheme.fhTextPrimary),
                  label: const Text('RESET JURASSIC PARK DATA'),
                  onPressed: () async {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: Row(children: [
                          Icon(MdiIcons.alertOutline,
                              color: AppTheme.fhAccentOrange),
                          const SizedBox(width: 10),
                          const Text('Confirm Park Reset')
                        ]),
                        content: const Text(
                            'This will reset all Jurassic Park data (owned dinosaurs, buildings, fossils, park rating, funds). Dinosaur species and building blueprints will remain. This action cannot be undone. Are you sure?'),
                        actionsAlignment: MainAxisAlignment.spaceBetween,
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.of(ctx).pop(false),
                              child: const Text('CANCEL')),
                          ElevatedButton(
                              onPressed: () => Navigator.of(ctx).pop(true),
                              style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.fhAccentOrange,
                                  foregroundColor: AppTheme.fhTextPrimary),
                              child: const Text('CONFIRM PARK RESET')),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      await gameProvider.resetParkData();
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content: Text(
                                    'Jurassic Park data has been reset.'),
                                backgroundColor: AppTheme.fhAccentGreen));
                      }
                    }
                  },
                  style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.fhAccentOrange,
                      foregroundColor: AppTheme.fhTextPrimary,
                      minimumSize: const Size(double.infinity, 44)),
                ),
              ]),
          _buildSettingsSection(gameProvider, theme,
              icon: MdiIcons.eyeSettingsOutline,
              title: 'User Interface Config',
              children: [
                SwitchListTile.adaptive(
                  title: const Text('Verbose Data Display'),
                  subtitle: const Text(
                      'Show detailed descriptions for stats and items throughout the interface.'),
                  value: gameProvider.settings.descriptionsVisible,
                  onChanged: (value) => gameProvider.setSettings(
                      gameProvider.settings..descriptionsVisible = value),
                  activeColor: (gameProvider.getSelectedTask()?.taskColor ??
                      AppTheme.fhAccentTealFixed),
                  contentPadding: EdgeInsets.zero,
                ),
              ]),
          if (gameProvider.currentUser != null)
            _buildSettingsSection(gameProvider, theme,
                icon: MdiIcons.shieldAccountOutline,
                title: 'Access Credentials',
                children: [
                  TextFormField(
                    controller: _newPasswordController,
                    decoration: InputDecoration(
                        labelText: 'New Passcode Sequence',
                        prefixIcon:
                            Icon(MdiIcons.formTextboxPassword, size: 20)),
                    obscureText: true,
                  ),
                  const SizedBox(height: 12),
                  TextFormField(
                    controller: _confirmPasswordController,
                    decoration: InputDecoration(
                        labelText: 'Confirm Passcode Sequence',
                        prefixIcon:
                            Icon(MdiIcons.formTextboxPassword, size: 20)),
                    obscureText: true,
                  ),
                  if (_passwordChangeError.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.only(top: 10.0),
                      child: Text(_passwordChangeError,
                          style: const TextStyle(
                              color: AppTheme.fhAccentRed, fontSize: 12)),
                    ),
                  if (_passwordChangeSuccess.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.only(top: 10.0),
                      child: Text(_passwordChangeSuccess,
                          style: const TextStyle(
                              color: AppTheme.fhAccentGreen, fontSize: 12)),
                    ),
                  const SizedBox(height: 16),
                  ElevatedButton.icon(
                    icon: _passwordChangeLoading
                        ? const SizedBox(
                            width: 18,
                            height: 18,
                            child: CircularProgressIndicator(
                                strokeWidth: 2.5,
                                color: AppTheme.fhTextPrimary))
                        : Icon(MdiIcons.keyChange, size: 18),
                    label: const Text('UPDATE PASSCODE'),
                    onPressed: _passwordChangeLoading
                        ? null
                        : () => _handleChangePassword(gameProvider),
                    style: ElevatedButton.styleFrom(
                        backgroundColor:
                            (gameProvider.getSelectedTask()?.taskColor ??
                                AppTheme.fhAccentTealFixed),
                        foregroundColor: AppTheme.fhBgDark,
                        minimumSize: const Size(double.infinity, 44)),
                  ),
                  const SizedBox(height: 20),
                  OutlinedButton.icon(
                    icon: _logoutLoading
                        ? const SizedBox(
                            width: 18,
                            height: 18,
                            child: CircularProgressIndicator(
                                strokeWidth: 2.5,
                                color: AppTheme.fhAccentOrange))
                        : Icon(MdiIcons.logoutVariant, size: 18),
                    label: const Text('TERMINATE SESSION'),
                    onPressed: _logoutLoading
                        ? null
                        : () => _handleLogout(gameProvider, context),
                    style: OutlinedButton.styleFrom(
                        foregroundColor: AppTheme.fhAccentOrange,
                        side: const BorderSide(
                            color: AppTheme.fhAccentOrange, width: 1.5),
                        minimumSize: const Size(double.infinity, 44)),
                  ),
                ]),
          _buildSettingsSection(gameProvider, theme,
              icon: MdiIcons.databaseRemoveOutline,
              title: 'Data & System Reset',
              children: [
                ElevatedButton.icon(
                  icon: Icon(MdiIcons.undoVariant, size: 18),
                  label: const Text('RESET PLAYER LEVEL'),
                  onPressed: () async {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: Row(children: [
                          Icon(MdiIcons.alertOutline,
                              color: AppTheme.fhAccentOrange),
                          const SizedBox(width: 10),
                          const Text('Confirm Level Reset')
                        ]),
                        content: const Text(
                            'This will reset your player level to 1, XP to 0, and clear defeated enemies for the current level. Your tasks, items, and coins will remain. Are you sure?'),
                        actionsAlignment: MainAxisAlignment.spaceBetween,
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.of(ctx).pop(false),
                              child: const Text('CANCEL')),
                          ElevatedButton(
                              onPressed: () => Navigator.of(ctx).pop(true),
                              style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.fhAccentOrange),
                              child: const Text('CONFIRM RESET')),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      gameProvider.resetPlayerLevelAndProgress();
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content:
                                    Text('Player level and progress reset.'),
                                backgroundColor: AppTheme.fhAccentGreen));
                      }
                    }
                  },
                  style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.fhAccentOrange,
                      foregroundColor: AppTheme.fhTextPrimary,
                      minimumSize: const Size(double.infinity, 44)),
                ),
                const SizedBox(height: 16),
                Text(
                  'WARNING: The "Purge All Data" protocol will erase all operational data, including quest logs, experience, currency, and acquired assets. This action is irreversible and will reset the system to factory defaults.',
                  style: theme.textTheme.bodySmall
                      ?.copyWith(color: AppTheme.fhTextSecondary, height: 1.5),
                ),
                const SizedBox(height: 16),
                ElevatedButton.icon(
                  icon: Icon(MdiIcons.alertOctagonOutline, size: 18),
                  label: const Text('PURGE ALL DATA'),
                  onPressed: () async {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: Row(children: [
                          Icon(MdiIcons.alertOutline,
                              color: AppTheme.fhAccentRed),
                          const SizedBox(width: 10),
                          const Text('Confirm System Purge',
                              style: TextStyle(color: AppTheme.fhAccentRed))
                        ]),
                        content: const Text(
                            'Are you absolutely certain you wish to erase all data? This operation cannot be undone and will result in total loss of progress.'),
                        actionsAlignment: MainAxisAlignment.spaceBetween,
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.of(ctx).pop(false),
                              child: const Text('CANCEL')),
                          ElevatedButton(
                              onPressed: () => Navigator.of(ctx).pop(true),
                              style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.fhAccentRed,
                                  foregroundColor: AppTheme.fhTextPrimary),
                              child: const Text('CONFIRM PURGE')),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      gameProvider.clearAllGameData();
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content: Text('All game data has been purged.'),
                                backgroundColor: AppTheme.fhAccentGreen));
                      }
                    }
                  },
                  style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.fhAccentRed,
                      foregroundColor: AppTheme.fhTextPrimary,
                      minimumSize: const Size(double.infinity, 44)),
                ),
              ]),
        ],
      ),
    );
  }

  Widget _buildSettingsSection(GameProvider gameProvider, ThemeData theme,
      {required IconData icon,
      required String title,
      required List<Widget> children}) {
    return Card(
      // Using the globally themed Card
      margin: const EdgeInsets.only(bottom: 24),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(icon,
                    color: (gameProvider.getSelectedTask()?.taskColor ??
                        AppTheme.fhAccentTealFixed),
                    size: 22),
                const SizedBox(width: 10),
                Text(title,
                    style: theme.textTheme.headlineSmall
                        ?.copyWith(fontWeight: FontWeight.w600)),
              ],
            ),
            Divider(
                height: 24,
                thickness: 0.5,
                color: AppTheme.fhBorderColor.withOpacity(0.5)),
            ...children,
          ],
        ),
      ),
    );
  }
}
--- END OF FILE lib/src/widgets/views/settings_view.dart ---

--- START OF FILE lib/src/widgets/views/task_details_view.dart ---
// lib/src/widgets/views/task_details_view.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/utils/constants.dart';
import 'package:arcane/src/utils/helpers.dart' as helper;
import 'package:arcane/src/widgets/ui/rhombus_checkbox.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class TaskDetailsView extends StatefulWidget {
  const TaskDetailsView({super.key});

  @override
  State<TaskDetailsView> createState() => _TaskDetailsViewState();
}

class _TaskDetailsViewState extends State<TaskDetailsView> {
  // State for new subtask form
  final _newSubtaskNameController = TextEditingController();
  bool _newSubtaskIsCountable = false;
  final _newSubtaskTargetCountController = TextEditingController(text: '10');

  // State for AI subquest generation form
  String _aiGenerationMode = 'text_list'; // default mode
  final _aiUserInputController = TextEditingController();
  final _aiNumSubquestsController = TextEditingController(text: '3');

  // State for new sub-subtask forms (keyed by parent subtask ID)
  final Map<String, TextEditingController> _newSubSubtaskNameControllers = {};
  final Map<String, bool> _newSubSubtaskIsCountableMap = {};
  final Map<String, TextEditingController>
  _newSubSubtaskTargetCountControllers = {};

  // Local state for editing current time/count (keyed by subtask/sub-subtask ID)
  final Map<String, TextEditingController> _localTimeControllers = {};
  final Map<String, TextEditingController> _localCountControllers =
  {}; // For subtasks
  final Map<String, TextEditingController> _localSubSubtaskCountControllers =
  {}; // For sub-subtasks

  // State for managing editable time fields and their focus nodes
  final Map<String, bool> _isEditingTimeMap = {};
  final Map<String, FocusNode> _timeFocusNodes = {};


  late GameProvider gameProvider;
  MainTask? _currentTaskForInit;

  @override
  void initState() {
    super.initState();
    gameProvider = Provider.of<GameProvider>(context, listen: false);
    _initializeControllersForTask(gameProvider.getSelectedTask());
    // Add listener to re-initialize controllers if selected task changes
    gameProvider.addListener(_handleProviderChange);
  }

  @override
  void dispose() {
    _newSubtaskNameController.dispose();
    _newSubtaskTargetCountController.dispose();
    _aiUserInputController.dispose();
    _aiNumSubquestsController.dispose();
    _clearDynamicControllers();
    gameProvider.removeListener(_handleProviderChange);
    super.dispose();
  }

  void _clearDynamicControllers() {
    for (var controller in _newSubSubtaskNameControllers.values) {
      controller.dispose();
    }
    _newSubSubtaskNameControllers.clear();
    for (var controller in _newSubSubtaskTargetCountControllers.values) {
      controller.dispose();
    }
    _newSubSubtaskTargetCountControllers.clear();
    for (var controller in _localTimeControllers.values) {
      controller.dispose();
    }
    _localTimeControllers.clear();
    for (var controller in _localCountControllers.values) {
      controller.dispose();
    }
    _localCountControllers.clear();
    for (var controller in _localSubSubtaskCountControllers.values) {
      controller.dispose();
    }
    _localSubSubtaskCountControllers.clear();
    _newSubSubtaskIsCountableMap.clear();
    _isEditingTimeMap.clear();
    for (var node in _timeFocusNodes.values) {
      node.dispose();
    }
    _timeFocusNodes.clear();
  }

  void _handleProviderChange() {
    final selectedTask = gameProvider.getSelectedTask();
    if (_currentTaskForInit?.id != selectedTask?.id) {
      if (mounted) {
        setState(() {
          // Ensure UI rebuilds if task changes leading to different controllers
          _initializeControllersForTask(selectedTask);
        });
      } else {
        _initializeControllersForTask(selectedTask);
      }
    } else {
      // If the same task is selected, but its data might have changed (e.g., timer stopped)
      // we might need to refresh controllers if not handled by individual item rebuilds.
      // This is mostly covered by the ListView.builder item updates,
      // but a full _initializeControllersForTask can be a fallback if specific updates are missed.
      // For now, the item builder update logic should suffice.
      if (mounted) setState(() {}); // Trigger rebuild to pick up latest provider data
    }
  }

  void _initializeControllersForTask(MainTask? task) {
    _clearDynamicControllers(); // Clear previous task's controllers
    _currentTaskForInit = task;

    if (task != null) {
      for (var st in task.subTasks) {
        _newSubSubtaskNameControllers[st.id] = TextEditingController();
        _newSubSubtaskIsCountableMap[st.id] = false;
        _newSubSubtaskTargetCountControllers[st.id] =
            TextEditingController(text: '5');
        _localTimeControllers[st.id] =
            TextEditingController(text: st.currentTimeSpent.toString());
        if (st.isCountable) {
          _localCountControllers[st.id] =
              TextEditingController(text: st.currentCount.toString());
        }
        _isEditingTimeMap[st.id] = false;
        _timeFocusNodes[st.id] = FocusNode();

        for (var sss in st.subSubTasks) {
          if (sss.isCountable) {
            _localSubSubtaskCountControllers[sss.id] =
                TextEditingController(text: sss.currentCount.toString());
          }
        }
      }
    }
  }

  void _handleAddSubtask(GameProvider gameProvider, MainTask task) {
    if (_newSubtaskNameController.text.trim().isNotEmpty) {
      final subtaskData = {
        'name': _newSubtaskNameController.text.trim(),
        'isCountable': _newSubtaskIsCountable,
        'targetCount': _newSubtaskIsCountable
            ? (int.tryParse(_newSubtaskTargetCountController.text) ?? 1)
            : 0,
      };
      final newSubtaskId = gameProvider.addSubtask(task.id, subtaskData);

      // Initialize controllers for the new subtask
      _newSubSubtaskNameControllers[newSubtaskId] = TextEditingController();
      _newSubSubtaskIsCountableMap[newSubtaskId] = false;
      _newSubSubtaskTargetCountControllers[newSubtaskId] =
          TextEditingController(text: '5');
      _localTimeControllers[newSubtaskId] = TextEditingController(text: '0');
      if (subtaskData['isCountable'] as bool) {
        _localCountControllers[newSubtaskId] = TextEditingController(text: '0');
      }
      _isEditingTimeMap[newSubtaskId] = false;
      _timeFocusNodes[newSubtaskId] = FocusNode();


      _newSubtaskNameController.clear();
      _newSubtaskIsCountable = false;
      _newSubtaskTargetCountController.text = '10';
      if (mounted) {
        setState(() {});
      }
    }
  }

  void _handleAddSubSubtask(
      GameProvider gameProvider, String mainTaskId, String parentSubtaskId) {
    final name = _newSubSubtaskNameControllers[parentSubtaskId]?.text.trim();
    if (name != null && name.isNotEmpty) {
      final subSubData = {
        'name': name,
        'isCountable': _newSubSubtaskIsCountableMap[parentSubtaskId] ?? false,
        'targetCount': (_newSubSubtaskIsCountableMap[parentSubtaskId] ?? false)
            ? (int.tryParse(
            _newSubSubtaskTargetCountControllers[parentSubtaskId]
                ?.text ??
                '1') ??
            1)
            : 0,
      };
      gameProvider.addSubSubtask(mainTaskId, parentSubtaskId, subSubData);
      _newSubSubtaskNameControllers[parentSubtaskId]?.clear();
      _newSubSubtaskIsCountableMap[parentSubtaskId] = false;
      _newSubSubtaskTargetCountControllers[parentSubtaskId]?.text = '5';
      if (mounted) {
        setState(() {});
      }
    }
  }

  void _handleTimeOrCountBlur(
      GameProvider gp, MainTask task, SubTask subTask, String fieldType) {
    if (fieldType == 'time') {
      final newTime =
          int.tryParse(_localTimeControllers[subTask.id]?.text ?? '0') ??
              subTask.currentTimeSpent;
      if (newTime != subTask.currentTimeSpent) {
        gp.updateSubtask(task.id, subTask.id, {'currentTimeSpent': newTime});
      }
    } else if (fieldType == 'count' && subTask.isCountable) {
      final newCount =
          int.tryParse(_localCountControllers[subTask.id]?.text ?? '0') ??
              subTask.currentCount;
      if (newCount != subTask.currentCount) {
        gp.updateSubtask(task.id, subTask.id,
            {'currentCount': newCount.clamp(0, subTask.targetCount)});
      }
    }
  }

  void _handleSubSubtaskCountBlur(GameProvider gp, MainTask task,
      SubTask parentSubTask, SubSubTask subSubTask) {
    if (subSubTask.isCountable) {
      final newCount = int.tryParse(
          _localSubSubtaskCountControllers[subSubTask.id]?.text ?? '0') ??
          subSubTask.currentCount;
      if (newCount != subSubTask.currentCount) {
        gp.updateSubSubtask(task.id, parentSubTask.id, subSubTask.id,
            {'currentCount': newCount.clamp(0, subSubTask.targetCount)});
      }
    }
  }

  void _handleCheckboxChange(GameProvider gp, MainTask task, SubTask subTask) {
    if (subTask.isCountable) {
      final currentCount =
          int.tryParse(_localCountControllers[subTask.id]?.text ?? '0') ??
              subTask.currentCount;
      if (currentCount < subTask.targetCount) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text(
                  'Please complete the target count (${subTask.targetCount}) before marking as done.'),
              backgroundColor: AppTheme.fhAccentRed),
        );
        return;
      }
    }
    gp.completeSubtask(task.id, subTask.id);
  }

  void _handleSubSubtaskCheckboxChange(GameProvider gp, MainTask task,
      SubTask parentSubTask, SubSubTask subSubTask) {
    if (subSubTask.isCountable) {
      final currentCount = int.tryParse(
          _localSubSubtaskCountControllers[subSubTask.id]?.text ?? '0') ??
          subSubTask.currentCount;
      if (currentCount < subSubTask.targetCount) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text(
                  'Please complete the target count (${subSubTask.targetCount}) for this step before marking as done.'),
              backgroundColor: AppTheme.fhAccentRed),
        );
        return;
      }
    }
    gp.completeSubSubtask(task.id, parentSubTask.id, subSubTask.id);
  }

  void _handleAiGenerateSubquests(GameProvider gameProvider, MainTask task) {
    if (_aiUserInputController.text.trim().isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
            content:
            Text("Please provide input for the AI to generate sub-quests."),
            backgroundColor: AppTheme.fhAccentOrange),
      );
      return;
    }
    gameProvider.triggerAISubquestGeneration(
        task,
        _aiGenerationMode,
        _aiUserInputController.text.trim(),
        int.tryParse(_aiNumSubquestsController.text) ?? 3);
    _aiUserInputController.clear(); // Clear after submission
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<GameProvider>(
      builder: (context, gameProviderConsumer, child) {
        final task = gameProviderConsumer.getSelectedTask();
        final theme = Theme.of(context);

        if (task == null) {
          return Center(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(MdiIcons.textBoxSearchOutline,
                        size: 56,
                        color: (gameProvider.getSelectedTask()?.taskColor ??
                            AppTheme.fhAccentTealFixed)),
                    const SizedBox(height: 16),
                    Text('Select a Quest',
                        style: theme.textTheme.displaySmall?.copyWith(
                            color: (gameProvider.getSelectedTask()?.taskColor ??
                                AppTheme.fhAccentTealFixed))),
                    const SizedBox(height: 8),
                    Text(
                      'Details of the selected quest will appear here.',
                      style: theme.textTheme.titleMedium
                          ?.copyWith(color: AppTheme.fhTextSecondary),
                      textAlign: TextAlign.center,
                    ),
                  ],
                ),
              ));
        }

        if (_currentTaskForInit?.id != task.id) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (mounted) {
              setState(() {
                _initializeControllersForTask(task);
              });
            }
          });
        }

        final timeProgressPercent = (task.dailyTimeSpent /
            dailyTaskGoalMinutes.toDouble() *
            100)
            .clamp(0.0, 100.0);
        Color timeProgressColor = (gameProvider.getSelectedTask()?.taskColor ??
            AppTheme.fhAccentTealFixed);
        if (task.dailyTimeSpent >= dailyTaskGoalMinutes * 3) {
          timeProgressColor = AppTheme.fhAccentPurple;
        } else if (task.dailyTimeSpent >= dailyTaskGoalMinutes * 2) {
          timeProgressColor = AppTheme.fhAccentTeal;
        } else if (task.dailyTimeSpent >= dailyTaskGoalMinutes) {
          timeProgressColor = AppTheme.fhAccentGreen;
        }

        final completedSubtasksCount =
            task.subTasks.where((st) => st.completed).length;
        final totalSubtasksCount = task.subTasks.length;
        final subtaskCompletionPercent = totalSubtasksCount > 0
            ? (completedSubtasksCount / totalSubtasksCount * 100)
            : 0.0;

        for (var st in task.subTasks) {
          _localTimeControllers.putIfAbsent(
              st.id,
                  () =>
                  TextEditingController(text: st.currentTimeSpent.toString()));
          if (st.isCountable) {
            _localCountControllers.putIfAbsent(st.id,
                    () => TextEditingController(text: st.currentCount.toString()));
          }
          _newSubSubtaskNameControllers.putIfAbsent(
              st.id, () => TextEditingController());
          _newSubSubtaskIsCountableMap.putIfAbsent(st.id, () => false);
          _newSubSubtaskTargetCountControllers.putIfAbsent(
              st.id, () => TextEditingController(text: '5'));

          _isEditingTimeMap.putIfAbsent(st.id, () => false);
          _timeFocusNodes.putIfAbsent(st.id, () => FocusNode());

          // Update time controller text if not editing and subtask data changed
          if (!(_isEditingTimeMap[st.id] ?? false)) {
            final timeController = _localTimeControllers[st.id];
            if (timeController != null && timeController.text != st.currentTimeSpent.toString()) {
              timeController.text = st.currentTimeSpent.toString();
            }
          }

          for (var sss in st.subSubTasks) {
            if (sss.isCountable) {
              _localSubSubtaskCountControllers.putIfAbsent(
                  sss.id,
                      () =>
                      TextEditingController(text: sss.currentCount.toString()));
            }
          }
        }

        return Padding(
          padding:
          const EdgeInsets.only(top: 0, bottom: 16, left: 10, right: 10),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Card(
                color: AppTheme.fhBgMedium,
                margin: const EdgeInsets.only(bottom: 16, left: 0, right: 0),
                elevation: 0,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(6.0),
                  side: BorderSide(
                      color: AppTheme.fhBorderColor.withOpacity(0.5), width: 1),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(12.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            '${task.theme.toUpperCase()} QUEST PROTOCOL',
                            style: theme.textTheme.labelMedium?.copyWith(
                                color: (gameProvider
                                    .getSelectedTask()
                                    ?.taskColor ??
                                    AppTheme.fhAccentTealFixed),
                                fontWeight: FontWeight.bold,
                                letterSpacing: 0.8),
                          ),
                          Container(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 8, vertical: 3),
                            decoration: BoxDecoration(
                                color: task.dailyTimeSpent >=
                                    dailyTaskGoalMinutes
                                    ? AppTheme.fhAccentGreen.withOpacity(0.2)
                                    : AppTheme.fhAccentOrange.withOpacity(0.2),
                                borderRadius: BorderRadius.circular(4),
                                border: Border.all(
                                    color: task.dailyTimeSpent >=
                                        dailyTaskGoalMinutes
                                        ? AppTheme.fhAccentGreen
                                        : AppTheme.fhAccentOrange,
                                    width: 0.5)),
                            child: Text(
                              task.dailyTimeSpent >= dailyTaskGoalMinutes
                                  ? "OBJECTIVE MET"
                                  : (task.dailyTimeSpent > 0
                                  ? "ACTIVE"
                                  : "PENDING"),
                              style: theme.textTheme.labelSmall?.copyWith(
                                color:
                                task.dailyTimeSpent >= dailyTaskGoalMinutes
                                    ? AppTheme.fhAccentGreen
                                    : AppTheme.fhAccentOrange,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 6),
                      Text(task.name,
                          style: theme
                              .textTheme.headlineSmall
                              ?.copyWith(
                              color: AppTheme.fhTextPrimary,
                              fontWeight: FontWeight.w600)),
                      const SizedBox(height: 8),
                      Text(task.description,
                          style: theme.textTheme.bodyMedium?.copyWith(
                              color: AppTheme.fhTextSecondary,
                              fontSize: 13,
                              height: 1.5)),
                      const SizedBox(height: 16),
                      Card(
                        color: AppTheme.fhBgDark.withOpacity(0.7),
                        elevation: 0,
                        child: Padding(
                          padding: const EdgeInsets.all(12.0),
                          child: Column(
                            children: [
                              Row(
                                children: [
                                  Container(
                                    padding: const EdgeInsets.all(8),
                                    decoration: BoxDecoration(
                                      border: Border.all(
                                          color: (gameProvider
                                              .getSelectedTask()
                                              ?.taskColor ??
                                              AppTheme.fhAccentTealFixed)
                                              .withOpacity(0.7),
                                          width: 1.5),
                                      borderRadius: BorderRadius.circular(4),
                                    ),
                                    child: Text(
                                      gameProviderConsumer.romanize(
                                          task.streak > 0 ? task.streak : 1),
                                      style: theme.textTheme.titleLarge
                                          ?.copyWith(
                                          color: (gameProvider
                                              .getSelectedTask()
                                              ?.taskColor ??
                                              AppTheme.fhAccentTealFixed),
                                          fontWeight: FontWeight.bold),
                                    ),
                                  ),
                                  const SizedBox(width: 16),
                                  Expanded(
                                    child: Column(
                                      crossAxisAlignment:
                                      CrossAxisAlignment.start,
                                      children: [
                                        Text('CURRENT STREAK: ${task.streak}',
                                            style: theme.textTheme.labelMedium
                                                ?.copyWith(
                                                color:
                                                AppTheme.fhAccentGreen,
                                                fontWeight:
                                                FontWeight.bold)),
                                        const SizedBox(height: 2),
                                        Text(
                                            'TIME LOGGED (TODAY): ${task.dailyTimeSpent}m / ${dailyTaskGoalMinutes}m Goal',
                                            style: theme.textTheme.bodySmall
                                                ?.copyWith(
                                                fontSize: 11,
                                                color: AppTheme
                                                    .fhTextSecondary)),
                                        const SizedBox(height: 6),
                                        SizedBox(
                                            height: 8,
                                            child: ClipRRect(
                                                borderRadius:
                                                BorderRadius.circular(4),
                                                child: LinearProgressIndicator(
                                                    value: timeProgressPercent /
                                                        100,
                                                    backgroundColor: AppTheme
                                                        .fhBorderColor
                                                        .withOpacity(0.3),
                                                    valueColor:
                                                    AlwaysStoppedAnimation<
                                                        Color>(
                                                        timeProgressColor)))),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                              if (totalSubtasksCount > 0) ...[
                                const SizedBox(height: 12),
                                Divider(
                                    color:
                                    AppTheme.fhBorderColor.withOpacity(0.3),
                                    height: 1),
                                const SizedBox(height: 10),
                                Text('SUB-QUESTS TRACKING:',
                                    style: theme.textTheme.labelMedium
                                        ?.copyWith(
                                        color: AppTheme.fhTextSecondary,
                                        fontWeight: FontWeight.bold)),
                                const SizedBox(height: 6),
                                SizedBox(
                                    height: 8,
                                    child: ClipRRect(
                                        borderRadius: BorderRadius.circular(4),
                                        child: LinearProgressIndicator(
                                            value:
                                            subtaskCompletionPercent / 100,
                                            backgroundColor: AppTheme
                                                .fhBorderColor
                                                .withOpacity(0.3),
                                            valueColor:
                                            const AlwaysStoppedAnimation<
                                                Color>(
                                                AppTheme.fhAccentPurple)))),
                                const SizedBox(height: 4),
                                Align(
                                    alignment: Alignment.centerRight,
                                    child: Text(
                                        '$completedSubtasksCount / $totalSubtasksCount modules completed',
                                        style: theme.textTheme.labelSmall
                                            ?.copyWith(
                                            fontSize: 10,
                                            color:
                                            AppTheme.fhTextSecondary))),
                              ]
                            ],
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
              Padding(
                padding:
                const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),
                child: Text('Sub-Quests Log',
                    style: theme.textTheme.titleLarge?.copyWith(
                        fontFamily: AppTheme.fontDisplay,
                        color: AppTheme.fhTextPrimary,
                        fontWeight: FontWeight.w600)),
              ),
              if (task.subTasks.isEmpty)
                Padding(
                  padding: const EdgeInsets.all(24.0),
                  child: Center(
                      child: Text(
                          'No sub-quests recorded yet. Add some below or use AI generation.',
                          textAlign: TextAlign.center,
                          style: theme.textTheme.bodyLarge?.copyWith(
                              color: AppTheme.fhTextSecondary.withOpacity(0.8),
                              fontStyle: FontStyle.italic))),
                )
              else
                ListView.builder(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  itemCount: task.subTasks.length,
                  itemBuilder: (ctx, index) {
                    final st = task.subTasks[index];
                    // Controller availability is ensured by the loop above build method + _initializeControllersForTask

                    final timerState = gameProviderConsumer.activeTimers[st.id];
                    final displayTimeSeconds = timerState != null
                        ? (timerState.isRunning
                        ? timerState.accumulatedDisplayTime +
                        (DateTime.now()
                            .difference(timerState.startTime)
                            .inMilliseconds /
                            1000)
                        : timerState.accumulatedDisplayTime)
                        : st.currentTimeSpent * 60.0;

                    final completedSubSubTasks =
                        st.subSubTasks.where((sss) => sss.completed).length;
                    final totalSubSubTasks = st.subSubTasks.length;
                    final subSubTaskProgress = totalSubSubTasks > 0
                        ? (completedSubSubTasks / totalSubSubTasks * 100)
                        : 0.0;

                    return Card(
                      key: ValueKey(st.id),
                      margin:
                      const EdgeInsets.only(bottom: 12, left: 0, right: 0),
                      color: AppTheme.fhBgLight,
                      elevation: 0,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(4.0),
                        side: BorderSide(
                            color: AppTheme.fhBorderColor.withOpacity(0.5),
                            width: 0.5),
                      ),
                      child: Padding(
                        padding: const EdgeInsets.all(12.0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Row(
                              children: [
                                RhombusCheckbox(
                                  checked: st.completed,
                                  onChanged: st.completed
                                      ? null
                                      : (bool? value) => _handleCheckboxChange(
                                      gameProviderConsumer, task, st),
                                  disabled: st.completed,
                                ),
                                const SizedBox(width: 10),
                                Expanded(
                                    child: Text(st.name,
                                        style: theme.textTheme
                                            .titleMedium
                                            ?.copyWith(
                                            decoration: st.completed
                                                ? TextDecoration.lineThrough
                                                : TextDecoration.none,
                                            color: st.completed
                                                ? AppTheme.fhTextSecondary
                                                .withOpacity(0.7)
                                                : AppTheme.fhTextPrimary,
                                            fontWeight: st.completed
                                                ? FontWeight.normal
                                                : FontWeight.w600))),
                                if (!st.completed)
                                  IconButton(
                                    icon: Icon(
                                        MdiIcons.deleteForeverOutline,
                                        color: AppTheme.fhAccentRed
                                            .withOpacity(0.8),
                                        size: 20),
                                    onPressed: () => gameProviderConsumer
                                        .deleteSubtask(task.id, st.id),
                                    tooltip: 'Delete Sub-Quest',
                                    padding: EdgeInsets.zero,
                                    constraints: const BoxConstraints(),
                                    visualDensity: VisualDensity.compact,
                                  ),
                              ],
                            ),
                            if (!st.completed) ...[
                              const SizedBox(height: 10),
                              Divider(
                                  color:
                                  AppTheme.fhBorderColor.withOpacity(0.3)),
                              Padding(
                                padding: const EdgeInsets.only(
                                    left: 30.0, top: 8.0),
                                child: Column(
                                  children: [
                                    if (st.isCountable)
                                      _buildProgressRow(
                                        theme,
                                        label: 'Progress:',
                                        controller:
                                        _localCountControllers[st.id]!,
                                        currentValue: st.currentCount,
                                        targetValue: st.targetCount,
                                        progressColor: (gameProvider
                                            .getSelectedTask()
                                            ?.taskColor ??
                                            AppTheme.fhAccentTealFixed),
                                        onBlur: () => _handleTimeOrCountBlur(
                                            gameProviderConsumer,
                                            task,
                                            st,
                                            'count'),
                                      ),
                                    const SizedBox(height: 6),
                                    _buildTimerRow(
                                      theme,
                                      subtaskId: st.id, // Pass subtask ID
                                      label: 'Time (m):',
                                      controller: _localTimeControllers[st.id]!,
                                      focusNode: _timeFocusNodes[st.id]!,
                                      timerState: timerState,
                                      displayTimeSeconds: displayTimeSeconds,
                                      onPlayPause: () {
                                        // If editing time, save before toggling timer
                                        if (_isEditingTimeMap[st.id] ?? false) {
                                          _handleTimeOrCountBlur(gameProviderConsumer, task, st, 'time');
                                          if (mounted) {
                                            setState(() {
                                              _isEditingTimeMap[st.id] = false;
                                            });
                                          }
                                        }
                                        // Original play/pause logic
                                        if (timerState?.isRunning ?? false) {
                                          gameProviderConsumer.pauseTimer(st.id);
                                          gameProviderConsumer.logTimerAndReset(st.id);
                                        } else {
                                          gameProviderConsumer.startTimer(st.id, 'subtask', task.id);
                                        }
                                      },
                                      onEditToggle: () { // For edit/save icon
                                        setState(() {
                                          bool isCurrentlyEditing = _isEditingTimeMap[st.id] ?? false;
                                          if (isCurrentlyEditing) {
                                            _handleTimeOrCountBlur(gameProviderConsumer, task, st, 'time');
                                            _isEditingTimeMap[st.id] = false;
                                          } else {
                                            _isEditingTimeMap[st.id] = true;
                                            WidgetsBinding.instance.addPostFrameCallback((_) {
                                              _timeFocusNodes[st.id]?.requestFocus();
                                            });
                                          }
                                        });
                                      },
                                      onBlur: () { // For TextField's onEditingComplete/onTapOutside
                                        _handleTimeOrCountBlur(gameProviderConsumer, task, st, 'time');
                                        if (mounted && (_isEditingTimeMap[st.id] ?? false)) {
                                          setState(() {
                                            _isEditingTimeMap[st.id] = false;
                                          });
                                        }
                                      },
                                    ),
                                    const SizedBox(height: 12),
                                    if (st.subSubTasks.isNotEmpty) ...[
                                      _buildSubSubTaskList(
                                          theme,
                                          gameProviderConsumer,
                                          task,
                                          st,
                                          subSubTaskProgress),
                                    ],
                                    const SizedBox(height: 8),
                                    _buildAddSubSubTaskForm(
                                        theme, gameProviderConsumer, task, st),
                                  ],
                                ),
                              ),
                            ],
                            if (st.completed)
                              Padding(
                                padding:
                                const EdgeInsets.only(left: 30.0, top: 8.0),
                                child: Row(
                                  mainAxisAlignment:
                                  MainAxisAlignment.spaceBetween,
                                  children: [
                                    Text(
                                        'Completed: ${st.completedDate} - Logged: ${st.currentTimeSpent}m',
                                        style: theme.textTheme.labelSmall
                                            ?.copyWith(
                                            color: AppTheme.fhAccentGreen
                                                .withOpacity(0.8),
                                            fontSize: 10)),
                                    Wrap(
                                      spacing: 10,
                                      children: [
                                        IconButton(
                                            icon: Icon(MdiIcons.repeatVariant,
                                                size: 18,
                                                color: (gameProvider
                                                    .getSelectedTask()
                                                    ?.taskColor ??
                                                    AppTheme.fhAccentTealFixed)
                                                    .withOpacity(0.8)),
                                            onPressed: () =>
                                                gameProviderConsumer
                                                    .duplicateCompletedSubtask(
                                                    task.id, st.id),
                                            visualDensity:
                                            VisualDensity.compact,
                                            padding: EdgeInsets.zero,
                                            constraints: const BoxConstraints(
                                                maxWidth: 30, maxHeight: 24)),
                                        IconButton(
                                            icon: Icon(MdiIcons.deleteOutline,
                                                size: 18,
                                                color: AppTheme.fhAccentRed),
                                            onPressed: () =>
                                                gameProviderConsumer
                                                    .deleteSubtask(
                                                    task.id, st.id),
                                            visualDensity:
                                            VisualDensity.compact,
                                            padding: EdgeInsets.zero,
                                            constraints: const BoxConstraints(
                                                maxWidth: 30, maxHeight: 24)),
                                      ],
                                    ),
                                  ],
                                ),
                              ),
                          ],
                        ),
                      ),
                    );
                  },
                ),
              _buildAddNewSubQuestCard(theme, gameProviderConsumer, task),
              _buildAISubQuestCard(theme, gameProviderConsumer, task),
            ],
          ),
        );
      },
    );
  }

  Widget _buildProgressRow(
      ThemeData theme, {
        required String label,
        required TextEditingController controller,
        required int currentValue,
        required int targetValue,
        required Color progressColor,
        required VoidCallback onBlur,
      }) {
    return Row(
      children: [
        SizedBox(
            width: 70,
            child: Text(label,
                style: theme.textTheme.bodySmall
                    ?.copyWith(fontSize: 11, color: AppTheme.fhTextSecondary))),
        SizedBox(
          width: 40,
          height: 28,
          child: TextField(
            controller: controller,
            keyboardType: TextInputType.number,
            textAlign: TextAlign.center,
            style: theme.textTheme.bodyMedium
                ?.copyWith(fontSize: 12, color: AppTheme.fhTextPrimary),
            decoration: const InputDecoration(
                contentPadding: EdgeInsets.symmetric(vertical: 2),
                border: InputBorder.none,
                filled: false),
            onEditingComplete: onBlur,
            onTapOutside: (_) => onBlur(),
          ),
        ),
        Text(' / $targetValue',
            style: theme.textTheme.bodySmall
                ?.copyWith(fontSize: 11, color: AppTheme.fhTextSecondary)),
        const SizedBox(width: 10),
        Expanded(
          child: SizedBox(
            height: 6,
            child: ClipRRect(
              borderRadius: BorderRadius.circular(3),
              child: LinearProgressIndicator(
                value: targetValue > 0 ? (currentValue / targetValue) : 0,
                backgroundColor: AppTheme.fhBorderColor.withOpacity(0.3),
                valueColor: AlwaysStoppedAnimation<Color>(progressColor),
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildTimerRow(
      ThemeData theme, {
        required String subtaskId,
        required String label,
        required TextEditingController controller,
        required FocusNode focusNode,
        required ActiveTimerInfo? timerState,
        required double displayTimeSeconds,
        required VoidCallback onPlayPause,
        required VoidCallback onEditToggle, // Callback for the edit/save icon
        required VoidCallback onBlur,       // Callback for TextField focus loss/completion
      }) {
    bool isEditing = _isEditingTimeMap[subtaskId] ?? false;

    return Row(
      children: [
        SizedBox(
            width: 60, // Adjusted width
            child: Text(label,
                style: theme.textTheme.bodySmall
                    ?.copyWith(fontSize: 11, color: AppTheme.fhTextSecondary))),
        SizedBox(
          width: 40,
          height: null,
          child: TextField(
            controller: controller,
            focusNode: focusNode,
            keyboardType: TextInputType.number,
            textAlign: TextAlign.center,
            readOnly: !isEditing,
            style: theme.textTheme.bodyMedium
                ?.copyWith(fontSize: 12, color: AppTheme.fhTextPrimary),
            decoration: InputDecoration(
              contentPadding: const EdgeInsets.symmetric(vertical: 2),
              border: InputBorder.none, // Clean look when read-only
              enabledBorder: isEditing
                  ? OutlineInputBorder(borderSide: BorderSide(color: theme.focusColor.withOpacity(0.5)))
                  : InputBorder.none,
              focusedBorder: isEditing
                  ? OutlineInputBorder(borderSide: BorderSide(color: theme.primaryColor))
                  : InputBorder.none,
              filled: false,
            ),
            onEditingComplete: onBlur, // Saves and sets isEditing to false
            onTapOutside: (_) => onBlur(), // Saves and sets isEditing to false
          ),
        ),
        IconButton(
          icon: Icon(
            isEditing ? MdiIcons.check : MdiIcons.pencilOutline,
            color: isEditing ? AppTheme.fhAccentGreen : AppTheme.fhTextSecondary.withOpacity(0.7),
            size: 18,
          ),
          onPressed: onEditToggle,
          padding: const EdgeInsets.symmetric(horizontal: 4),
          visualDensity: VisualDensity.compact,
          constraints: const BoxConstraints(),
        ),
        const Spacer(),
        IconButton(
          icon: Icon(
            timerState?.isRunning ?? false
                ? MdiIcons.pauseCircleOutline
                : MdiIcons.playCircleOutline,
            color: timerState?.isRunning ?? false
                ? AppTheme.fhAccentOrange
                : AppTheme.fhAccentGreen,
            size: 22,
          ),
          onPressed: onPlayPause,
          padding: EdgeInsets.zero,
          visualDensity: VisualDensity.compact,
        ),
        const SizedBox(width: 4),
        SizedBox(
          width: 45, // Give timer text some space
          child: Text(
            helper.formatTime(displayTimeSeconds),
            style: theme.textTheme.labelSmall?.copyWith(
                color: (gameProvider.getSelectedTask()?.taskColor ??
                    AppTheme.fhAccentTealFixed),
                fontSize: 11,
                fontWeight: FontWeight.w600),
            textAlign: TextAlign.right,
          ),
        ),
      ],
    );
  }

  Widget _buildSubSubTaskList(
      ThemeData theme,
      GameProvider gameProviderConsumer,
      MainTask task,
      SubTask st,
      double subSubTaskProgress) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text('Checkpoints:',
                style: theme.textTheme.bodySmall?.copyWith(
                    color: AppTheme.fhTextSecondary.withOpacity(0.8),
                    fontSize: 11,
                    fontWeight: FontWeight.w600)),
            const SizedBox(width: 8),
            Expanded(
              child: SizedBox(
                height: 4,
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(2),
                  child: LinearProgressIndicator(
                    value: subSubTaskProgress / 100,
                    backgroundColor: AppTheme.fhBorderColor.withOpacity(0.3),
                    valueColor: const AlwaysStoppedAnimation<Color>(
                        AppTheme.fhAccentPurple),
                  ),
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: 6),
        ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: st.subSubTasks.length,
            itemBuilder: (sctx, sIndex) {
              final sss = st.subSubTasks[sIndex];
              return Padding(
                padding: const EdgeInsets.only(
                    bottom: 4.0, left: 8.0),
                child: Row(
                  children: [
                    SizedBox(
                        width: 20,
                        height: 20,
                        child: RhombusCheckbox(
                          checked: sss.completed,
                          onChanged: sss.completed
                              ? null
                              : (bool? val) => _handleSubSubtaskCheckboxChange(
                              gameProviderConsumer, task, st, sss),
                          disabled: sss.completed,
                          size: CheckboxSize.small,
                        )),
                    const SizedBox(width: 8),
                    Expanded(
                        child: Text(
                            '${sss.name}${sss.isCountable && !sss.completed ? ' (${_localSubSubtaskCountControllers[sss.id]?.text ?? sss.currentCount}/${sss.targetCount})' : (sss.isCountable && sss.completed ? ' (${sss.currentCount}/${sss.targetCount})' : '')}',
                            style: theme.textTheme.bodySmall?.copyWith(
                              fontSize: 11,
                              decoration: sss.completed
                                  ? TextDecoration.lineThrough
                                  : TextDecoration.none,
                              color: sss.completed
                                  ? AppTheme.fhTextSecondary.withOpacity(0.6)
                                  : AppTheme.fhTextSecondary,
                            ))),
                    if (sss.isCountable && !sss.completed)
                      SizedBox(
                        width: 35,
                        height: 22,
                        child: TextField(
                          controller: _localSubSubtaskCountControllers[sss.id],
                          keyboardType: TextInputType.number,
                          textAlign: TextAlign.center,
                          style: theme.textTheme.labelSmall?.copyWith(
                              fontSize: 10, color: AppTheme.fhTextPrimary),
                          decoration: const InputDecoration(
                              contentPadding: EdgeInsets.symmetric(vertical: 1),
                              border: InputBorder.none,
                              filled: false),
                          onEditingComplete: () => _handleSubSubtaskCountBlur(
                              gameProviderConsumer, task, st, sss),
                          onTapOutside: (_) => _handleSubSubtaskCountBlur(
                              gameProviderConsumer, task, st, sss),
                        ),
                      ),
                    if (!sss.completed)
                      IconButton(
                          icon: Icon(MdiIcons.deleteOutline,
                              color: AppTheme.fhAccentRed.withOpacity(0.7),
                              size: 16),
                          visualDensity: VisualDensity.compact,
                          padding: EdgeInsets.zero,
                          constraints: const BoxConstraints(),
                          onPressed: () => gameProviderConsumer
                              .deleteSubSubtask(task.id, st.id, sss.id)),
                  ],
                ),
              );
            }),
      ],
    );
  }

  Widget _buildAddSubSubTaskForm(ThemeData theme,
      GameProvider gameProviderConsumer, MainTask task, SubTask st) {
    return Padding(
      padding: const EdgeInsets.only(top: 4.0, left: 8.0),
      child: Row(
        children: [
          Expanded(
              child: SizedBox(
                  height: 36,
                  child: TextField(
                    controller: _newSubSubtaskNameControllers[st.id],
                    decoration: const InputDecoration(
                        hintText: 'Add a checkpoint...',
                        contentPadding:
                        EdgeInsets.symmetric(horizontal: 8, vertical: 4)),
                    style: theme.textTheme.bodySmall
                        ?.copyWith(fontSize: 11, color: AppTheme.fhTextPrimary),
                  ))),
          Transform.scale(
            scale: 0.7,
            child: Switch(
              value: _newSubSubtaskIsCountableMap[st.id] ?? false,
              onChanged: (val) =>
                  setState(() => _newSubSubtaskIsCountableMap[st.id] = val),
              activeColor: (gameProvider.getSelectedTask()?.taskColor ??
                  AppTheme.fhAccentTealFixed),
              materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
            ),
          ),
          if (_newSubSubtaskIsCountableMap[st.id] ?? false)
            SizedBox(
                width: 35,
                height:  null, // Auto height based on content
                child: TextField(
                  controller: _newSubSubtaskTargetCountControllers[st.id],
                  keyboardType: TextInputType.number,
                  textAlign: TextAlign.center,
                  decoration: const InputDecoration(
                    contentPadding: EdgeInsets.symmetric(vertical: 4),
                    border: InputBorder.none, // Remove underline
                  ),
                  style: theme.textTheme.bodySmall
                      ?.copyWith(fontSize: 11, color: AppTheme.fhTextPrimary),
                )),
          IconButton(
            icon: Icon(MdiIcons.plusCircleOutline,
                color: AppTheme.fhAccentGreen, size: 22),
            onPressed: () =>
                _handleAddSubSubtask(gameProviderConsumer, task.id, st.id),
            visualDensity: VisualDensity.compact,
            padding: const EdgeInsets.only(left: 4),
            constraints: const BoxConstraints(),
          ),
        ],
      ),
    );
  }

  Widget _buildAddNewSubQuestCard(
      ThemeData theme, GameProvider gameProviderConsumer, MainTask task) {
    return Card(
      color: AppTheme.fhBgMedium,
      margin: const EdgeInsets.only(top: 20, left: 0, right: 0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(6),
        side: BorderSide(
            color: AppTheme.fhBorderColor.withOpacity(0.8), width: 1),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Add New Sub-Quest (Manually)',
                style: theme.textTheme.titleMedium?.copyWith(
                    fontFamily: AppTheme.fontDisplay,
                    color: AppTheme.fhTextPrimary,
                    fontWeight: FontWeight.w600)),
            const SizedBox(height: 12),
            TextField(
              controller: _newSubtaskNameController,
              decoration:
              const InputDecoration(hintText: 'Sub-quest objective...'),
              style: theme.textTheme.bodyMedium
                  ?.copyWith(fontSize: 14, color: AppTheme.fhTextPrimary),
            ),
            const SizedBox(height: 10),
            Row(
              children: [
                Checkbox(
                  value: _newSubtaskIsCountable,
                  onChanged: (val) =>
                      setState(() => _newSubtaskIsCountable = val ?? false),
                  activeColor: (gameProvider.getSelectedTask()?.taskColor ??
                      AppTheme.fhAccentTealFixed),
                  checkColor: AppTheme.fhBgDark,
                  visualDensity: VisualDensity.compact,
                  side: BorderSide(
                      color: (gameProvider.getSelectedTask()?.taskColor ??
                          AppTheme.fhAccentTealFixed)
                          .withOpacity(0.7),
                      width: 1.5),
                ),
                const Text('Is it countable?',
                    style: TextStyle(
                        color: AppTheme.fhTextSecondary,
                        fontSize: 13,
                        fontFamily: AppTheme.fontBody)),
                const SizedBox(width: 12),
                if (_newSubtaskIsCountable)
                  Expanded(
                    child: TextField(
                      controller: _newSubtaskTargetCountController,
                      decoration: const InputDecoration(
                          labelText: 'Target #',
                          contentPadding:
                          EdgeInsets.symmetric(horizontal: 8, vertical: 6)),
                      keyboardType: TextInputType.number,
                      style: const TextStyle(
                          fontSize: 13,
                          fontFamily: AppTheme.fontBody,
                          color: AppTheme.fhTextPrimary),
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 16),
            ElevatedButton.icon(
              icon: Icon(MdiIcons.plusBoxOutline, size: 18),
              label: const Text('ADD SUB-QUEST'),
              onPressed: () => _handleAddSubtask(gameProviderConsumer, task),
              style: ElevatedButton.styleFrom(
                  minimumSize: const Size(double.infinity, 40)),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAISubQuestCard(
      ThemeData theme, GameProvider gameProviderConsumer, MainTask task) {
    return Card(
      color: AppTheme.fhBgMedium,
      margin: const EdgeInsets.only(top: 16, left: 0, right: 0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(6),
        side: BorderSide(
            color: AppTheme.fhAccentPurple.withOpacity(0.5),
            width: 1),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(MdiIcons.robotHappyOutline,
                    color: AppTheme.fhAccentPurple, size: 20),
                const SizedBox(width: 8),
                Text('Generate Sub-Quests with AI',
                    style: theme.textTheme.titleMedium?.copyWith(
                        fontFamily: AppTheme.fontDisplay,
                        color: AppTheme.fhTextPrimary,
                        fontWeight: FontWeight.w600)),
              ],
            ),
            const SizedBox(height: 12),
            DropdownButtonFormField<String>(
              decoration: const InputDecoration(
                  labelText: 'Generation Mode',
                  labelStyle:
                  TextStyle(fontSize: 13, fontFamily: AppTheme.fontBody)),
              dropdownColor: AppTheme.fhBgLight,
              value: _aiGenerationMode,
              style: theme.textTheme.bodyMedium
                  ?.copyWith(fontSize: 14, color: AppTheme.fhTextPrimary),
              items: const [
                DropdownMenuItem(
                    value: 'text_list',
                    child: Text('From Text List / Outline')),
                DropdownMenuItem(
                    value: 'book_chapter',
                    child: Text('From Book Chapter/Section')),
                DropdownMenuItem(
                    value: 'general_plan',
                    child: Text('From General Plan/Goal')),
              ],
              onChanged: (value) {
                if (value != null) {
                  setState(() => _aiGenerationMode = value);
                }
              },
            ),
            const SizedBox(height: 12),
            TextField(
              controller: _aiUserInputController,
              decoration: const InputDecoration(
                labelText: 'Your Input for AI...',
                alignLabelWithHint: true,
                labelStyle:
                TextStyle(fontSize: 13, fontFamily: AppTheme.fontBody),
              ),
              maxLines: null,
              minLines: 2,
              style: theme.textTheme.bodyMedium
                  ?.copyWith(fontSize: 14, color: AppTheme.fhTextPrimary),
            ),
            const SizedBox(height: 12),
            TextField(
              controller: _aiNumSubquestsController,
              decoration: const InputDecoration(
                  labelText: 'Approx. # Sub-Quests',
                  labelStyle:
                  TextStyle(fontSize: 13, fontFamily: AppTheme.fontBody)),
              keyboardType: TextInputType.number,
              style: theme.textTheme.bodyMedium
                  ?.copyWith(fontSize: 14, color: AppTheme.fhTextPrimary),
            ),
            const SizedBox(height: 16),
            ElevatedButton.icon(
              icon: gameProviderConsumer.isGeneratingSubquests
                  ? const SizedBox(
                  width: 18,
                  height: 18,
                  child: CircularProgressIndicator(
                      strokeWidth: 2, color: AppTheme.fhBgDark))
                  : Icon(MdiIcons.creationOutline, size: 18),
              label: Text(gameProviderConsumer.isGeneratingSubquests
                  ? 'GENERATING...'
                  : 'INITIATE AI PROTOCOL'),
              onPressed: gameProviderConsumer.isGeneratingSubquests
                  ? null
                  : () =>
                  _handleAiGenerateSubquests(gameProviderConsumer, task),
              style: ElevatedButton.styleFrom(
                  backgroundColor: AppTheme.fhAccentPurple,
                  foregroundColor: AppTheme.fhTextPrimary,
                  disabledBackgroundColor: AppTheme.fhBgLight.withOpacity(0.5),
                  minimumSize: const Size(double.infinity, 40)),
            ),
          ],
        ),
      ),
    );
  }
}
--- END OF FILE lib/src/widgets/views/task_details_view.dart ---

--- START OF FILE test/mock.dart ---

import 'package:firebase_core_platform_interface/firebase_core_platform_interface.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';

// Mock FirebaseAppPlatform
class MockFirebaseAppPlatform extends Mock implements FirebaseAppPlatform {
  @override
  String get name => 'mock'; // Or any other default you prefer
  @override
  FirebaseOptions get options => const FirebaseOptions(
        apiKey: 'mock_api_key',
        appId: 'mock_app_id',
        messagingSenderId: 'mock_sender_id',
        projectId: 'mock_project_id',
      );
}

// Mock FirebaseCorePlatform
class MockFirebaseCorePlatform extends Mock implements FirebasePlatform {
  @override
  Future<FirebaseAppPlatform> initializeApp({
    String? name,
    FirebaseOptions? options,
  }) async {
    return MockFirebaseAppPlatform();
  }

  @override
  List<FirebaseAppPlatform> get apps => [MockFirebaseAppPlatform()];

  @override
  FirebaseAppPlatform app([String name = defaultFirebaseAppName]) {
    return MockFirebaseAppPlatform();
  }
}


void setupFirebaseAuthMocks() {
  TestWidgetsFlutterBinding.ensureInitialized();

  // Mock FirebaseCorePlatform
  final mockCorePlatform = MockFirebaseCorePlatform();
  FirebasePlatform.instance = mockCorePlatform;
  
  // Mock FirebaseAppPlatform (used by Firebase.initializeApp)
  // This part might be tricky as Firebase.initializeApp directly calls native code.
  // For simple unit/widget tests not deeply testing Firebase,
  // ensuring Firebase.initializeApp doesn't throw is often enough.
  // The above mockCorePlatform should handle the Firebase.app() calls.

  // If you are testing Firebase Auth, Firestore, etc., you'd also mock their respective platform interfaces
  // using packages like firebase_auth_mocks, cloud_firestore_mocks, or custom mocks.
}

--- END OF FILE test/mock.dart ---

--- START OF FILE test/widget_test.dart ---
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:arcane/src/app.dart'; // Changed import
import 'package:provider/provider.dart'; // Added for GameProvider
import 'package:arcane/src/providers/game_provider.dart'; // Added for GameProvider
import 'package:firebase_core/firebase_core.dart'; // Added for Firebase
import './mock.dart'; // For Firebase mock

void main() {
  // Mock Firebase core setup
  setupFirebaseAuthMocks();

  setUpAll(() async {
    await Firebase.initializeApp();
  });

  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    // Wrap with ChangeNotifierProvider for GameProvider
    await tester.pumpWidget(
      ChangeNotifierProvider(
        create: (context) => GameProvider(), // Provide a GameProvider instance
        child: const MyApp(),
      ),
    );

    // Due to the async nature of Firebase initialization and initial auth state loading,
    // we might need to pump a few times or use pumpAndSettle.
    // For this basic test, we'll assume the LoginScreen shows up first if no user.
    // Or, if a user is mocked/logged in, it might go to HomeScreen.
    // The original test looked for '0' and '1' which suggests a counter.
    // This app structure is different. Let's verify something basic from LoginScreen or HomeScreen.

    // If LoginScreen is expected (no user by default in GameProvider mock or fresh state)
    await tester.pumpAndSettle(); // Wait for UI to stabilize

    // Check if LoginScreen elements are present
    // This is a placeholder. Actual test would depend on GameProvider's initial state.
    // For now, let's assume we get to a state where a MaterialApp is built.
    expect(find.byType(MaterialApp), findsOneWidget);

    // The original test was for a counter app, this app is different.
    // This test needs to be adapted to the new app's functionality.
    // For now, a smoke test that the app builds is sufficient.
    // Example: Verify "TASK DOMINION" text from LoginScreen or HeaderWidget appears.
    // As GameProvider might show a loading spinner first, then LoginScreen.
    // final loginTitle = find.text('TASK DOMINION');
    // expect(loginTitle, findsOneWidget); // This might fail depending on initial loading state.
  });
}

--- END OF FILE test/widget_test.dart ---
