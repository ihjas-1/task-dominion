--- START OF FILE lib/src/models/game_models.dart ---
// lib/src/models/game_models.dart
// import 'package:arcane/src/utils/constants.dart'; // No longer needed here for constants
import 'package:collection/collection.dart'; // For firstWhereOrNull
import 'package:flutter/material.dart'; // For Color
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:arcane/src/theme/app_theme.dart'; // For MdiIcons

class MainTask {
  String id;
  String name;
  String description;
  String theme;
  String colorHex; // e.g., "FF64FFDA"
  int streak;
  int dailyTimeSpent;
  String? lastWorkedDate;
  List<SubTask> subTasks;

  MainTask({
    required this.id,
    required this.name,
    required this.description,
    required this.theme,
    this.colorHex = "FF00F8F8", // Default to a vibrant cyan
    this.streak = 0,
    this.dailyTimeSpent = 0,
    this.lastWorkedDate,
    List<SubTask>? subTasks,
  }) : subTasks = subTasks ?? [];

  // Factory from MainTaskTemplate (which is now in this file)
  factory MainTask.fromTemplate(MainTaskTemplate template) {
    return MainTask(
      id: template.id,
      name: template.name,
      description: template.description,
      theme: template.theme,
      colorHex: template.colorHex,
    );
  }

  factory MainTask.fromJson(Map<String, dynamic> json) {
    return MainTask(
      id: json['id'] as String,
      name: json['name'] as String,
      description: json['description'] as String,
      theme: json['theme'] as String,
      colorHex: json['colorHex'] as String? ?? "FF00F8F8",
      streak: json['streak'] as int? ?? 0,
      dailyTimeSpent: json['dailyTimeSpent'] as int? ?? 0,
      lastWorkedDate: json['lastWorkedDate'] as String?,
      subTasks: (json['subTasks'] as List<dynamic>?)
              ?.map(
                  (stJson) => SubTask.fromJson(stJson as Map<String, dynamic>))
              .toList() ??
          [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'theme': theme,
      'colorHex': colorHex,
      'streak': streak,
      'dailyTimeSpent': dailyTimeSpent,
      'lastWorkedDate': lastWorkedDate,
      'subTasks': subTasks.map((st) => st.toJson()).toList(),
    };
  }

  Color get taskColor {
    try {
      return Color(int.parse("0x$colorHex"));
    } catch (e) {
      return AppTheme.fhAccentTealFixed; // Fallback color
    }
  }
}

class SubTask {
  String id;
  String name;
  bool completed;
  int currentTimeSpent; // Storing as minutes
  String? completedDate;
  bool isCountable;
  int targetCount;
  int currentCount;
  List<SubSubTask> subSubTasks;

  SubTask({
    required this.id,
    required this.name,
    this.completed = false,
    this.currentTimeSpent = 0,
    this.completedDate,
    this.isCountable = false,
    this.targetCount = 0,
    this.currentCount = 0,
    List<SubSubTask>? subSubTasks,
  }) : subSubTasks = subSubTasks ?? [];

  factory SubTask.fromJson(Map<String, dynamic> json) {
    return SubTask(
      id: json['id'] as String,
      name: json['name'] as String,
      completed: json['completed'] as bool? ?? false,
      currentTimeSpent: json['currentTimeSpent'] as int? ?? 0,
      completedDate: json['completedDate'] as String?,
      isCountable: json['isCountable'] as bool? ?? false,
      targetCount: json['targetCount'] as int? ?? 0,
      currentCount: json['currentCount'] as int? ?? 0,
      subSubTasks: (json['subSubTasks'] as List<dynamic>?)
              ?.map((sssJson) =>
                  SubSubTask.fromJson(sssJson as Map<String, dynamic>))
              .toList() ??
          [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'completed': completed,
      'currentTimeSpent': currentTimeSpent,
      'completedDate': completedDate,
      'isCountable': isCountable,
      'targetCount': targetCount,
      'currentCount': currentCount,
      'subSubTasks': subSubTasks.map((sss) => sss.toJson()).toList(),
    };
  }
}

class SubSubTask {
  String id;
  String name;
  bool completed;
  bool isCountable;
  int targetCount;
  int currentCount;

  SubSubTask({
    required this.id,
    required this.name,
    this.completed = false,
    this.isCountable = false,
    this.targetCount = 0,
    this.currentCount = 0,
  });

  factory SubSubTask.fromJson(Map<String, dynamic> json) {
    return SubSubTask(
      id: json['id'] as String,
      name: json['name'] as String,
      completed: json['completed'] as bool? ?? false,
      isCountable: json['isCountable'] as bool? ?? false,
      targetCount: json['targetCount'] as int? ?? 0,
      currentCount: json['currentCount'] as int? ?? 0,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'completed': completed,
      'isCountable': isCountable,
      'targetCount': targetCount,
      'currentCount': currentCount,
    };
  }
}

class OwnedArtifact {
  String uniqueId;
  String templateId;
  int currentLevel;
  int? uses;

  OwnedArtifact({
    required this.uniqueId,
    required this.templateId,
    required this.currentLevel,
    this.uses,
  });

  factory OwnedArtifact.fromJson(Map<String, dynamic> json) {
    return OwnedArtifact(
      uniqueId: json['uniqueId'] as String,
      templateId: json['templateId'] as String,
      currentLevel: json['currentLevel'] as int,
      uses: json['uses'] as int?,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'uniqueId': uniqueId,
      'templateId': templateId,
      'currentLevel': currentLevel,
      'uses': uses,
    };
  }
}

class CurrentGame {
  EnemyTemplate? enemy;
  double playerCurrentHp;
  List<String> log;
  String? currentPlaceKey;

  CurrentGame({
    this.enemy,
    required this.playerCurrentHp,
    List<String>? log,
    this.currentPlaceKey,
  }) : log = log ?? [];

  factory CurrentGame.fromJson(
      Map<String, dynamic> json, List<EnemyTemplate> allEnemyTemplates) {
    EnemyTemplate? currentEnemy;
    if (json['enemy'] != null) {
      final enemyData = json['enemy'] as Map<String, dynamic>;
      currentEnemy =
          allEnemyTemplates.firstWhereOrNull((t) => t.id == enemyData['id']) ??
              EnemyTemplate.fromJson(enemyData);
    }
    return CurrentGame(
      enemy: currentEnemy,
      playerCurrentHp: (json['playerCurrentHp'] as num).toDouble(),
      log: (json['log'] as List<dynamic>?)
              ?.map((entry) => entry as String)
              .toList() ??
          [],
      currentPlaceKey: json['currentPlaceKey'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'enemy': enemy?.toJson(),
      'playerCurrentHp': playerCurrentHp,
      'log': log,
      'currentPlaceKey': currentPlaceKey,
    };
  }
}

class GameSettings {
  bool descriptionsVisible;
  bool dailyAutoGenerateContent; // Renamed from autoGenerateContent
  int wakeupTimeHour;
  int wakeupTimeMinute;


  GameSettings({
    this.descriptionsVisible = true,
    this.dailyAutoGenerateContent = true, // Renamed
    this.wakeupTimeHour = 7,
    this.wakeupTimeMinute = 0,
  });

  factory GameSettings.fromJson(Map<String, dynamic> json) {
    return GameSettings(
      descriptionsVisible: json['descriptionsVisible'] as bool? ?? true,
      dailyAutoGenerateContent: json['dailyAutoGenerateContent'] as bool? ?? json['autoGenerateContent'] as bool? ?? true, // Handle legacy name
      wakeupTimeHour: json['wakeupTimeHour'] as int? ?? 7,
      wakeupTimeMinute: json['wakeupTimeMinute'] as int? ?? 0,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'descriptionsVisible': descriptionsVisible,
      'dailyAutoGenerateContent': dailyAutoGenerateContent, // Renamed
      'wakeupTimeHour': wakeupTimeHour,
      'wakeupTimeMinute': wakeupTimeMinute,
    };
  }
}

class ActiveTimerInfo {
  DateTime startTime;
  double accumulatedDisplayTime; // In seconds
  bool isRunning;
  String type;
  String mainTaskId;

  ActiveTimerInfo({
    required this.startTime,
    this.accumulatedDisplayTime = 0,
    required this.isRunning,
    required this.type,
    required this.mainTaskId,
  });

  factory ActiveTimerInfo.fromJson(Map<String, dynamic> json) {
    return ActiveTimerInfo(
      startTime: DateTime.parse(json['startTime'] as String),
      accumulatedDisplayTime:
          (json['accumulatedDisplayTime'] as num? ?? 0).toDouble(),
      isRunning: json['isRunning'] as bool? ?? false,
      type: json['type'] as String? ?? 'subtask',
      mainTaskId: json['mainTaskId'] as String? ?? '',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'startTime': startTime.toIso8601String(),
      'accumulatedDisplayTime': accumulatedDisplayTime,
      'isRunning': isRunning,
      'type': type,
      'mainTaskId': mainTaskId,
    };
  }
}

class PlayerStat {
  final String name;
  final String description;
  final String icon; // Can be an emoji or an MDI icon name (e.g., "mdi-sword")
  double value;
  double base;

  PlayerStat({
    required this.name,
    required this.description,
    required this.icon,
    required this.value,
    required this.base,
  });

  factory PlayerStat.fromJson(Map<String, dynamic> json) {
    double parseNumToDouble(dynamic val, double defaultValue) {
      if (val == null) return defaultValue;
      if (val is num) return val.toDouble();
      if (val is String) return double.tryParse(val) ?? defaultValue;
      return defaultValue;
    }

    String parseString(dynamic val, String defaultValue) {
      if (val == null) return defaultValue;
      if (val is String) return val;
      return val.toString();
    }

    return PlayerStat(
      name: parseString(json['name'], 'Unknown Stat'),
      description: parseString(json['description'], 'No description.'),
      icon: parseString(
          json['icon'],
          MdiIcons.helpCircleOutline.codePoint
              .toString()), // Use MDI icon as string default
      value: parseNumToDouble(json['value'], 0.0),
      base: parseNumToDouble(json['base'], 0.0),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'description': description,
      'icon': icon,
      'value': value,
      'base': base,
    };
  }
}

class ArtifactTemplate {
  final String id;
  final String name;
  final String type;
  final String? theme;
  final String description;
  final int cost;
  final String icon; // Can be an emoji or an MDI icon name
  final int? baseAtt;
  final int? baseRunic;
  final int? baseDef;
  final int? baseHealth;
  final int? baseLuck;
  final int? baseCooldown;
  final double? bonusXPMod;
  final Map<String, int>? upgradeBonus;
  final int? maxLevel;
  final String? effectType;
  final int? effectValue;
  final int? uses;

  ArtifactTemplate({
    required this.id,
    required this.name,
    required this.type,
    this.theme,
    required this.description,
    required this.cost,
    required this.icon,
    this.baseAtt,
    this.baseRunic,
    this.baseDef,
    this.baseHealth,
    this.baseLuck,
    this.baseCooldown,
    this.bonusXPMod,
    this.upgradeBonus,
    this.maxLevel,
    this.effectType,
    this.effectValue,
    this.uses,
  });

  factory ArtifactTemplate.fromJson(Map<String, dynamic> json) {
    Map<String, int>? parsedUpgradeBonus;
    if (json['upgradeBonus'] != null && json['upgradeBonus'] is Map) {
      parsedUpgradeBonus = {};
      try {
        (json['upgradeBonus'] as Map<String, dynamic>).forEach((key, value) {
          if (value is num) {
            parsedUpgradeBonus![key] = value.toInt();
          } else if (value is String)
            parsedUpgradeBonus![key] = int.tryParse(value) ?? 0;
        });
      } catch (e) {/* ... */}
    }
    int? parseInt(dynamic val) {
      if (val == null) return null;
      if (val is int) return val;
      if (val is double) return val.toInt();
      if (val is String) return int.tryParse(val);
      return null;
    }

    double? parseDouble(dynamic val) {
      if (val == null) return null;
      if (val is double) return val;
      if (val is int) return val.toDouble();
      if (val is String) return double.tryParse(val);
      return null;
    }

    return ArtifactTemplate(
      id: json['id'] as String? ??
          'unknown_id_${DateTime.now().millisecondsSinceEpoch}',
      name: json['name'] as String? ?? 'Unknown Artifact',
      type: json['type'] as String? ?? 'unknown',
      theme: json['theme'] as String?,
      description: json['description'] as String? ?? 'No description.',
      cost: parseInt(json['cost']) ?? 0,
      icon: json['icon'] as String? ??
          MdiIcons.treasureChest.codePoint
              .toString(), // Default to MDI icon string
      baseAtt: parseInt(json['baseAtt']),
      baseRunic: parseInt(json['baseRunic']),
      baseDef: parseInt(json['baseDef']),
      baseHealth: parseInt(json['baseHealth']),
      baseLuck: parseInt(json['baseLuck']),
      baseCooldown: parseInt(json['baseCooldown']),
      bonusXPMod: parseDouble(json['bonusXPMod']),
      upgradeBonus: parsedUpgradeBonus,
      maxLevel: parseInt(json['maxLevel']),
      effectType: json['effectType'] as String?,
      effectValue: parseInt(json['effectValue']),
      uses: parseInt(json['uses']),
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'type': type,
      'theme': theme,
      'description': description,
      'cost': cost,
      'icon': icon,
      'baseAtt': baseAtt,
      'baseRunic': baseRunic,
      'baseDef': baseDef,
      'baseHealth': baseHealth,
      'baseLuck': baseLuck,
      'baseCooldown': baseCooldown,
      'bonusXPMod': bonusXPMod,
      'upgradeBonus': upgradeBonus,
      'maxLevel': maxLevel,
      'effectType': effectType,
      'effectValue': effectValue,
      'uses': uses,
    };
  }
}

class EnemyTemplate {
  final String id;
  final String name;
  final String? theme;
  final String? locationKey;
  final int minPlayerLevel;
  final int health;
  final int attack;
  final int defense;
  int hp;
  final int coinReward;
  final int xpReward;
  final String description;

  EnemyTemplate({
    required this.id,
    required this.name,
    this.theme,
    this.locationKey,
    required this.minPlayerLevel,
    required this.health,
    required this.attack,
    required this.defense,
    int? hp,
    required this.coinReward,
    required this.xpReward,
    required this.description,
  }) : hp = hp ?? health;

  factory EnemyTemplate.fromJson(Map<String, dynamic> json) {
    int? parseInt(dynamic val) {
      if (val == null) return null;
      if (val is int) return val;
      if (val is double) return val.toInt();
      if (val is String) return int.tryParse(val);
      return null;
    }

    final maxHealth = parseInt(json['health']) ?? 10;
    return EnemyTemplate(
      id: json['id'] as String? ??
          'unknown_enemy_${DateTime.now().millisecondsSinceEpoch}',
      name: json['name'] as String? ?? 'Nameless Foe',
      theme: json['theme'] as String?,
      locationKey: json['locationKey'] as String?,
      minPlayerLevel: parseInt(json['minPlayerLevel']) ?? 1,
      health: maxHealth,
      hp: parseInt(json['hp']) ?? maxHealth,
      attack: parseInt(json['attack']) ?? 1,
      defense: parseInt(json['defense']) ?? 0,
      coinReward: parseInt(json['coinReward']) ?? 0,
      xpReward: parseInt(json['xpReward']) ?? 0,
      description: json['description'] as String? ?? 'A mysterious enemy.',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'theme': theme,
      'locationKey': locationKey,
      'minPlayerLevel': minPlayerLevel,
      'health': health,
      'hp': hp,
      'attack': attack,
      'defense': defense,
      'coinReward': coinReward,
      'xpReward': xpReward,
      'description': description,
    };
  }
}

class Rune {
  String id;
  String name;
  String description;
  String icon;
  String type;
  String effectType;
  double effectValue;
  double? effectDuration;
  String? targetStat;
  int cost;
  int? requiredLevel;

  Rune({
    required this.id,
    required this.name,
    required this.description,
    required this.icon,
    required this.type,
    required this.effectType,
    required this.effectValue,
    this.effectDuration,
    this.targetStat,
    required this.cost,
    this.requiredLevel,
  });

  factory Rune.fromJson(Map<String, dynamic> json) {
    return Rune(
      id: json['id'] as String,
      name: json['name'] as String,
      description: json['description'] as String,
      icon: json['icon'] as String,
      type: json['type'] as String,
      effectType: json['effectType'] as String,
      effectValue: (json['effectValue'] as num).toDouble(),
      effectDuration: (json['effectDuration'] as num?)?.toDouble(),
      targetStat: json['targetStat'] as String?,
      cost: json['cost'] as int,
      requiredLevel: json['requiredLevel'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'icon': icon,
      'type': type,
      'effectType': effectType,
      'effectValue': effectValue,
      'effectDuration': effectDuration,
      'targetStat': targetStat,
      'cost': cost,
      'requiredLevel': requiredLevel,
    };
  }
}

class OwnedRune {
  String uniqueId;
  String runeId;
  bool isActive;

  OwnedRune({
    required this.uniqueId,
    required this.runeId,
    this.isActive = false,
  });

  factory OwnedRune.fromJson(Map<String, dynamic> json) {
    return OwnedRune(
      uniqueId: json['uniqueId'] as String,
      runeId: json['runeId'] as String,
      isActive: json['isActive'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'uniqueId': uniqueId,
      'runeId': runeId,
      'isActive': isActive,
    };
  }
}

// Moved from constants.dart
class MainTaskTemplate {
  final String id;
  final String name;
  final String description;
  final String theme;
  final String colorHex;

  MainTaskTemplate({
    required this.id,
    required this.name,
    required this.description,
    required this.theme,
    this.colorHex = "FF00F8F8", // Default Cyan
  });
}

// Moved from constants.dart
class GameLocation {
  final String id; // Changed key to id for consistency
  final String name;
  final String description;
  final int minPlayerLevelToUnlock;
  final String iconEmoji; // Using specific field for emoji
  final String? associatedTheme;
  final String?
      bossEnemyIdToUnlockNextLocation; // ID of an enemy in this location
  bool isCleared; // Added field for tracking if location is cleared

  GameLocation({
    required this.id,
    required this.name,
    required this.description,
    this.minPlayerLevelToUnlock = 1,
    required this.iconEmoji,
    this.associatedTheme,
    this.bossEnemyIdToUnlockNextLocation,
    this.isCleared = false, // Default to not cleared
  });

  factory GameLocation.fromJson(Map<String, dynamic> json) {
    return GameLocation(
      id: json['id'] as String? ??
          'loc_${DateTime.now().millisecondsSinceEpoch}',
      name: json['name'] as String? ?? 'Unknown Area',
      description: json['description'] as String? ?? 'A mysterious place.',
      minPlayerLevelToUnlock: json['minPlayerLevelToUnlock'] as int? ?? 1,
      iconEmoji: json['iconEmoji'] as String? ?? '❓',
      associatedTheme: json['associatedTheme'] as String?,
      bossEnemyIdToUnlockNextLocation:
          json['bossEnemyIdToUnlockNextLocation'] as String?,
      isCleared: json['isCleared'] as bool? ?? false, // Load isCleared status
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'minPlayerLevelToUnlock': minPlayerLevelToUnlock,
      'iconEmoji': iconEmoji,
      'associatedTheme': associatedTheme,
      'bossEnemyIdToUnlockNextLocation': bossEnemyIdToUnlockNextLocation,
      'isCleared': isCleared, // Save isCleared status
    };
  }
}

// Park Management Models
class DinosaurSpecies {
  final String id;
  final String name;
  final String description;
  final String diet; // "carnivore" or "herbivore"
  final int incubationCostDollars; // Park currency (Dollars)
  final int fossilExcavationEnergyCost; // Player energy
  final int baseRating; // Contribution to park rating
  final double comfortThreshold; // Min comfort % to be happy
  final int socialNeedsMin; // Min number of same species
  final int socialNeedsMax; // Max number of same species
  final int enclosureSizeNeeds; // Arbitrary units (e.g., squares)
  final String icon; // Emoji or MDI icon name

  DinosaurSpecies({
    required this.id,
    required this.name,
    required this.description,
    required this.diet,
    required this.incubationCostDollars,
    required this.fossilExcavationEnergyCost,
    required this.baseRating,
    required this.comfortThreshold,
    required this.socialNeedsMin,
    required this.socialNeedsMax,
    required this.enclosureSizeNeeds,
    required this.icon,
  });

  factory DinosaurSpecies.fromJson(Map<String, dynamic> json) {
    return DinosaurSpecies(
      id: json['id'] as String,
      name: json['name'] as String,
      description: json['description'] as String,
      diet: json['diet'] as String,
      incubationCostDollars: json['incubationCostDollars'] as int? ?? json['incubationCost'] as int, // Handle legacy 'incubationCost'
      fossilExcavationEnergyCost: json['fossilExcavationEnergyCost'] as int? ?? json['fossilExcavationCost'] as int, // Handle legacy 'fossilExcavationCost'
      baseRating: json['baseRating'] as int,
      comfortThreshold: (json['comfortThreshold'] as num).toDouble(),
      socialNeedsMin: json['socialNeedsMin'] as int,
      socialNeedsMax: json['socialNeedsMax'] as int,
      enclosureSizeNeeds: json['enclosureSizeNeeds'] as int,
      icon: json['icon'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'diet': diet,
      'incubationCostDollars': incubationCostDollars,
      'fossilExcavationEnergyCost': fossilExcavationEnergyCost,
      'baseRating': baseRating,
      'comfortThreshold': comfortThreshold,
      'socialNeedsMin': socialNeedsMin,
      'socialNeedsMax': socialNeedsMax,
      'enclosureSizeNeeds': enclosureSizeNeeds,
      'icon': icon,
    };
  }
}

class BuildingTemplate {
  final String id;
  final String name;
  final String type; // e.g., "enclosure", "hatchery", "fossil_center", "food_station", "visitor_center", "power_plant"
  final int costDollars; // Park currency (Dollars)
  final String icon; // MDI icon name
  final int? capacity; // e.g., number of dinos for enclosure, incubation slots for hatchery
  final int? operationalCostPerMinuteDollars; // Park currency
  final int? incomePerMinuteDollars; // Park currency (for visitor centers, etc.)
  final int? parkRatingBoost;
  final int? sizeX; // Grid size X
  final int? sizeY; // Grid size Y
  final int? powerRequired; // Power units this building consumes when operational
  final int? powerOutput;   // Power units this building generates (for power plants)


  BuildingTemplate({
    required this.id,
    required this.name,
    required this.type,
    required this.costDollars,
    required this.icon,
    this.capacity,
    this.operationalCostPerMinuteDollars,
    this.incomePerMinuteDollars,
    this.parkRatingBoost,
    this.sizeX,
    this.sizeY,
    this.powerRequired,
    this.powerOutput,
  });

  factory BuildingTemplate.fromJson(Map<String, dynamic> json) {
    return BuildingTemplate(
      id: json['id'] as String,
      name: json['name'] as String,
      type: json['type'] as String,
      costDollars: json['costDollars'] as int? ?? json['cost'] as int, // Handle legacy 'cost'
      icon: json['icon'] as String,
      capacity: json['capacity'] as int?,
      operationalCostPerMinuteDollars: json['operationalCostPerMinuteDollars'] as int? ?? json['operationalCostPerMinute'] as int?,
      incomePerMinuteDollars: json['incomePerMinuteDollars'] as int? ?? json['incomePerMinute'] as int?,
      parkRatingBoost: json['parkRatingBoost'] as int?,
      sizeX: json['sizeX'] as int?,
      sizeY: json['sizeY'] as int?,
      powerRequired: json['powerRequired'] as int?,
      powerOutput: json['powerOutput'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'type': type,
      'costDollars': costDollars,
      'icon': icon,
      'capacity': capacity,
      'operationalCostPerMinuteDollars': operationalCostPerMinuteDollars,
      'incomePerMinuteDollars': incomePerMinuteDollars,
      'parkRatingBoost': parkRatingBoost,
      'sizeX': sizeX,
      'sizeY': sizeY,
      'powerRequired': powerRequired,
      'powerOutput': powerOutput,
    };
  }
}

class OwnedBuilding {
  final String uniqueId;
  final String templateId;
  // GridPosition position; // Placeholder for later grid system
  List<String> dinosaurUniqueIds; // For enclosures
  int? currentFoodLevel; // For food stations (0-100)
  bool isOperational;

  OwnedBuilding({
    required this.uniqueId,
    required this.templateId,
    // required this.position,
    List<String>? dinosaurUniqueIds,
    this.currentFoodLevel,
    this.isOperational = true,
  }) : dinosaurUniqueIds = dinosaurUniqueIds ?? [];

  factory OwnedBuilding.fromJson(Map<String, dynamic> json) {
    return OwnedBuilding(
      uniqueId: json['uniqueId'] as String,
      templateId: json['templateId'] as String,
      // position: GridPosition.fromJson(json['position']),
      dinosaurUniqueIds: (json['dinosaurUniqueIds'] as List<dynamic>?)
          ?.map((id) => id as String)
          .toList() ?? [],
      currentFoodLevel: json['currentFoodLevel'] as int?,
      isOperational: json['isOperational'] as bool? ?? true,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'uniqueId': uniqueId,
      'templateId': templateId,
      // 'position': position.toJson(),
      'dinosaurUniqueIds': dinosaurUniqueIds,
      'currentFoodLevel': currentFoodLevel,
      'isOperational': isOperational,
    };
  }
}

class OwnedDinosaur {
  final String uniqueId;
  final String speciesId;
  String name; // Can be nicknamed by player
  double currentHealth; // 0-100
  double currentComfort; // 0-100
  double currentFood; // 0-100 (satiation)
  int age; // In game days/minutes

  OwnedDinosaur({
    required this.uniqueId,
    required this.speciesId,
    required this.name,
    this.currentHealth = 100.0,
    this.currentComfort = 75.0,
    this.currentFood = 75.0,
    this.age = 0,
  });

  factory OwnedDinosaur.fromJson(Map<String, dynamic> json) {
    return OwnedDinosaur(
      uniqueId: json['uniqueId'] as String,
      speciesId: json['speciesId'] as String,
      name: json['name'] as String,
      currentHealth: (json['currentHealth'] as num? ?? 100.0).toDouble(),
      currentComfort: (json['currentComfort'] as num? ?? 75.0).toDouble(),
      currentFood: (json['currentFood'] as num? ?? 75.0).toDouble(),
      age: json['age'] as int? ?? 0,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'uniqueId': uniqueId,
      'speciesId': speciesId,
      'name': name,
      'currentHealth': currentHealth,
      'currentComfort': currentComfort,
      'currentFood': currentFood,
      'age': age,
    };
  }
}

class FossilRecord {
  final String speciesId;
  double excavationProgress; // 0.0 to 100.0
  bool isGenomeComplete;

  FossilRecord({
    required this.speciesId,
    this.excavationProgress = 0.0,
    this.isGenomeComplete = false,
  });

  factory FossilRecord.fromJson(Map<String, dynamic> json) {
    return FossilRecord(
      speciesId: json['speciesId'] as String,
      excavationProgress: (json['excavationProgress'] as num? ?? 0.0).toDouble(),
      isGenomeComplete: json['isGenomeComplete'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'speciesId': speciesId,
      'excavationProgress': excavationProgress,
      'isGenomeComplete': isGenomeComplete,
    };
  }
}

class ParkManager {
  int parkRating;
  double parkDollars; // New currency for park
  double parkEnergy; // Player energy for park operations
  double maxParkEnergy;
  int incomePerMinuteDollars; // Total from all income-generating buildings (Dollars)
  int operationalCostPerMinuteDollars; // Total from all buildings (Dollars)
  int currentPowerGenerated;
  int currentPowerConsumed;


  ParkManager({
    this.parkRating = 0,
    this.parkDollars = 50000, // Starting park dollars
    this.parkEnergy = 100.0, // Starting park energy, linked to player energy
    this.maxParkEnergy = 100.0,
    this.incomePerMinuteDollars = 0,
    this.operationalCostPerMinuteDollars = 0,
    this.currentPowerGenerated = 0,
    this.currentPowerConsumed = 0,
  });

  factory ParkManager.fromJson(Map<String, dynamic> json) {
    return ParkManager(
      parkRating: json['parkRating'] as int? ?? 0,
      parkDollars: (json['parkDollars'] as num? ?? 50000.0).toDouble(),
      parkEnergy: (json['parkEnergy'] as num? ?? 100.0).toDouble(),
      maxParkEnergy: (json['maxParkEnergy'] as num? ?? 100.0).toDouble(),
      incomePerMinuteDollars: json['incomePerMinuteDollars'] as int? ?? json['incomePerMinute'] as int? ?? 0,
      operationalCostPerMinuteDollars: json['operationalCostPerMinuteDollars'] as int? ?? json['operationalCostPerMinute'] as int? ?? 0,
      currentPowerGenerated: json['currentPowerGenerated'] as int? ?? 0,
      currentPowerConsumed: json['currentPowerConsumed'] as int? ?? 0,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'parkRating': parkRating,
      'parkDollars': parkDollars,
      'parkEnergy': parkEnergy,
      'maxParkEnergy': maxParkEnergy,
      'incomePerMinuteDollars': incomePerMinuteDollars,
      'operationalCostPerMinuteDollars': operationalCostPerMinuteDollars,
      'currentPowerGenerated': currentPowerGenerated,
      'currentPowerConsumed': currentPowerConsumed,
    };
  }
}

class EmotionLog {
  final DateTime timestamp;
  final int rating; // 1-5

  EmotionLog({required this.timestamp, required this.rating});

  factory EmotionLog.fromJson(Map<String, dynamic> json) {
    return EmotionLog(
      timestamp: DateTime.parse(json['timestamp'] as String),
      rating: json['rating'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'timestamp': timestamp.toIso8601String(),
      'rating': rating,
    };
  }
}
--- END OF FILE lib/src/models/game_models.dart ---
--- START OF FILE lib/src/widgets/views/settings_view.dart ---
// lib/src/widgets/views/settings_view.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:intl/intl.dart';

class SettingsView extends StatefulWidget {
  const SettingsView({super.key});

  @override
  State<SettingsView> createState() => _SettingsViewState();
}

class _SettingsViewState extends State<SettingsView> {
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  final _newUsernameController = TextEditingController(); // For username change
  bool _passwordChangeLoading = false;
  String _passwordChangeError = '';
  String _passwordChangeSuccess = '';
  bool _usernameChangeLoading = false; // For username change
  String _usernameChangeError = ''; // For username change
  String _usernameChangeSuccess = ''; // For username change
  bool _logoutLoading = false;

  @override
  void initState() {
    super.initState();
    // Initialize username controller if user is available
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    _newUsernameController.text = gameProvider.currentUser?.displayName ?? '';
  }

  @override
  void dispose() {
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    _newUsernameController.dispose();
    super.dispose();
  }

  Future<void> _handleChangePassword(GameProvider gameProvider) async {
    if (_newPasswordController.text != _confirmPasswordController.text) {
      setState(() => _passwordChangeError = "Passwords do not match.");
      return;
    }
    if (_newPasswordController.text.length < 6) {
      setState(() => _passwordChangeError =
          "Password should be at least 6 characters long.");
      return;
    }
    setState(() {
      _passwordChangeLoading = true;
      _passwordChangeError = '';
      _passwordChangeSuccess = '';
    });
    try {
      await gameProvider.changePasswordHandler(_newPasswordController.text);
      setState(() {
        _passwordChangeSuccess = "Password changed successfully!";
        _newPasswordController.clear();
        _confirmPasswordController.clear();
      });
    } catch (e) {
      if (e is FirebaseAuthException) {
        setState(() =>
            _passwordChangeError = e.message ?? "Failed to change password.");
      } else {
        setState(() => _passwordChangeError =
            "An unexpected error occurred while changing password.");
      }
    } finally {
      if (mounted) {
        setState(() => _passwordChangeLoading = false);
      }
    }
  }

  Future<void> _handleChangeUsername(GameProvider gameProvider) async {
    if (_newUsernameController.text.trim().isEmpty) {
      setState(() => _usernameChangeError = "Username cannot be empty.");
      return;
    }
    if (_newUsernameController.text.trim().length < 3) {
      setState(() =>
          _usernameChangeError = "Username must be at least 3 characters.");
      return;
    }
    setState(() {
      _usernameChangeLoading = true;
      _usernameChangeError = '';
      _usernameChangeSuccess = '';
    });
    try {
      await gameProvider
          .updateUserDisplayName(_newUsernameController.text.trim());
      setState(() {
        _usernameChangeSuccess = "Username updated successfully!";
      });
    } catch (e) {
      if (e is FirebaseAuthException) {
        setState(() =>
            _usernameChangeError = e.message ?? "Failed to update username.");
      } else {
        setState(() => _usernameChangeError =
            "An unexpected error occurred while updating username.");
      }
    } finally {
      if (mounted) {
        setState(() => _usernameChangeLoading = false);
      }
    }
  }

  Future<void> _handleLogout(
      GameProvider gameProvider, BuildContext pageContext) async {
    setState(() {
      _logoutLoading = true;
    });
    try {
      await gameProvider.logoutUser();
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(pageContext).showSnackBar(SnackBar(
          content: Text('Logout failed: ${e.toString()}'),
          backgroundColor: AppTheme.fhAccentRed));
    } finally {
      if (mounted) {
        setState(() {
          _logoutLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);

    String lastSavedString = "Not synced yet.";
    if (gameProvider.lastSuccessfulSaveTimestamp != null) {
      lastSavedString =
          "Last synced: ${DateFormat('MMM d, yyyy, hh:mm:ss a').format(gameProvider.lastSuccessfulSaveTimestamp!.toLocal())}";
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.only(bottom: 24.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(MdiIcons.cogOutline,
                    color: (gameProvider.getSelectedTask()?.taskColor ??
                        AppTheme.fhAccentTealFixed),
                    size: 36),
                const SizedBox(width: 12),
                Text("System Configuration",
                    style: theme.textTheme.displaySmall?.copyWith(
                        color: (gameProvider.getSelectedTask()?.taskColor ??
                            AppTheme.fhAccentTealFixed))),
              ],
            ),
          ),
          _buildSettingsSection(gameProvider, theme,
              icon: MdiIcons.cloudSyncOutline,
              title: 'Cloud Synchronization',
              children: [
                ElevatedButton.icon(
                  icon: gameProvider.isManuallySaving
                      ? const SizedBox(
                          width: 18,
                          height: 18,
                          child: CircularProgressIndicator(
                              strokeWidth: 2, color: AppTheme.fhTextPrimary))
                      : Icon(MdiIcons.cloudUploadOutline, size: 18),
                  label: const Text('SAVE TO CLOUD NOW'),
                  onPressed: gameProvider.isManuallySaving ||
                          gameProvider.isManuallyLoading
                      ? null
                      : () async {
                          try {
                            await gameProvider.manuallySaveToCloud();
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                  const SnackBar(
                                      content: Text('Data saved to cloud.'),
                                      backgroundColor: AppTheme.fhAccentGreen));
                            }
                          } catch (e) {
                            if (mounted) {
                              ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                      content: Text(
                                          'Cloud save failed: ${e.toString()}'),
                                      backgroundColor: AppTheme.fhAccentRed));
                            }
                          }
                        },
                  style: ElevatedButton.styleFrom(
                      minimumSize: const Size(double.infinity, 44),
                      backgroundColor:
                          (gameProvider.getSelectedTask()?.taskColor ??
                              AppTheme.fhAccentTealFixed),
                      foregroundColor: AppTheme.fhBgDark),
                ),
                const SizedBox(height: 12),
                ElevatedButton.icon(
                  icon: gameProvider.isManuallyLoading
                      ? const SizedBox(
                          width: 18,
                          height: 18,
                          child: CircularProgressIndicator(
                              strokeWidth: 2, color: AppTheme.fhTextPrimary))
                      : Icon(MdiIcons.cloudDownloadOutline, size: 18),
                  label: const Text('LOAD FROM CLOUD NOW'),
                  onPressed: gameProvider.isManuallySaving ||
                          gameProvider.isManuallyLoading
                      ? null
                      : () async {
                          final confirm = await showDialog<bool>(
                            context: context,
                            builder: (ctx) => AlertDialog(
                              title: Row(children: [
                                Icon(MdiIcons.cloudQuestionOutline,
                                    color: AppTheme.fhAccentOrange),
                                const SizedBox(width: 10),
                                const Text('Confirm Load')
                              ]),
                              content: const Text(
                                  'This will overwrite any local unsaved changes with data from the cloud. Are you sure?'),
                              actionsAlignment: MainAxisAlignment.spaceBetween,
                              actions: [
                                TextButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(false),
                                    child: const Text('CANCEL')),
                                ElevatedButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(true),
                                    style: ElevatedButton.styleFrom(
                                        backgroundColor:
                                            AppTheme.fhAccentOrange),
                                    child: const Text('CONFIRM LOAD')),
                              ],
                            ),
                          );
                          if (confirm == true) {
                            try {
                              await gameProvider.manuallyLoadFromCloud();
                              if (mounted) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                    const SnackBar(
                                        content:
                                            Text('Data loaded from cloud.'),
                                        backgroundColor:
                                            AppTheme.fhAccentGreen));
                              }
                            } catch (e) {
                              if (mounted) {
                                ScaffoldMessenger.of(context).showSnackBar(
                                    SnackBar(
                                        content: Text(
                                            'Cloud load failed: ${e.toString()}'),
                                        backgroundColor: AppTheme.fhAccentRed));
                              }
                            }
                          }
                        },
                  style: ElevatedButton.styleFrom(
                      minimumSize: const Size(double.infinity, 44),
                      backgroundColor:
                          (gameProvider.getSelectedTask()?.taskColor ??
                              AppTheme.fhAccentTealFixed),
                      foregroundColor: AppTheme.fhBgDark),
                ),
                const SizedBox(height: 12),
                Center(
                  child: Text(
                    lastSavedString,
                    style: theme.textTheme.labelSmall?.copyWith(
                        color: AppTheme.fhTextSecondary.withOpacity(0.8),
                        fontSize: 11,
                        fontStyle: FontStyle.italic),
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  "Note: Game progress is auto-saved to the cloud periodically (approx. every minute if changes are detected). Use these options for immediate synchronization or recovery.",
                  style: theme.textTheme.bodySmall?.copyWith(
                      color: AppTheme.fhTextSecondary.withOpacity(0.8),
                      fontSize: 10),
                ),
              ]),
          _buildSettingsSection(gameProvider, theme,
              icon: MdiIcons.accountEditOutline,
              title: 'User Profile',
              children: [
                TextFormField(
                  controller: _newUsernameController,
                  decoration: InputDecoration(
                      labelText: 'Display Name',
                      prefixIcon: Icon(MdiIcons.accountBadgeOutline, size: 20)),
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Display name cannot be empty.';
                    }
                    if (value.trim().length < 3) {
                      return 'Must be at least 3 characters.';
                    }
                    return null;
                  },
                ),
                if (_usernameChangeError.isNotEmpty)
                  Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(_usernameChangeError,
                        style: const TextStyle(
                            color: AppTheme.fhAccentRed, fontSize: 12)),
                  ),
                if (_usernameChangeSuccess.isNotEmpty)
                  Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(_usernameChangeSuccess,
                        style: const TextStyle(
                            color: AppTheme.fhAccentGreen, fontSize: 12)),
                  ),
                const SizedBox(height: 16),
                ElevatedButton.icon(
                  icon: _usernameChangeLoading
                      ? const SizedBox(
                          width: 18,
                          height: 18,
                          child: CircularProgressIndicator(
                              strokeWidth: 2, color: AppTheme.fhTextPrimary))
                      : Icon(MdiIcons.contentSaveOutline, size: 18),
                  label: const Text('UPDATE DISPLAY NAME'),
                  onPressed: _usernameChangeLoading
                      ? null
                      : () => _handleChangeUsername(gameProvider),
                  style: ElevatedButton.styleFrom(
                      minimumSize: const Size(double.infinity, 44)),
                ),
              ]),
          _buildSettingsSection(
            gameProvider,
            theme,
            icon: MdiIcons.brain,
            title: 'Cognitive Matrix (AI)',
            children: [
              SwitchListTile.adaptive(
                title: const Text('Daily Auto-Generate Content'),
                subtitle: const Text(
                    'Each day, automatically generate new challenges (enemies, and a new realm if current one is pacified).'),
                value: gameProvider.settings.dailyAutoGenerateContent,
                onChanged: (value) => gameProvider.setSettings(
                    gameProvider.settings..dailyAutoGenerateContent = value),
                activeColor: (gameProvider.getSelectedTask()?.taskColor ??
                    AppTheme.fhAccentTealFixed),
                contentPadding: EdgeInsets.zero,
              ),
              const SizedBox(height: 12),
              Text(
                'Manually initiate content generation protocols for current operational level (${gameProvider.playerLevel}). This may consume significant resources.',
                style: theme.textTheme.bodySmall
                    ?.copyWith(color: AppTheme.fhTextSecondary),
              ),
              const SizedBox(height: 12),
              ElevatedButton.icon(
                icon: gameProvider.isGeneratingContent &&
                        gameProvider.aiGenerationStatusMessage
                            .contains("Adversaries")
                    ? const SizedBox(
                        width: 18,
                        height: 18,
                        child: CircularProgressIndicator(
                            strokeWidth: 2.5, color: AppTheme.fhTextPrimary))
                    : Icon(MdiIcons.skullCrossbonesOutline, size: 18),
                label: Text(gameProvider.isGeneratingContent &&
                        gameProvider.aiGenerationStatusMessage
                            .contains("Adversaries")
                    ? 'GENERATING ADVERSARIES...'
                    : 'GENERATE NEW ADVERSARIES'),
                onPressed: gameProvider.isGeneratingContent
                    ? null
                    : () => gameProvider.generateGameContent(
                        gameProvider.playerLevel,
                        isManual: true,
                        isInitial: false,
                        contentType: "enemies"),
                style: ElevatedButton.styleFrom(
                    minimumSize: const Size(double.infinity, 44)),
              ),
              const SizedBox(height: 12),
              ElevatedButton.icon(
                icon: gameProvider.isGeneratingContent &&
                        gameProvider.aiGenerationStatusMessage
                            .contains("Artifacts")
                    ? const SizedBox(
                        width: 18,
                        height: 18,
                        child: CircularProgressIndicator(
                            strokeWidth: 2.5, color: AppTheme.fhTextPrimary))
                    : Icon(MdiIcons.swordCross, size: 18),
                label: Text(gameProvider.isGeneratingContent &&
                        gameProvider.aiGenerationStatusMessage
                            .contains("Artifacts")
                    ? 'FORGING ARTIFACTS...'
                    : 'FORGE NEW ARTIFACTS'),
                onPressed: gameProvider.isGeneratingContent
                    ? null
                    : () => gameProvider.generateGameContent(
                        gameProvider.playerLevel,
                        isManual: true,
                        isInitial: false,
                        contentType: "artifacts"),
                style: ElevatedButton.styleFrom(
                    minimumSize: const Size(double.infinity, 44)),
              ),
              const SizedBox(height: 12),
              ElevatedButton.icon(
                icon: gameProvider.isGeneratingContent &&
                        gameProvider.aiGenerationStatusMessage.contains("Realms")
                    ? const SizedBox(
                        width: 18,
                        height: 18,
                        child: CircularProgressIndicator(
                            strokeWidth: 2.5, color: AppTheme.fhTextPrimary))
                    : Icon(MdiIcons.mapSearchOutline, size: 18),
                label: Text(gameProvider.isGeneratingContent &&
                        gameProvider.aiGenerationStatusMessage.contains("Realms")
                    ? 'DISCOVERING REALMS...'
                    : 'DISCOVER NEW REALMS'),
                onPressed: gameProvider.isGeneratingContent
                    ? null
                    : () => gameProvider.generateGameContent(
                        gameProvider.playerLevel,
                        isManual: true,
                        isInitial: false,
                        contentType: "locations"),
                style: ElevatedButton.styleFrom(
                    minimumSize: const Size(double.infinity, 44)),
              ),
              if (gameProvider.isGeneratingContent)
                Padding(
                  padding: const EdgeInsets.only(top: 10.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      LinearProgressIndicator(
                        value: gameProvider.aiGenerationProgress,
                        backgroundColor:
                            AppTheme.fhBorderColor.withOpacity(0.2),
                        valueColor: AlwaysStoppedAnimation<Color>(
                            (gameProvider.getSelectedTask()?.taskColor ??
                                    AppTheme.fhAccentTealFixed)
                                .withOpacity(0.7)),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        gameProvider.aiGenerationStatusMessage.isNotEmpty
                            ? gameProvider.aiGenerationStatusMessage
                            : 'Cognitive matrix recalculating... please standby.',
                        style: theme.textTheme.bodySmall?.copyWith(
                            fontStyle: FontStyle.italic,
                            color: (gameProvider.getSelectedTask()?.taskColor ??
                                    AppTheme.fhAccentTealFixed)
                                .withOpacity(0.8)),
                      ),
                    ],
                  ),
                ),
            ],
          ),
          _buildSettingsSection(gameProvider, theme,
              icon: MdiIcons.mapLegend,
              title: "Manage Realms (Combat Zones)",
              children: [
                if (gameProvider.gameLocationsList.isEmpty)
                  const Text("No combat zones discovered yet.",
                      style: TextStyle(fontStyle: FontStyle.italic)),
                ListView.builder(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  itemCount: gameProvider.gameLocationsList.length,
                  itemBuilder: (context, index) {
                    final location = gameProvider.gameLocationsList[index];
                    return ListTile(
                      leading: Text(location.iconEmoji,
                          style: const TextStyle(fontSize: 20)),
                      title: Text(location.name),
                      subtitle: Text(
                          "Lvl ${location.minPlayerLevelToUnlock}+. ${location.description}",
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis),
                      trailing: IconButton(
                        icon: Icon(MdiIcons.mapMarkerRemoveVariant,
                            color: AppTheme.fhAccentRed),
                        tooltip: "Decommission Realm",
                        onPressed: () async {
                          final confirm = await showDialog<bool>(
                            context: context,
                            builder: (ctx) => AlertDialog(
                              title: Row(children: [
                                Icon(MdiIcons.alertOutline,
                                    color: AppTheme.fhAccentRed),
                                const SizedBox(width: 10),
                                const Text('Confirm Decommission')
                              ]),
                              content: Text(
                                  'Are you sure you want to decommission the realm "${location.name}"? This cannot be undone.'),
                              actionsAlignment: MainAxisAlignment.spaceBetween,
                              actions: [
                                TextButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(false),
                                    child: const Text('CANCEL')),
                                ElevatedButton(
                                    onPressed: () =>
                                        Navigator.of(ctx).pop(true),
                                    style: ElevatedButton.styleFrom(
                                        backgroundColor: AppTheme.fhAccentRed),
                                    child: const Text('DECOMMISSION REALM')),
                              ],
                            ),
                          );
                          if (confirm == true) {
                            gameProvider.deleteGameLocation(location.id);
                          }
                        },
                      ),
                    );
                  },
                )
              ]),
          _buildSettingsSection(gameProvider, theme,
              icon: MdiIcons.layersTripleOutline,
              title: 'Content Matrix Control',
              children: [
                Text(
                  'Manage generated game content. These actions are specific and do not affect player progress directly, but may alter game balance or availability of items/enemies.',
                  style: theme.textTheme.bodySmall
                      ?.copyWith(color: AppTheme.fhTextSecondary, height: 1.4),
                ),
                const SizedBox(height: 16),
                ElevatedButton.icon(
                  icon: Icon(MdiIcons.archiveRemoveOutline,
                      size: 18, color: AppTheme.fhTextPrimary),
                  label: const Text('CLEAR ARTIFACTS & BLUEPRINTS'),
                  onPressed: () async {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: Row(children: [
                          Icon(MdiIcons.alertOutline,
                              color: AppTheme.fhAccentOrange),
                          const SizedBox(width: 10),
                          const Text('Confirm Artifact Purge')
                        ]),
                        content: const Text(
                            'This will remove ALL owned artifacts from your inventory (equipped items will be unequipped) AND all artifact blueprints/templates. This action cannot be undone. Are you sure?'),
                        actionsAlignment: MainAxisAlignment.spaceBetween,
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.of(ctx).pop(false),
                              child: const Text('CANCEL')),
                          ElevatedButton(
                              onPressed: () => Navigator.of(ctx).pop(true),
                              style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.fhAccentOrange),
                              child: const Text('CONFIRM PURGE')),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      gameProvider.clearAllArtifactsAndTemplates(); // Updated method name
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(
                            content: Text(
                                'All owned artifacts and blueprints purged.'),
                            backgroundColor: AppTheme.fhAccentGreen));
                      }
                    }
                  },
                  style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.fhAccentOrange,
                      foregroundColor: AppTheme.fhTextPrimary,
                      minimumSize: const Size(double.infinity, 44)),
                ),
                const SizedBox(height: 12),
                ElevatedButton.icon(
                  icon: Icon(MdiIcons.skullCrossbonesOutline,
                      size: 18, color: AppTheme.fhTextPrimary),
                  label: const Text('DECOMMISSION ENEMIES'),
                  onPressed: () async {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: Row(children: [
                          Icon(MdiIcons.alertOutline,
                              color: AppTheme.fhAccentOrange),
                          const SizedBox(width: 10),
                          const Text('Confirm Decommission')
                        ]),
                        content: const Text(
                            'This removes all enemy templates. The Arena might be empty until new content is generated. This action cannot be undone. Are you sure?'),
                        actionsAlignment: MainAxisAlignment.spaceBetween,
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.of(ctx).pop(false),
                              child: const Text('CANCEL')),
                          ElevatedButton(
                              onPressed: () => Navigator.of(ctx).pop(true),
                              style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.fhAccentOrange,
                                  foregroundColor: AppTheme.fhTextPrimary),
                              child: const Text('CONFIRM DECOMMISSION')),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      gameProvider.removeAllEnemyTemplates();
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content: Text(
                                    'All enemy signatures decommissioned.'),
                                backgroundColor: AppTheme.fhAccentGreen));
                      }
                    }
                  },
                  style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.fhAccentOrange,
                      foregroundColor: AppTheme.fhTextPrimary,
                      minimumSize: const Size(double.infinity, 44)),
                ),
                const SizedBox(height: 12),
                ElevatedButton.icon( // New Button
                  icon: Icon(MdiIcons.earthRemove,
                      size: 18, color: AppTheme.fhTextPrimary),
                  label: const Text('DECOMMISSION ALL REALMS'),
                  onPressed: () async {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: Row(children: [
                          Icon(MdiIcons.alertOutline,
                              color: AppTheme.fhAccentOrange),
                          const SizedBox(width: 10),
                          const Text('Confirm Realm Decommission')
                        ]),
                        content: const Text(
                            'This removes ALL combat zones (realms). The Arena will be inaccessible until new realms are discovered/generated. This action cannot be undone. Are you sure?'),
                        actionsAlignment: MainAxisAlignment.spaceBetween,
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.of(ctx).pop(false),
                              child: const Text('CANCEL')),
                          ElevatedButton(
                              onPressed: () => Navigator.of(ctx).pop(true),
                              style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.fhAccentOrange,
                                  foregroundColor: AppTheme.fhTextPrimary),
                              child: const Text('CONFIRM DECOMMISSION')),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      gameProvider.removeAllGameLocations();
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content: Text(
                                    'All realms decommissioned.'),
                                backgroundColor: AppTheme.fhAccentGreen));
                      }
                    }
                  },
                  style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.fhAccentOrange,
                      foregroundColor: AppTheme.fhTextPrimary,
                      minimumSize: const Size(double.infinity, 44)),
                ),
              ]),
          _buildSettingsSection(gameProvider, theme,
              icon: MdiIcons.eyeSettingsOutline,
              title: 'User Interface Config',
              children: [
                SwitchListTile.adaptive(
                  title: const Text('Verbose Data Display'),
                  subtitle: const Text(
                      'Show detailed descriptions for stats and items throughout the interface.'),
                  value: gameProvider.settings.descriptionsVisible,
                  onChanged: (value) => gameProvider.setSettings(
                      gameProvider.settings..descriptionsVisible = value),
                  activeColor: (gameProvider.getSelectedTask()?.taskColor ??
                      AppTheme.fhAccentTealFixed),
                  contentPadding: EdgeInsets.zero,
                ),
              ]),
          if (gameProvider.currentUser != null)
            _buildSettingsSection(gameProvider, theme,
                icon: MdiIcons.shieldAccountOutline,
                title: 'Access Credentials',
                children: [
                  TextFormField(
                    controller: _newPasswordController,
                    decoration: InputDecoration(
                        labelText: 'New Passcode Sequence',
                        prefixIcon:
                            Icon(MdiIcons.formTextboxPassword, size: 20)),
                    obscureText: true,
                  ),
                  const SizedBox(height: 12),
                  TextFormField(
                    controller: _confirmPasswordController,
                    decoration: InputDecoration(
                        labelText: 'Confirm Passcode Sequence',
                        prefixIcon:
                            Icon(MdiIcons.formTextboxPassword, size: 20)),
                    obscureText: true,
                  ),
                  if (_passwordChangeError.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.only(top: 10.0),
                      child: Text(_passwordChangeError,
                          style: const TextStyle(
                              color: AppTheme.fhAccentRed, fontSize: 12)),
                    ),
                  if (_passwordChangeSuccess.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.only(top: 10.0),
                      child: Text(_passwordChangeSuccess,
                          style: const TextStyle(
                              color: AppTheme.fhAccentGreen, fontSize: 12)),
                    ),
                  const SizedBox(height: 16),
                  ElevatedButton.icon(
                    icon: _passwordChangeLoading
                        ? const SizedBox(
                            width: 18,
                            height: 18,
                            child: CircularProgressIndicator(
                                strokeWidth: 2.5,
                                color: AppTheme.fhTextPrimary))
                        : Icon(MdiIcons.keyChange, size: 18),
                    label: const Text('UPDATE PASSCODE'),
                    onPressed: _passwordChangeLoading
                        ? null
                        : () => _handleChangePassword(gameProvider),
                    style: ElevatedButton.styleFrom(
                        backgroundColor:
                            (gameProvider.getSelectedTask()?.taskColor ??
                                AppTheme.fhAccentTealFixed),
                        foregroundColor: AppTheme.fhBgDark,
                        minimumSize: const Size(double.infinity, 44)),
                  ),
                  const SizedBox(height: 20),
                  OutlinedButton.icon(
                    icon: _logoutLoading
                        ? const SizedBox(
                            width: 18,
                            height: 18,
                            child: CircularProgressIndicator(
                                strokeWidth: 2.5,
                                color: AppTheme.fhAccentOrange))
                        : Icon(MdiIcons.logoutVariant, size: 18),
                    label: const Text('TERMINATE SESSION'),
                    onPressed: _logoutLoading
                        ? null
                        : () => _handleLogout(gameProvider, context),
                    style: OutlinedButton.styleFrom(
                        foregroundColor: AppTheme.fhAccentOrange,
                        side: const BorderSide(
                            color: AppTheme.fhAccentOrange, width: 1.5),
                        minimumSize: const Size(double.infinity, 44)),
                  ),
                ]),
          _buildSettingsSection(gameProvider, theme,
              icon: MdiIcons.databaseRemoveOutline,
              title: 'Data & System Reset',
              children: [
                ElevatedButton.icon(
                  icon: Icon(MdiIcons.undoVariant, size: 18),
                  label: const Text('RESET PLAYER LEVEL'),
                  onPressed: () async {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: Row(children: [
                          Icon(MdiIcons.alertOutline,
                              color: AppTheme.fhAccentOrange),
                          const SizedBox(width: 10),
                          const Text('Confirm Level Reset')
                        ]),
                        content: const Text(
                            'This will reset your player level to 1, XP to 0, and clear defeated enemies for the current level. Your tasks, items, and coins will remain. Are you sure?'),
                        actionsAlignment: MainAxisAlignment.spaceBetween,
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.of(ctx).pop(false),
                              child: const Text('CANCEL')),
                          ElevatedButton(
                              onPressed: () => Navigator.of(ctx).pop(true),
                              style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.fhAccentOrange),
                              child: const Text('CONFIRM RESET')),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      gameProvider.resetPlayerLevelAndProgress();
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content:
                                    Text('Player level and progress reset.'),
                                backgroundColor: AppTheme.fhAccentGreen));
                      }
                    }
                  },
                  style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.fhAccentOrange,
                      foregroundColor: AppTheme.fhTextPrimary,
                      minimumSize: const Size(double.infinity, 44)),
                ),
                const SizedBox(height: 16),
                Text(
                  'WARNING: The "Purge All Data" protocol will erase all operational data, including quest logs, experience, currency, and acquired assets. This action is irreversible and will reset the system to factory defaults.',
                  style: theme.textTheme.bodySmall
                      ?.copyWith(color: AppTheme.fhTextSecondary, height: 1.5),
                ),
                const SizedBox(height: 16),
                ElevatedButton.icon(
                  icon: Icon(MdiIcons.alertOctagonOutline, size: 18),
                  label: const Text('PURGE ALL DATA'),
                  onPressed: () async {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: Row(children: [
                          Icon(MdiIcons.alertOutline,
                              color: AppTheme.fhAccentRed),
                          const SizedBox(width: 10),
                          const Text('Confirm System Purge',
                              style: TextStyle(color: AppTheme.fhAccentRed))
                        ]),
                        content: const Text(
                            'Are you absolutely certain you wish to erase all data? This operation cannot be undone and will result in total loss of progress.'),
                        actionsAlignment: MainAxisAlignment.spaceBetween,
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.of(ctx).pop(false),
                              child: const Text('CANCEL')),
                          ElevatedButton(
                              onPressed: () => Navigator.of(ctx).pop(true),
                              style: ElevatedButton.styleFrom(
                                  backgroundColor: AppTheme.fhAccentRed,
                                  foregroundColor: AppTheme.fhTextPrimary),
                              child: const Text('CONFIRM PURGE')),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      gameProvider.clearAllGameData();
                      if (mounted) {
                        ScaffoldMessenger.of(context).showSnackBar(
                            const SnackBar(
                                content: Text('All game data has been purged.'),
                                backgroundColor: AppTheme.fhAccentGreen));
                      }
                    }
                  },
                  style: ElevatedButton.styleFrom(
                      backgroundColor: AppTheme.fhAccentRed,
                      foregroundColor: AppTheme.fhTextPrimary,
                      minimumSize: const Size(double.infinity, 44)),
                ),
              ]),
        ],
      ),
    );
  }

  Widget _buildSettingsSection(GameProvider gameProvider, ThemeData theme,
      {required IconData icon,
      required String title,
      required List<Widget> children}) {
    return Card(
      // Using the globally themed Card
      margin: const EdgeInsets.only(bottom: 24),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(icon,
                    color: (gameProvider.getSelectedTask()?.taskColor ??
                        AppTheme.fhAccentTealFixed),
                    size: 22),
                const SizedBox(width: 10),
                Text(title,
                    style: theme.textTheme.headlineSmall
                        ?.copyWith(fontWeight: FontWeight.w600)),
              ],
            ),
            Divider(
                height: 24,
                thickness: 0.5,
                color: AppTheme.fhBorderColor.withOpacity(0.5)),
            ...children,
          ],
        ),
      ),
    );
  }
}

--- END OF FILE lib/src/widgets/views/settings_view.dart ---
--- START OF FILE lib/src/providers/game_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:arcane/src/services/firebase_service.dart' as fb_service;
import 'package:arcane/src/services/storage_service.dart';
import 'package:arcane/src/utils/constants.dart';
import 'package:arcane/src/utils/helpers.dart' as helper;
import 'package:firebase_auth/firebase_auth.dart';
import 'package:intl/intl.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:collection/collection.dart';
import 'dart:async';
import 'package:flutter/material.dart'; // For TimeOfDay

import 'package:arcane/src/models/game_models.dart';

import 'actions/task_actions.dart';
import 'actions/item_actions.dart';
import 'actions/combat_actions.dart';
import 'actions/ai_generation_actions.dart';
import 'actions/timer_actions.dart';
import 'actions/park_actions.dart';

class GameProvider with ChangeNotifier {
  final StorageService _storageService = StorageService();
  Timer? _periodicUiTimer;
  Timer? _autoSaveTimer;
  Timer? _parkUpdateTimer; // For park income/costs

  User? _currentUser;
  User? get currentUser => _currentUser;
  bool _authLoading = true;
  bool get authLoading => _authLoading;
  bool _isDataLoadingAfterLogin = false;
  bool get isDataLoadingAfterLogin => _isDataLoadingAfterLogin;
  bool _isUsernameMissing = false;
  bool get isUsernameMissing => _isUsernameMissing;

  String? _lastLoginDate;
  double _coins = 100;
  double _xp = 0;
  int _playerLevel = 1;
  double _playerEnergy = baseMaxPlayerEnergy;
  List<MainTask> _mainTasks =
      initialMainTaskTemplates.map((t) => MainTask.fromTemplate(t)).toList();
  Map<String, dynamic> _completedByDay = {};
  List<OwnedArtifact> _artifacts = [];
  List<ArtifactTemplate> _artifactTemplatesList = [];
  List<EnemyTemplate> _enemyTemplatesList = [];
  List<GameLocation> _gameLocationsList = []; // New list for game locations
  List<Rune> _runeTemplatesList = [];
  List<OwnedRune> _ownedRunes = [];

  Map<String, PlayerStat> _playerGameStats = {
    ...Map.from(basePlayerGameStats.map((key, value) => MapEntry(
        key,
        PlayerStat(
            name: value.name,
            description: value.description,
            icon: value.icon,
            value: value.value,
            base: value.base)))),
  };
  void _ensureBonusXpModStat() {
    if (!_playerGameStats.containsKey('bonusXPMod')) {
      _playerGameStats['bonusXPMod'] = PlayerStat(
          name: 'XP CALC MOD', // Display name for the UI
          value: 0,
          base: 0,
          description: 'Internal XP modifier from gear.',
          icon: 'mdi-percent-outline'); // Using MDI string
    }
  }

  Map<String, String?> _equippedItems = {
    'weapon': null,
    'armor': null,
    'talisman': null
  };
  Map<String, String?> _equippedRunes = {
    'rune_slot_1': null,
    'rune_slot_2': null
  };

  List<String> _defeatedEnemyIds = [];
  List<String> _clearedLocationIds = []; // To track cleared locations
  List<String> get clearedLocationIds => _clearedLocationIds;

  CurrentGame _currentGame = CurrentGame(
      playerCurrentHp: basePlayerGameStats['vitality']!.value,
      currentPlaceKey: initialGameLocations.isNotEmpty
          ? initialGameLocations.first.id
          : null);
  GameSettings _settings = GameSettings();
  String _currentView = 'task-details';
  String? _selectedTaskId = initialMainTaskTemplates.isNotEmpty
      ? initialMainTaskTemplates[0].id
      : null;
  int _apiKeyIndex = 0;
  Map<String, ActiveTimerInfo> _activeTimers = {};

  bool _hasUnsavedChanges = false;
  bool _isManuallySaving = false;
  bool get isManuallySaving => _isManuallySaving;
  bool _isManuallyLoading = false;
  bool get isManuallyLoading => _isManuallyLoading;
  DateTime? _lastSuccessfulSaveTimestamp;
  DateTime? get lastSuccessfulSaveTimestamp => _lastSuccessfulSaveTimestamp;

  bool _isGeneratingGlobalContent = false;
  bool get isGeneratingContent => _isGeneratingGlobalContent;
  bool _isGeneratingSubquestsForTask = false;
  bool get isGeneratingSubquests => _isGeneratingSubquestsForTask;

  double _aiGenerationProgress = 0.0;
  double get aiGenerationProgress => _aiGenerationProgress;
  String _aiGenerationStatusMessage = "";
  String get aiGenerationStatusMessage => _aiGenerationStatusMessage;

  // Park Management State
  List<DinosaurSpecies> _dinosaurSpeciesList = [];
  List<BuildingTemplate> _buildingTemplatesList = [];
  List<OwnedBuilding> _ownedBuildings = [];
  List<OwnedDinosaur> _ownedDinosaurs = [];
  List<FossilRecord> _fossilRecords = [];
  ParkManager _parkManager = ParkManager();

  List<DinosaurSpecies> get dinosaurSpeciesList => _dinosaurSpeciesList;
  List<BuildingTemplate> get buildingTemplatesList => _buildingTemplatesList;
  List<OwnedBuilding> get ownedBuildings => _ownedBuildings;
  List<OwnedDinosaur> get ownedDinosaurs => _ownedDinosaurs;
  List<FossilRecord> get fossilRecords => _fossilRecords;
  ParkManager get parkManager => _parkManager;
  ParkActions get parkActions => _parkActions;

  String? get lastLoginDate => _lastLoginDate;
  double get coins => _coins;
  double get xp => _xp;
  int get playerLevel => _playerLevel;
  double get playerEnergy => _playerEnergy;
  List<MainTask> get mainTasks => _mainTasks;
  Map<String, dynamic> get completedByDay => _completedByDay;
  List<OwnedArtifact> get artifacts => _artifacts;
  List<ArtifactTemplate> get artifactTemplatesList => _artifactTemplatesList;
  List<EnemyTemplate> get enemyTemplatesList => _enemyTemplatesList;
  List<GameLocation> get gameLocationsList =>
      _gameLocationsList; // Getter for locations
  List<Rune> get runeTemplatesList => _runeTemplatesList;
  List<OwnedRune> get ownedRunes => _ownedRunes;

  Map<String, PlayerStat> get playerGameStats => _playerGameStats;
  Map<String, String?> get equippedItems => _equippedItems;
  Map<String, String?> get equippedRunes => _equippedRunes;

  List<String> get defeatedEnemyIds => _defeatedEnemyIds;
  CurrentGame get currentGame => _currentGame;
  GameSettings get settings => _settings;
  String get currentView => _currentView;
  String? get selectedTaskId => _selectedTaskId;
  int get apiKeyIndex => _apiKeyIndex;
  Map<String, ActiveTimerInfo> get activeTimers => _activeTimers;

  double get calculatedMaxEnergy =>
      baseMaxPlayerEnergy + (_playerLevel - 1) * playerEnergyPerLevelVitality;
  double get xpNeededForNextLevel =>
      helper.xpToNext(_playerLevel, xpPerLevelBase, xpLevelMultiplier);
  double get currentLevelXPStart =>
      helper.xpForLevel(_playerLevel, xpPerLevelBase, xpLevelMultiplier);
  double get currentLevelXPProgress => _xp - currentLevelXPStart;
  double get xpProgressPercent => xpNeededForNextLevel > 0
      ? (currentLevelXPProgress / xpNeededForNextLevel).clamp(0.0, 1.0) * 100
      : 0;

  TimeOfDay get wakeupTime => TimeOfDay(hour: _settings.wakeupTimeHour, minute: _settings.wakeupTimeMinute);


  late final TaskActions _taskActions;
  late final ItemActions _itemActions;
  late final CombatActions _combatActions;
  late final AIGenerationActions _aiGenerationActions;
  late final TimerActions _timerActions;
  late final ParkActions _parkActions;

  GameProvider() {
    print("[GameProvider] Constructor called. Initializing actions first...");
    // Initialize actions first to prevent LateInitializationError from async callbacks
    _taskActions = TaskActions(this);
    _itemActions = ItemActions(this);
    _combatActions = CombatActions(this);
    _aiGenerationActions = AIGenerationActions(this);
    _timerActions = TimerActions(this);
    _parkActions = ParkActions(this);

    print("[GameProvider] Actions initialized. Ensuring bonusXPModStat...");
    _ensureBonusXpModStat();

    print("[GameProvider] Initializing core systems and listeners...");
    _initialize(); // Now call initialize, which sets up listeners

    _periodicUiTimer?.cancel();
    _periodicUiTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_activeTimers.values.any((info) => info.isRunning)) {
        notifyListeners();
      }
    });

    _parkUpdateTimer?.cancel();
    _parkUpdateTimer = Timer.periodic(const Duration(minutes: 1), (timer) {
      _parkActions
          .updateAllDinosaursStatus(); // Periodically update dinosaur needs
      _parkActions
          .recalculateParkStats(); // This also calls _updateBuildingOperationalStatusBasedOnPower and updates income/costs
    });
    print("[GameProvider] Initialization complete.");
  }

  @override
  void dispose() {
    print("[GameProvider] dispose called.");
    _periodicUiTimer?.cancel();
    _autoSaveTimer?.cancel();
    _parkUpdateTimer?.cancel();
    super.dispose();
  }

  Future<void> _initialize() async {
    // Made async
    fb_service.authStateChanges.listen(_onAuthStateChanged);
    _autoSaveTimer?.cancel();
    _autoSaveTimer = Timer.periodic(const Duration(minutes: 1), (timer) {
      if (_hasUnsavedChanges &&
          _currentUser != null &&
          !_isManuallySaving &&
          !_isManuallyLoading) {
        print("[GameProvider] Auto-saving changes...");
        _performActualSave();
      }
    });
  }

  Future<void> _onAuthStateChanged(User? user) async {
    print("[GameProvider] _onAuthStateChanged triggered. User: ${user?.uid}");
    if (_authLoading &&
        _currentUser != null &&
        user != null &&
        _currentUser!.uid == user.uid) {
      print("[GameProvider] Auth state unchanged for same user, returning.");
      return;
    }

    _authLoading = true;
    notifyListeners();

    if (user != null) {
      print("[GameProvider] User signed in: ${user.uid}. Loading data...");
      _currentUser = user;
      _isDataLoadingAfterLogin = true;
      notifyListeners();

      final data = await _storageService.getUserData(user.uid);
      if (data != null) {
        print("[GameProvider] User data found, loading state.");
        _loadStateFromMap(data);
        _hasUnsavedChanges = false; // Data is in sync with cloud after load
        _handleDailyReset(); // Handle daily reset logic which includes potential content generation
      } else {
        print("[GameProvider] No user data found, resetting to initial state.");
        await _resetToInitialState(); // Make reset async if it involves async ops
        _lastLoginDate = helper.getTodayDateString(); // Set login date for new user
        _hasUnsavedChanges = true; // Mark as changed to trigger initial save
        if (settings.dailyAutoGenerateContent) { // Use new setting name
          print("[GameProvider] Initial content generation for new user.");
          // Don't await this if it blocks UI too much, let it run in background
          _aiGenerationActions
              .generateGameContent(_playerLevel, isManual: false, isInitial: true, contentType: "all")
              .catchError((e) {
            print("Error during initial content generation: $e");
          }).whenComplete(() => _performActualSave()); // Save after initial content is generated
        } else {
          await _performActualSave(); // Save immediately if no initial content generation
        }
        _handleDailyReset(); // Call daily reset even for new user to set up daily state
      }

      if (_currentUser?.displayName == null ||
          _currentUser!.displayName!.trim().isEmpty) {
        print("[GameProvider] Username is missing for current user.");
        _isUsernameMissing = true;
      } else {
        _isUsernameMissing = false;
      }
      _isDataLoadingAfterLogin = false;
    } else {
      print("[GameProvider] User signed out or null. Resetting state.");
      _currentUser = null;
      await _resetToInitialState(); // Make reset async
      _isDataLoadingAfterLogin = false;
      _hasUnsavedChanges = false;
    }

    _authLoading = false;
    notifyListeners();
    print(
        "[GameProvider] _onAuthStateChanged finished. AuthLoading: $_authLoading, IsDataLoadingAfterLogin: $_isDataLoadingAfterLogin");
  }

  Map<String, dynamic> _gameStateToMap() {
    return {
      'lastLoginDate': _lastLoginDate,
      'coins': _coins,
      'xp': _xp,
      'playerLevel': _playerLevel,
      'playerEnergy': _playerEnergy,
      'mainTasks': _mainTasks.map((mt) => mt.toJson()).toList(),
      'completedByDay': _completedByDay,
      'artifacts': _artifacts.map((a) => a.toJson()).toList(),
      'artifactTemplatesList':
          _artifactTemplatesList.map((at) => at.toJson()).toList(),
      'enemyTemplatesList':
          _enemyTemplatesList.map((et) => et.toJson()).toList(),
      'gameLocationsList': _gameLocationsList
          .map((gl) => gl.toJson())
          .toList(), // Save locations
      'runeTemplatesList': _runeTemplatesList.map((rt) => rt.toJson()).toList(),
      'ownedRunes': _ownedRunes.map((or) => or.toJson()).toList(),
      'playerGameStats':
          _playerGameStats.map((key, stat) => MapEntry(key, stat.toJson())),
      'equippedItems': _equippedItems,
      'equippedRunes': _equippedRunes,
      'defeatedEnemyIds': _defeatedEnemyIds,
      'clearedLocationIds': _clearedLocationIds, // Save cleared locations
      'currentGame': _currentGame.toJson(),
      'settings': settings.toJson(),
      'currentView': _currentView,
      'selectedTaskId': _selectedTaskId,
      'apiKeyIndex': _apiKeyIndex,
      'activeTimers':
          _activeTimers.map((key, value) => MapEntry(key, value.toJson())),
      'lastSuccessfulSaveTimestamp':
          _lastSuccessfulSaveTimestamp?.toIso8601String(),
      // Park Management Data
      'dinosaurSpeciesList':
          _dinosaurSpeciesList.map((ds) => ds.toJson()).toList(),
      'buildingTemplatesList':
          _buildingTemplatesList.map((bt) => bt.toJson()).toList(),
      'ownedBuildings': _ownedBuildings.map((ob) => ob.toJson()).toList(),
      'ownedDinosaurs': _ownedDinosaurs.map((od) => od.toJson()).toList(),
      'fossilRecords': _fossilRecords.map((fr) => fr.toJson()).toList(),
      'parkManager': _parkManager.toJson(),
    };
  }

  void _loadStateFromMap(Map<String, dynamic> data) {
    print("[GameProvider] Loading state from map: ${data.keys.toList()}");
    _lastLoginDate = data['lastLoginDate'] as String?;
    _coins = (data['coins'] as num? ?? 100).toDouble();
    _xp = (data['xp'] as num? ?? 0).toDouble();
    _playerLevel = data['playerLevel'] as int? ?? 1;
    _playerEnergy =
        (data['playerEnergy'] as num? ?? baseMaxPlayerEnergy).toDouble();

    _mainTasks = (data['mainTasks'] as List<dynamic>?)
            ?.map((mtJson) => MainTask.fromJson(mtJson as Map<String, dynamic>))
            .toList() ??
        initialMainTaskTemplates.map((t) => MainTask.fromTemplate(t)).toList();

    _completedByDay = data['completedByDay'] as Map<String, dynamic>? ?? {};
    _completedByDay.forEach((date, dayDataMap) {
      if (dayDataMap is Map<String, dynamic>) {
        dayDataMap.putIfAbsent('taskTimes', () => <String, int>{});
        dayDataMap.putIfAbsent(
            'subtasksCompleted', () => <Map<String, dynamic>>[]);
        dayDataMap.putIfAbsent(
            'checkpointsCompleted', () => <Map<String, dynamic>>[]);
        dayDataMap.putIfAbsent('emotionLogs', () => <Map<String, dynamic>>[]); // Initialize emotionLogs
      }
    });

    _artifacts = (data['artifacts'] as List<dynamic>?)
            ?.map((aJson) =>
                OwnedArtifact.fromJson(aJson as Map<String, dynamic>))
            .toList() ??
        [];

    _artifactTemplatesList = (data['artifactTemplatesList'] as List<dynamic>?)
            ?.map((atJson) =>
                ArtifactTemplate.fromJson(atJson as Map<String, dynamic>))
            .toList() ??
        initialArtifactTemplates; // Use initial if not present

    _enemyTemplatesList = (data['enemyTemplatesList'] as List<dynamic>?)
            ?.map((etJson) =>
                EnemyTemplate.fromJson(etJson as Map<String, dynamic>))
            .toList() ??
        initialEnemyTemplates; // Use initial if not present

    _gameLocationsList = (data['gameLocationsList'] as List<dynamic>?)
            ?.map((glJson) =>
                GameLocation.fromJson(glJson as Map<String, dynamic>))
            .toList() ??
        initialGameLocations; // Use initial if not present

    _runeTemplatesList = (data['runeTemplatesList'] as List<dynamic>?)
            ?.map((rtJson) => Rune.fromJson(rtJson as Map<String, dynamic>))
            .toList() ??
        [];
    _ownedRunes = (data['ownedRunes'] as List<dynamic>?)
            ?.map(
                (orJson) => OwnedRune.fromJson(orJson as Map<String, dynamic>))
            .toList() ??
        [];

    final statsData = data['playerGameStats'] as Map<String, dynamic>?;
    _playerGameStats = {
      ...Map.from(basePlayerGameStats.map((key, value) => MapEntry(
          key,
          PlayerStat(
              name: value.name,
              description: value.description,
              icon: value.icon,
              value: value.value,
              base: value.base)))),
    };
    _ensureBonusXpModStat();

    if (statsData != null) {
      statsData.forEach((String key, dynamic statJsonValue) {
        if (_playerGameStats.containsKey(key) &&
            statJsonValue is Map<String, dynamic>) {
          _playerGameStats[key] = PlayerStat.fromJson(statJsonValue);
        } else if (!_playerGameStats.containsKey(key) &&
            statJsonValue is Map<String, dynamic> &&
            key == 'bonusXPMod') {
          _playerGameStats[key] = PlayerStat.fromJson(statJsonValue);
        }
      });
    }

    _equippedItems = Map<String, String?>.from(
        data['equippedItems'] as Map<dynamic, dynamic>? ??
            {'weapon': null, 'armor': null, 'talisman': null});
    _equippedRunes = Map<String, String?>.from(
        data['equippedRunes'] as Map<dynamic, dynamic>? ??
            {'rune_slot_1': null, 'rune_slot_2': null});
    _defeatedEnemyIds = (data['defeatedEnemyIds'] as List<dynamic>?)
            ?.map((id) => id as String)
            .toList() ??
        [];
    _clearedLocationIds = (data['clearedLocationIds'] as List<dynamic>?)
            ?.map((id) => id as String)
            .toList() ??
        []; // Load cleared locations

    _currentGame = data['currentGame'] != null
        ? CurrentGame.fromJson(
            data['currentGame'] as Map<String, dynamic>, _enemyTemplatesList)
        : CurrentGame(
            playerCurrentHp: _playerGameStats['vitality']!.value,
            currentPlaceKey: _gameLocationsList.isNotEmpty
                ? _gameLocationsList.first.id
                : null);

    // Ensure currentPlaceKey is valid
    if (_currentGame.currentPlaceKey == null && _gameLocationsList.isNotEmpty) {
      _currentGame.currentPlaceKey = _gameLocationsList.first.id;
    } else if (_currentGame.currentPlaceKey != null &&
        !_gameLocationsList
            .any((loc) => loc.id == _currentGame.currentPlaceKey)) {
      _currentGame.currentPlaceKey =
          _gameLocationsList.isNotEmpty ? _gameLocationsList.first.id : null;
    }

    _settings = data['settings'] != null
        ? GameSettings.fromJson(data['settings'] as Map<String, dynamic>)
        : GameSettings();

    _currentView = data['currentView'] as String? ?? 'task-details';
    _selectedTaskId = data['selectedTaskId'] as String? ??
        (_mainTasks.isNotEmpty ? _mainTasks[0].id : null);
    _apiKeyIndex = data['apiKeyIndex'] as int? ?? 0;

    _activeTimers = (data['activeTimers'] as Map<String, dynamic>?)?.map(
            (key, value) => MapEntry(key,
                ActiveTimerInfo.fromJson(value as Map<String, dynamic>))) ??
        {};

    final timestampString = data['lastSuccessfulSaveTimestamp'] as String?;
    _lastSuccessfulSaveTimestamp =
        timestampString != null ? DateTime.tryParse(timestampString) : null;

    // Park Management Data Loading
    _dinosaurSpeciesList = (data['dinosaurSpeciesList'] as List<dynamic>?)
            ?.map((dsJson) =>
                DinosaurSpecies.fromJson(dsJson as Map<String, dynamic>))
            .toList() ??
        initialDinosaurSpecies;
    _buildingTemplatesList = (data['buildingTemplatesList'] as List<dynamic>?)
            ?.map((btJson) =>
                BuildingTemplate.fromJson(btJson as Map<String, dynamic>))
            .toList() ??
        initialBuildingTemplates;
    _ownedBuildings = (data['ownedBuildings'] as List<dynamic>?)
            ?.map((obJson) =>
                OwnedBuilding.fromJson(obJson as Map<String, dynamic>))
            .toList() ??
        [];
    _ownedDinosaurs = (data['ownedDinosaurs'] as List<dynamic>?)
            ?.map((odJson) =>
                OwnedDinosaur.fromJson(odJson as Map<String, dynamic>))
            .toList() ??
        [];
    _fossilRecords = (data['fossilRecords'] as List<dynamic>?)
            ?.map((frJson) =>
                FossilRecord.fromJson(frJson as Map<String, dynamic>))
            .toList() ??
        [];
    // Ensure fossil records list matches species list
    if (_fossilRecords.length != _dinosaurSpeciesList.length) {
      _fossilRecords = _dinosaurSpeciesList
          .map((species) => _fossilRecords.firstWhere(
              (fr) => fr.speciesId == species.id,
              orElse: () => FossilRecord(speciesId: species.id)))
          .toList();
    }

    _parkManager = data['parkManager'] != null
        ? ParkManager.fromJson(data['parkManager'] as Map<String, dynamic>)
        : ParkManager();

    _recalculatePlayerLevel();
    _updatePlayerStatsFromItemsAndRunes();
    _parkActions.recalculateParkStats(); // Recalculate park stats after loading
    print(
        "[GameProvider] State loaded. Current XP: $_xp, Level: $_playerLevel");
  }

  Future<void> _resetToInitialState() async {
    // Make async
    print("[GameProvider] Resetting to initial state.");
    _lastLoginDate = null;
    _coins = 100;
    _xp = 0;
    _playerLevel = 1;
    _playerEnergy = baseMaxPlayerEnergy;
    _mainTasks =
        initialMainTaskTemplates.map((t) => MainTask.fromTemplate(t)).toList();
    _completedByDay = {};
    _artifacts = [];

    // Potentially load these from assets async if they become large
    _artifactTemplatesList = List.from(initialArtifactTemplates);
    _enemyTemplatesList = List.from(initialEnemyTemplates);
    _gameLocationsList = List.from(initialGameLocations);

    _runeTemplatesList = [];
    _ownedRunes = [];
    _playerGameStats = {
      ...Map.from(basePlayerGameStats.map((key, value) => MapEntry(
          key,
          PlayerStat(
              name: value.name,
              description: value.description,
              icon: value.icon,
              value: value.value,
              base: value.base)))),
    };
    _ensureBonusXpModStat();
    _equippedItems = {'weapon': null, 'armor': null, 'talisman': null};
    _equippedRunes = {'rune_slot_1': null, 'rune_slot_2': null};
    _defeatedEnemyIds = [];
    _clearedLocationIds = []; // Reset cleared locations
    _currentGame = CurrentGame(
        playerCurrentHp: _playerGameStats['vitality']!.value,
        currentPlaceKey:
            _gameLocationsList.isNotEmpty ? _gameLocationsList.first.id : null);
    _settings = GameSettings();
    _currentView = 'task-details';
    _selectedTaskId = _mainTasks.isNotEmpty ? _mainTasks[0].id : null;
    _apiKeyIndex = 0;
    _activeTimers = {};
    _isUsernameMissing = false;
    _lastSuccessfulSaveTimestamp = null;

    // Park Management Reset
    _dinosaurSpeciesList = List.from(initialDinosaurSpecies);
    _buildingTemplatesList = List.from(initialBuildingTemplates);
    _ownedBuildings = [];
    _ownedDinosaurs = [];
    _fossilRecords = _dinosaurSpeciesList
        .map((species) => FossilRecord(speciesId: species.id))
        .toList();
    _parkManager = ParkManager(
        parkDollars: 50000,
        parkEnergy: _playerEnergy,
        maxParkEnergy:
            calculatedMaxEnergy); // Start with some dollars and link park energy to player energy

    _hasUnsavedChanges = true;

    final rustySword = _artifactTemplatesList
        .firstWhereOrNull((art) => art.id == "art_rusty_sword");
    if (rustySword != null) {
      _artifacts.add(OwnedArtifact(
          uniqueId: "owned_${rustySword.id}_init",
          templateId: rustySword.id,
          currentLevel: 1));
      _equippedItems['weapon'] = "owned_${rustySword.id}_init";
    }
    final leatherJerkin = _artifactTemplatesList
        .firstWhereOrNull((art) => art.id == "art_leather_jerkin");
    if (leatherJerkin != null) {
      _artifacts.add(OwnedArtifact(
          uniqueId: "owned_${leatherJerkin.id}_init",
          templateId: leatherJerkin.id,
          currentLevel: 1));
      _equippedItems['armor'] = "owned_${leatherJerkin.id}_init";
    }
    _updatePlayerStatsFromItemsAndRunes();
    _parkActions.recalculateParkStats(); // Recalculate park stats after reset
    print("[GameProvider] Initial state reset complete.");
  }

  Future<void> _performActualSave() async {
    if (_currentUser != null) {
      print(
          "[GameProvider] Performing actual save to Firestore for user ${_currentUser!.uid}");
      final success = await _storageService.setUserData(_currentUser!.uid,
          _gameStateToMap()); // Changed to setUserData for full overwrite
      if (success) {
        _lastSuccessfulSaveTimestamp = DateTime.now();
        _hasUnsavedChanges = false;
        notifyListeners(); // To update UI with new save timestamp if displayed
        print(
            "[GameProvider] Save successful. Timestamp: $_lastSuccessfulSaveTimestamp");
      } else {
        print("[GameProvider] Save FAILED.");
        // Optionally, add a log to the game's UI log about save failure
        setProviderState(
            currentGame: CurrentGame(
              enemy: _currentGame.enemy,
              playerCurrentHp: _currentGame.playerCurrentHp,
              log: [
                ..._currentGame.log,
                "<span style=\"color:${AppTheme.fhAccentRed.value.toRadixString(16).substring(2)};\">Critical Error: Failed to save game data to cloud!</span>"
              ],
              currentPlaceKey: _currentGame.currentPlaceKey,
            ),
            doPersist: false, // Don't try to re-save immediately
            doNotify: true);
      }
    } else {
      print("[GameProvider] Cannot save, no current user.");
    }
  }

  Future<void> manuallySaveToCloud() async {
    if (_currentUser == null) throw Exception("Not logged in. Cannot save.");
    print("[GameProvider] Manually saving to cloud...");
    _isManuallySaving = true;
    notifyListeners();
    try {
      await _performActualSave();
    } finally {
      _isManuallySaving = false;
      notifyListeners();
      print("[GameProvider] Manual save finished.");
    }
  }

  Future<void> manuallyLoadFromCloud() async {
    if (_currentUser == null) throw Exception("Not logged in. Cannot load.");
    print("[GameProvider] Manually loading from cloud...");
    _isManuallyLoading = true;
    notifyListeners();
    try {
      final data = await _storageService.getUserData(_currentUser!.uid);
      if (data != null) {
        _loadStateFromMap(data);
        _handleDailyReset(); // Call daily reset after loading data
        // No specific auto-generation here; daily reset handles it if enabled.
        if (_currentUser?.displayName == null ||
            _currentUser!.displayName!.trim().isEmpty) {
          _isUsernameMissing = true;
        } else {
          _isUsernameMissing = false;
        }
        _hasUnsavedChanges = false; // Data is now in sync with cloud
      } else {
        throw Exception("No data found on cloud.");
      }
    } finally {
      _isManuallyLoading = false;
      notifyListeners();
      print("[GameProvider] Manual load finished.");
    }
  }

  Future<void> loginUser(String email, String password) async {
    print("[GameProvider] Attempting login for email: $email");
    await fb_service.signInWithEmail(email, password);
  }

  Future<void> signupUser(
      String email, String password, String username) async {
    print(
        "[GameProvider] Attempting signup for email: $email, username: $username");
    _authLoading = true;
    notifyListeners();
    try {
      UserCredential userCredential =
          await fb_service.firebaseAuthInstance.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );
      _currentUser = userCredential.user;
      if (_currentUser != null) {
        print(
            "[GameProvider] Signup successful, user UID: ${_currentUser!.uid}. Updating display name.");
        await _currentUser!.updateDisplayName(username);
        await _currentUser!.reload();
        _currentUser =
            fb_service.firebaseAuthInstance.currentUser; // Refresh user object

        await _resetToInitialState(); // Make reset async
        _lastLoginDate = helper.getTodayDateString();
        _hasUnsavedChanges = true; // Mark for initial save
        // Trigger initial content generation if daily auto-generate is on
        if (settings.dailyAutoGenerateContent) { 
          print("[GameProvider] Initial content generation for new user after signup.");
           _aiGenerationActions
              .generateGameContent(_playerLevel, isManual: false, isInitial: true, contentType: "all")
              .catchError((e) {
            print("Error during signup initial content generation: $e");
          }).whenComplete(() => _performActualSave());
        } else {
            await _performActualSave();
        }
        
        _handleDailyReset();
        _isDataLoadingAfterLogin = false;
        _isUsernameMissing = false;
        print(
            "[GameProvider] Signup and initial setup complete for user: $username");
      } else {
        throw Exception("Signup successful but user object is null.");
      }
    } catch (e) {
      _currentUser = null;
      print("[GameProvider] Signup failed: $e");
      rethrow;
    } finally {
      _authLoading = false;
      notifyListeners();
    }
  }

  Future<void> logoutUser() async {
    print("[GameProvider] Logging out user...");
    if (_hasUnsavedChanges && _currentUser != null) {
      print("[GameProvider] Saving unsaved changes before logout.");
      await _performActualSave();
    }
    try {
      await fb_service.signOut();
      print("[GameProvider] User signed out successfully.");
    } catch (e) {
      print("[GameProvider] Error during sign out: $e");
      rethrow;
    }
  }

  Future<void> changePasswordHandler(String newPassword) async {
    if (_currentUser != null) {
      print(
          "[GameProvider] Attempting to change password for user ${_currentUser!.uid}");
      await fb_service.changePassword(newPassword);
      _hasUnsavedChanges = true;
      notifyListeners();
      print("[GameProvider] Password change successful (client-side).");
    } else {
      throw Exception("No user is currently signed in.");
    }
  }

  Future<void> updateUserDisplayName(String newUsername) async {
    if (_currentUser != null) {
      print(
          "[GameProvider] Updating display name to '$newUsername' for user ${_currentUser!.uid}");
      await _currentUser!.updateDisplayName(newUsername);
      await _currentUser!.reload();
      _currentUser = fb_service.firebaseAuthInstance.currentUser;

      _isUsernameMissing = false;
      _hasUnsavedChanges = true;
      notifyListeners();
      await _performActualSave();
      print("[GameProvider] Display name updated and saved.");
    }
  }

  void setCurrentView(String view) {
    if (_currentView != view) {
      print(
          "[GameProvider] Setting current view from '$_currentView' to '$view'");
      _currentView = view;
      _hasUnsavedChanges = true;
      notifyListeners();
    }
  }

  void setSelectedTaskId(String? taskId) {
    if (_selectedTaskId != taskId) {
      print(
          "[GameProvider] Setting selected task ID from '$_selectedTaskId' to '$taskId'");
      _selectedTaskId = taskId;
      _hasUnsavedChanges = true;
      notifyListeners();
    }
  }

  void setSettings(GameSettings newSettings) {
    _settings = newSettings;
    _hasUnsavedChanges = true;
    notifyListeners();
    print(
        "[GameProvider] Settings updated. DescriptionsVisible: ${newSettings.descriptionsVisible}, DailyAutoGenerate: ${newSettings.dailyAutoGenerateContent}, Wakeup: ${newSettings.wakeupTimeHour}:${newSettings.wakeupTimeMinute}");
  }

  String romanize(int num) => num.toString(); // Changed to common numbering

  MainTask? getSelectedTask() {
    if (_selectedTaskId == null) {
      return _mainTasks.firstOrNull;
    }
    return _mainTasks.firstWhereOrNull((t) => t.id == _selectedTaskId) ??
        _mainTasks.firstOrNull;
  }

  void _recalculatePlayerLevel() {
    int newLevel = 1;
    double xpAtStartOfLvl = 0;
    while (true) {
      final double xpNeeded =
          helper.xpToNext(newLevel, xpPerLevelBase, xpLevelMultiplier);
      if (_xp >= xpAtStartOfLvl + xpNeeded) {
        xpAtStartOfLvl += xpNeeded;
        newLevel++;
      } else {
        break;
      }
    }
    if (_playerLevel != newLevel) {
      final oldLevel = _playerLevel;
      _playerLevel = newLevel;
      print(
          "[GameProvider] Player level changed from $oldLevel to $_playerLevel. XP: $_xp");
      if (_playerLevel > oldLevel) {
        _handleLevelUpEffect();
      } else {
        _hasUnsavedChanges = true;
        notifyListeners();
      }
    }
  }

  void _handleLevelUpEffect() {
    if (_currentUser == null) return;
    print(
        "[GameProvider] Player leveled up to $_playerLevel! Handling effects.");

    const double strengthIncreasePerLevel = 0.5;
    const double defenseIncreasePerLevel = 0.3;
    const double runicIncreasePerLevel = 0.25;

    _playerGameStats['vitality']!.base = basePlayerGameStats['vitality']!.base +
        ((_playerLevel - 1) * playerEnergyPerLevelVitality);
    _playerGameStats['strength']!.base = basePlayerGameStats['strength']!.base +
        ((_playerLevel - 1) * strengthIncreasePerLevel).roundToDouble();
    _playerGameStats['defense']!.base = basePlayerGameStats['defense']!.base +
        ((_playerLevel - 1) * defenseIncreasePerLevel).roundToDouble();
    _playerGameStats['runic']!.base = basePlayerGameStats['runic']!.base +
        ((_playerLevel - 1) * runicIncreasePerLevel).roundToDouble();

    _updatePlayerStatsFromItemsAndRunes();

    _playerEnergy = calculatedMaxEnergy;
    _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;

    _currentGame.log = [
        ..._currentGame.log,
        "<span style=\"color:#${(getSelectedTask()?.taskColor ?? AppTheme.fhAccentTealFixed).value.toRadixString(16).substring(2)}\">You feel a surge of power! Level up to $_playerLevel.</span>"
      ];
    
    _hasUnsavedChanges = true;
    notifyListeners();
  }

  Future<void> _handleDailyReset() async {
    if (_currentUser == null) return;
    final today = helper.getTodayDateString();
    bool hasResetRun = false;

    if (_lastLoginDate != today) {
      print("[GameProvider] Daily reset triggered. Last login: $_lastLoginDate, Today: $today");
      hasResetRun = true;
      _mainTasks = _mainTasks.map((task) {
        int newStreak = task.streak;
        if (_lastLoginDate != null) {
          final yesterday = DateTime.now().subtract(const Duration(days: 1));
          final yesterdayStr = DateFormat('yyyy-MM-dd').format(yesterday);
          if (task.dailyTimeSpent < dailyTaskGoalMinutes &&
              task.lastWorkedDate != null &&
              task.lastWorkedDate != today &&
              task.lastWorkedDate != yesterdayStr) {
            newStreak = 0;
            print("[GameProvider] Task '${task.name}' streak reset due to inactivity.");
          }
        }
        return MainTask(
          id: task.id,
          name: task.name,
          description: task.description,
          theme: task.theme,
          colorHex: task.colorHex,
          streak: newStreak,
          dailyTimeSpent: 0,
          lastWorkedDate: task.lastWorkedDate,
          subTasks: task.subTasks,
        );
      }).toList();

      _playerEnergy = calculatedMaxEnergy;
      _defeatedEnemyIds = []; // Reset defeated enemies for the day
      _clearedLocationIds = []; // Reset cleared locations for the day
      _lastLoginDate = today;
      _hasUnsavedChanges = true; // Mark changes for saving
      scheduleEmotionReminders(); // Re-schedule reminders for the new day
      print("[GameProvider] Daily reset applied. Player energy restored. Streaks updated.");
    }

    if (settings.dailyAutoGenerateContent && hasResetRun) { // Only run auto-gen if a daily reset actually occurred
      print("[GameProvider] Daily auto-generation triggered.");
      String? currentLocationId = _currentGame.currentPlaceKey;
      bool currentRealmPacified = false;

      if (currentLocationId != null) {
        final enemiesInLocation = _enemyTemplatesList.where((e) => e.locationKey == currentLocationId).toList();
        if (enemiesInLocation.isNotEmpty && enemiesInLocation.every((e) => _defeatedEnemyIds.contains(e.id))) {
          currentRealmPacified = true;
          print("[GameProvider] Current realm '$currentLocationId' is pacified.");
        }
      }

      if (currentLocationId == null || currentRealmPacified) {
        if (currentLocationId != null && currentRealmPacified) {
          _gameLocationsList.removeWhere((loc) => loc.id == currentLocationId);
          _clearedLocationIds.removeWhere((id) => id == currentLocationId);
           _currentGame.log.add("<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">Realm '$currentLocationId' pacified and archived.</span>");
          print("[GameProvider] Pacified realm '$currentLocationId' removed.");
        }
        
        print("[GameProvider] Generating a new realm due to daily reset or pacified current realm.");
        await _aiGenerationActions.generateGameContent(
            _playerLevel, isManual: false, isInitial: false, contentType: "locations", numLocationsToGenerate: 1); // generate 1 new location
        
        // Select the newly generated or first available realm
        if (_gameLocationsList.isNotEmpty) {
            currentLocationId = _gameLocationsList.where((loc) => !_clearedLocationIds.contains(loc.id)).firstOrNull?.id ?? _gameLocationsList.first.id;
        } else {
            currentLocationId = null; // No locations available
        }
        _currentGame.currentPlaceKey = currentLocationId;
         _hasUnsavedChanges = true; // Mark changes for saving
      }
      
      if (currentLocationId != null) {
        print("[GameProvider] Generating new enemies for realm '$currentLocationId'.");
        await _aiGenerationActions.generateGameContent(
            _playerLevel, isManual: false, isInitial: false, contentType: "enemies", numEnemiesToGenerate: 3, specificLocationKeyForEnemies: currentLocationId); // generate 3 enemies for current/new location
      } else {
        print("[GameProvider] No active realm to populate with new threats after daily reset.");
         _currentGame.log.add("<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">No active realm available for new threats.</span>");
      }
    }
    if (hasResetRun) notifyListeners(); // Notify at the end if any reset or generation happened
  }


  void _updatePlayerStatsFromItemsAndRunes() {
    final Map<String, PlayerStat> newStats = {
      ...Map.from(basePlayerGameStats.map((key, bs) => MapEntry(
          key,
          PlayerStat(
              name: bs.name,
              base: bs.base,
              value: bs.base,
              description: bs.description,
              icon: bs.icon)))),
    };
    _ensureBonusXpModStat();
    if (!newStats.containsKey('bonusXPMod')) {
      newStats['bonusXPMod'] = PlayerStat(
          name: 'XP CALC MOD',
          value: 0,
          base: 0,
          description: 'Internal XP modifier from gear.',
          icon: 'mdi-percent-outline');
    }

    const double strengthIncreasePerLevel = 0.5;
    const double defenseIncreasePerLevel = 0.3;
    const double runicIncreasePerLevel = 0.25;

    newStats['vitality']!.base = basePlayerGameStats['vitality']!.base +
        ((_playerLevel - 1) * playerEnergyPerLevelVitality);
    newStats['strength']!.base = basePlayerGameStats['strength']!.base +
        ((_playerLevel - 1) * strengthIncreasePerLevel).roundToDouble();
    newStats['defense']!.base = basePlayerGameStats['defense']!.base +
        ((_playerLevel - 1) * defenseIncreasePerLevel).roundToDouble();
    newStats['runic']!.base = basePlayerGameStats['runic']!.base +
        ((_playerLevel - 1) * runicIncreasePerLevel).roundToDouble();

    newStats.forEach((key, stat) {
      stat.value = stat.base;
    });

    _equippedItems.forEach((slot, uniqueId) {
      if (uniqueId != null) {
        final owned =
            _artifacts.firstWhereOrNull((art) => art.uniqueId == uniqueId);
        if (owned != null) {
          final template = _artifactTemplatesList
              .firstWhereOrNull((t) => t.id == owned.templateId);
          if (template != null && template.type != 'powerup') {
            final effective = _itemActions.getArtifactEffectiveStats(owned);
            newStats['strength']!.value += effective.baseAtt ?? 0;
            newStats['defense']!.value += effective.baseDef ?? 0;
            newStats['vitality']!.value += effective.baseHealth ?? 0;
            newStats['runic']!.value += effective.baseRunic ?? 0;
            newStats['luck']!.value += effective.baseLuck?.toDouble() ?? 0;
            newStats['cooldown']!.value +=
                effective.baseCooldown?.toDouble() ?? 0;
            newStats['bonusXPMod']!.value += effective.bonusXPMod ?? 0.0;
          }
        }
      }
    });

    _equippedRunes.forEach((slot, uniqueOwnedRuneId) {
      if (uniqueOwnedRuneId != null) {
        final ownedRune = _ownedRunes
            .firstWhereOrNull((or) => or.uniqueId == uniqueOwnedRuneId);
        if (ownedRune != null) {
          final runeTemplate = _runeTemplatesList
              .firstWhereOrNull((rt) => rt.id == ownedRune.runeId);
          if (runeTemplate != null && runeTemplate.type.contains("passive")) {
            if (runeTemplate.effectType == 'stat_boost' &&
                runeTemplate.targetStat != null &&
                newStats.containsKey(runeTemplate.targetStat!)) {
              newStats[runeTemplate.targetStat!]!.value +=
                  runeTemplate.effectValue;
            }
          }
        }
      }
    });

    newStats['luck']!.value =
        newStats['luck']!.value.clamp(0, double.infinity).toDouble();
    newStats['bonusXPMod']!.value =
        newStats['bonusXPMod']!.value.clamp(0, double.infinity).toDouble();

    _playerGameStats = newStats;

    if (_currentGame.playerCurrentHp > _playerGameStats['vitality']!.value) {
      _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;
    } else if (_currentGame.enemy == null &&
        _currentGame.playerCurrentHp < _playerGameStats['vitality']!.value) {
      _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;
    }
    print(
        "[GameProvider] Player stats updated. Vitality: ${_playerGameStats['vitality']!.value}, Strength: ${_playerGameStats['strength']!.value}");
  }

  bool isLocationUnlocked(String locationId) {
    final location =
        _gameLocationsList.firstWhereOrNull((loc) => loc.id == locationId);
    if (location == null) {
      print(
          "[GameProvider] isLocationUnlocked: Location ID '$locationId' not found.");
      return false;
    }

    if (_playerLevel < location.minPlayerLevelToUnlock) {
      return false;
    }
    return true;
  }

  Future<void> clearAllGameData() async {
    if (_currentUser == null) return;
    print(
        "[GameProvider] Clearing all game data for user ${_currentUser!.uid}");
    await _storageService.deleteUserData(_currentUser!.uid);
    await _resetToInitialState(); // Make reset async
    // After reset, if daily auto-gen is on, an initial populate will happen.
    if (settings.dailyAutoGenerateContent) {
      print("[GameProvider] Generating initial content after data purge.");
      await _aiGenerationActions.generateGameContent(_playerLevel, isManual: false, isInitial: true, contentType: "all");
    }
    await _performActualSave(); // Save the reset (and potentially newly generated) state.
    notifyListeners();
    print("[GameProvider] All game data cleared and reset.");
  }

  Future<void> resetPlayerLevelAndProgress() async {
    if (_currentUser == null) return;
    print("[GameProvider] Resetting player level and progress.");
    _playerLevel = 1;
    _xp = 0;
    _playerGameStats = {
      ...Map.from(basePlayerGameStats.map((key, value) => MapEntry(
          key,
          PlayerStat(
              name: value.name,
              description: value.description,
              icon: value.icon,
              value: value.value,
              base: value.base)))),
    };
    _ensureBonusXpModStat();
    _updatePlayerStatsFromItemsAndRunes();
    _playerEnergy = calculatedMaxEnergy;
    _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;
    _defeatedEnemyIds = [];
    // No specific content generation here as daily reset handles it.
    _currentGame.log = [
      ..._currentGame.log,
      "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">Player level and progress have been reset.</span>"
    ];
    _hasUnsavedChanges = true;
    notifyListeners();
    print("[GameProvider] Player level and progress reset complete.");
  }

  void clearAllArtifactsAndTemplates() {
    if (_currentUser == null) return;
    print("[GameProvider] Clearing all owned artifacts and templates.");
    setProviderState(
      artifacts: [], // Clear owned artifacts
      artifactTemplatesList: [], // Clear artifact templates
      equippedItems: {
        'weapon': null,
        'armor': null,
        'talisman': null
      }, // Unequip all
      currentGame: CurrentGame(
        enemy: _currentGame.enemy,
        playerCurrentHp: _currentGame.playerCurrentHp,
        log: [
          ..._currentGame.log,
          "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">All artifacts and blueprints purged.</span>"
        ],
        currentPlaceKey: _currentGame.currentPlaceKey,
      ),
    );
  }

  Future<void> removeAllGameLocations() async {
    if (_currentUser == null) return;
    print("[GameProvider] Removing all game locations (realms).");
    setProviderState(
      gameLocationsList: [],
      clearedLocationIds: [],
      defeatedEnemyIds: [], // Also clear defeated enemies as realms are gone
      currentGame: CurrentGame(
        enemy: null, // No active enemy if no realms
        playerCurrentHp: _currentGame.playerCurrentHp,
        log: [
          ..._currentGame.log,
          "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">All combat realms decommissioned. The Arena is now empty.</span>"
        ],
        currentPlaceKey: null, // No current place
      ),
    );
  }


  Future<void> clearDiscoverablePowerUps() async {
    if (_currentUser == null) return;
    print("[GameProvider] Clearing discoverable power-ups.");
    final List<String> ownedPowerUpTemplateIds = _artifacts
        .where((owned) {
          final template = _artifactTemplatesList
              .firstWhereOrNull((t) => t.id == owned.templateId);
          return template != null && template.type == 'powerup';
        })
        .map((owned) => owned.templateId)
        .toSet()
        .toList();

    final List<ArtifactTemplate> newArtifactTemplates =
        _artifactTemplatesList.where((template) {
      return template.type != 'powerup' ||
          ownedPowerUpTemplateIds.contains(template.id);
    }).toList();

    setProviderState(
        artifactTemplatesList: newArtifactTemplates,
        currentGame: CurrentGame(
          enemy: _currentGame.enemy,
          playerCurrentHp: _currentGame.playerCurrentHp,
          log: [
            ..._currentGame.log,
            "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">Discoverable power-up schematics purged. Owned items remain.</span>"
          ],
          currentPlaceKey: _currentGame.currentPlaceKey,
        ));
  }

  Future<void> removeAllEnemyTemplates() async {
    if (_currentUser == null) return;
    print("[GameProvider] Removing all enemy templates.");
    setProviderState(
        enemyTemplatesList: [],
        currentGame: CurrentGame(
          enemy: _currentGame.enemy,
          playerCurrentHp: _currentGame.playerCurrentHp,
          log: [
            ..._currentGame.log,
            "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">All enemy intelligence wiped from the database.</span>"
          ],
          currentPlaceKey: _currentGame.currentPlaceKey,
        ));
  }

  void deleteGameLocation(String locationId) {
    final newLocations =
        _gameLocationsList.where((loc) => loc.id != locationId).toList();
    final newClearedIds =
        _clearedLocationIds.where((id) => id != locationId).toList();
    String? newCurrentPlaceKey = _currentGame.currentPlaceKey;
    if (newCurrentPlaceKey == locationId) {
      newCurrentPlaceKey =
          newLocations.isNotEmpty ? newLocations.first.id : null;
    }

    setProviderState(
        gameLocationsList: newLocations,
        clearedLocationIds: newClearedIds,
        currentGame: CurrentGame(
          enemy: _currentGame.currentPlaceKey == locationId
              ? null
              : _currentGame.enemy, // Clear enemy if it was in deleted location
          playerCurrentHp: _currentGame.playerCurrentHp,
          log: [
            ..._currentGame.log,
            "<span style=\"color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)}\">Realm '${_gameLocationsList.firstWhereOrNull((l) => l.id == locationId)?.name ?? locationId}' has been destabilized and removed.</span>"
          ],
          currentPlaceKey: newCurrentPlaceKey,
        ));
  }

  void markLocationAsCleared(String locationId) {
    final newLocations = _gameLocationsList.map((loc) {
      if (loc.id == locationId) {
        return GameLocation(
          id: loc.id,
          name: loc.name,
          description: loc.description,
          minPlayerLevelToUnlock: loc.minPlayerLevelToUnlock,
          iconEmoji: loc.iconEmoji,
          associatedTheme: loc.associatedTheme,
          bossEnemyIdToUnlockNextLocation: loc.bossEnemyIdToUnlockNextLocation,
          isCleared: true, // Mark as cleared
        );
      }
      return loc;
    }).toList();

    final newClearedLocationIds = List<String>.from(_clearedLocationIds)
      ..add(locationId);

    setProviderState(
        gameLocationsList: newLocations,
        clearedLocationIds: newClearedLocationIds,
        currentGame: CurrentGame(
          enemy: _currentGame.enemy, // Keep current enemy if any
          playerCurrentHp: _currentGame.playerCurrentHp,
          log: [
            ..._currentGame.log,
            "<span style=\"color:${AppTheme.fhAccentGreen.value.toRadixString(16).substring(2)};\">Zone '${_gameLocationsList.firstWhereOrNull((loc) => loc.id == locationId)?.name ?? locationId}' has been pacified!</span>"
          ],
          currentPlaceKey: _currentGame.currentPlaceKey,
        ));
  }

  // Emotion Logging
  List<EmotionLog> getEmotionLogsForDate(String date) {
    final dayData = _completedByDay[date] as Map<String, dynamic>?;
    if (dayData == null || dayData['emotionLogs'] == null) {
      return [];
    }
    return (dayData['emotionLogs'] as List<dynamic>)
        .map((logJson) => EmotionLog.fromJson(logJson as Map<String, dynamic>))
        .toList()..sort((a, b) => a.timestamp.compareTo(b.timestamp));
  }

  void logEmotion(String date, int rating, [DateTime? customTimestamp]) {
    final timestamp = customTimestamp ?? DateTime.now();
    final emotionLog = EmotionLog(timestamp: timestamp, rating: rating);

    final newCompletedByDay = Map<String, dynamic>.from(_completedByDay);
    final dayData = Map<String, dynamic>.from(newCompletedByDay[date] ??
        {
          'taskTimes': <String, int>{},
          'subtasksCompleted': <Map<String, dynamic>>[],
          'checkpointsCompleted': <Map<String, dynamic>>[],
          'emotionLogs': <Map<String, dynamic>>[]
        });

    final emotionLogsList = List<Map<String, dynamic>>.from(dayData['emotionLogs'] as List? ?? []);
    
    if (emotionLogsList.length >= 10) {
      // emotionLogsList is already sorted by timestamp in getEmotionLogsForDate, and new logs are added to keep sort
      emotionLogsList.removeAt(0); // Remove the oldest
    }
    emotionLogsList.add(emotionLog.toJson());
    // Ensure it remains sorted after adding
    emotionLogsList.sort((a, b) => (a['timestamp'] as String).compareTo(b['timestamp'] as String));

    dayData['emotionLogs'] = emotionLogsList;
    newCompletedByDay[date] = dayData;

    setProviderState(completedByDay: newCompletedByDay);
    _currentGame.log.add("<span style='color:${AppTheme.fhAccentPurple.value.toRadixString(16).substring(2)};'>Emotion logged: $rating/5 for $date.</span>");
    notifyListeners(); // Ensure UI updates for new log
  }

  void deleteLatestEmotionLog(String date) {
    final currentLogs = getEmotionLogsForDate(date);
    if (currentLogs.isEmpty) return;

    final newCompletedByDay = Map<String, dynamic>.from(_completedByDay);
    final dayData = Map<String, dynamic>.from(newCompletedByDay[date] ?? {});
    final emotionLogsList = List<Map<String, dynamic>>.from(dayData['emotionLogs'] as List? ?? []);

    if (emotionLogsList.isNotEmpty) {
        emotionLogsList.removeLast(); // Assumes logs are always sorted, last one is latest
    }
    
    dayData['emotionLogs'] = emotionLogsList;
    newCompletedByDay[date] = dayData;

    setProviderState(completedByDay: newCompletedByDay);
    _currentGame.log.add("<span style='color:${AppTheme.fhAccentOrange.value.toRadixString(16).substring(2)};'>Latest emotion log for $date deleted.</span>");
    notifyListeners(); // Ensure UI updates
  }
  
  void setWakeupTime(TimeOfDay newTime) {
    _settings.wakeupTimeHour = newTime.hour;
    _settings.wakeupTimeMinute = newTime.minute;
    setSettings(_settings); // This will notify and mark for save
    scheduleEmotionReminders(); // Re-schedule on change
  }

  List<DateTime> calculateNotificationTimes() {
    final now = DateTime.now();
    final wakeupDateTime = DateTime(now.year, now.month, now.day, wakeupTime.hour, wakeupTime.minute);
    const int loggingDurationMinutes = 16 * 60; 
    const int numberOfLogs = 10;
    final int intervalMinutes = (loggingDurationMinutes / (numberOfLogs -1 )).floor();

    List<DateTime> times = [];
    DateTime currentTime = wakeupDateTime;

    for (int i = 0; i < numberOfLogs; i++) {
        times.add(currentTime);
        currentTime = currentTime.add(Duration(minutes: intervalMinutes));
    }
    // Filter times that are in the past relative to 'now' for today's reminders.
    // For future days, all 10 times would be valid.
    if (now.day == wakeupDateTime.day){
        return times.where((t) => t.isAfter(now)).toList();
    }
    return times; // For future days, return all calculated times
  }

  void scheduleEmotionReminders() {
    // Placeholder for actual notification scheduling
    // This would involve using a plugin like flutter_local_notifications
    // E.g., flutterLocalNotificationsPlugin.cancelAll();
    // List<DateTime> notificationTimes = calculateNotificationTimes();
    // for (var time in notificationTimes) {
    //   if (time.isAfter(DateTime.now())) {
    //     flutterLocalNotificationsPlugin.zonedSchedule(...);
    //   }
    // }
    if (kDebugMode) {
      print("[GameProvider] Conceptual: Would schedule notifications for: ${calculateNotificationTimes().map((t) => DateFormat('HH:mm').format(t)).join(', ')}");
    }
  }


  // Delegated methods
  Future<void> generateGameContent(int level,
          {bool isManual = false,
          bool isInitial = false,
          String contentType = "all",
          int numLocationsToGenerate = 0, // Added for specific requests
          int numEnemiesToGenerate = 0, // Added
          String? specificLocationKeyForEnemies // Added
          }) =>
      _aiGenerationActions.generateGameContent(level,
          isManual: isManual, 
          isInitial: isInitial, 
          contentType: contentType,
          numLocationsToGenerate: numLocationsToGenerate,
          numEnemiesToGenerate: numEnemiesToGenerate,
          specificLocationKeyForEnemies: specificLocationKeyForEnemies
          );

  void addMainTask(
          {required String name,
          required String description,
          required String theme,
          required String colorHex}) =>
      _taskActions.addMainTask(
          name: name,
          description: description,
          theme: theme,
          colorHex: colorHex);
  void editMainTask(String taskId,
          {required String name,
          required String description,
          required String theme,
          required String colorHex}) =>
      _taskActions.editMainTask(taskId,
          name: name,
          description: description,
          theme: theme,
          colorHex: colorHex);
  void logToDailySummary(String type, Map<String, dynamic> data) =>
      _taskActions.logToDailySummary(type, data);
  String addSubtask(String mainTaskId, Map<String, dynamic> subtaskData) =>
      _taskActions.addSubtask(mainTaskId, subtaskData);
  void updateSubtask(
          String mainTaskId, String subtaskId, Map<String, dynamic> updates) =>
      _taskActions.updateSubtask(mainTaskId, subtaskId, updates);
  bool completeSubtask(String mainTaskId, String subtaskId) =>
      _taskActions.completeSubtask(mainTaskId, subtaskId);
  void deleteSubtask(String mainTaskId, String subtaskId) =>
      _taskActions.deleteSubtask(mainTaskId, subtaskId);
  void duplicateCompletedSubtask(String mainTaskId, String subtaskId) =>
      _taskActions.duplicateCompletedSubtask(mainTaskId, subtaskId);
  void addSubSubtask(String mainTaskId, String parentSubtaskId,
          Map<String, dynamic> subSubtaskData) =>
      _taskActions.addSubSubtask(mainTaskId, parentSubtaskId, subSubtaskData);
  void updateSubSubtask(String mainTaskId, String parentSubtaskId,
          String subSubtaskId, Map<String, dynamic> updates) =>
      _taskActions.updateSubSubtask(
          mainTaskId, parentSubtaskId, subSubtaskId, updates);
  void completeSubSubtask(
          String mainTaskId, String parentSubtaskId, String subSubtaskId) =>
      _taskActions.completeSubSubtask(
          mainTaskId, parentSubtaskId, subSubtaskId);
  void deleteSubSubtask(
          String mainTaskId, String parentSubtaskId, String subSubtaskId) =>
      _taskActions.deleteSubSubtask(mainTaskId, parentSubtaskId, subSubtaskId);

  OwnedArtifact? getArtifactByUniqueId(String uniqueId) =>
      _itemActions.getArtifactByUniqueId(uniqueId);
  ArtifactTemplate? getArtifactTemplateById(String templateId) =>
      _itemActions.getArtifactTemplateById(templateId);
  ArtifactTemplate getArtifactEffectiveStats(OwnedArtifact ownedArtifact) =>
      _itemActions.getArtifactEffectiveStats(ownedArtifact);
  void buyArtifact(String templateId) => _itemActions.buyArtifact(templateId);
  bool upgradeArtifact(String uniqueId) =>
      _itemActions.upgradeArtifact(uniqueId);
  bool sellArtifact(String uniqueId) => _itemActions.sellArtifact(uniqueId);
  void equipArtifact(String uniqueId) => _itemActions.equipArtifact(uniqueId);
  void unequipArtifact(String slot) => _itemActions.unequipArtifact(slot);
  void acquireRune(String runeId) {
    print("[GameProvider] Placeholder: Acquire Rune $runeId");
    notifyListeners();
  }

  void equipRune(String ownedRuneUniqueId, String slot) {
    print("[GameProvider] Placeholder: Equip Rune $ownedRuneUniqueId to $slot");
    _updatePlayerStatsFromItemsAndRunes();
    notifyListeners();
  }

  void unequipRune(String slot) {
    print("[GameProvider] Placeholder: Unequip Rune from $slot");
    _updatePlayerStatsFromItemsAndRunes();
    notifyListeners();
  }

  void startGame(String enemyId) => _combatActions.startGame(enemyId);
  void handleFight() => _combatActions.handleFight();
  void usePowerUp(String uniqueId) => _combatActions.usePowerUp(uniqueId);
  void forfeitMatch() => _combatActions.forfeitMatch();
  void checkAndClearLocationIfAllEnemiesDefeated(String locationId) =>
      _combatActions.checkAndClearLocationIfAllEnemiesDefeated(locationId);

  Future<void> triggerAISubquestGeneration(MainTask mainTask,
          String generationMode, String userInput, int numSubquests) =>
      _aiGenerationActions.triggerAISubquestGeneration(
          mainTask, generationMode, userInput, numSubquests);

  void startTimer(String id, String type, String mainTaskId) =>
      _timerActions.startTimer(id, type, mainTaskId);
  void pauseTimer(String id) => _timerActions.pauseTimer(id);
  void logTimerAndReset(String id) => _timerActions.logTimerAndReset(id);

  // Park Actions Delegation
  bool canAffordBuilding(BuildingTemplate buildingTemplate) =>
      _parkActions.canAffordBuilding(buildingTemplate);
  void buyAndPlaceBuilding(String buildingTemplateId) =>
      _parkActions.buyAndPlaceBuilding(buildingTemplateId);
  void sellBuilding(String ownedBuildingUniqueId) =>
      _parkActions.sellBuilding(ownedBuildingUniqueId);
  void excavateFossil(String speciesId) =>
      _parkActions.excavateFossil(speciesId);
  void incubateDinosaur(String speciesId) =>
      _parkActions.incubateDinosaur(speciesId);
  void addDinosaurToEnclosure(
          String dinosaurUniqueId, String enclosureUniqueId) =>
      _parkActions.addDinosaurToEnclosure(dinosaurUniqueId, enclosureUniqueId);
  void feedDinosaursInEnclosure(String enclosureUniqueId, int amount) =>
      _parkActions.feedDinosaursInEnclosure(enclosureUniqueId, amount);
  void toggleBuildingOperationalStatus(String ownedBuildingUniqueId) =>
      _parkActions.toggleBuildingOperationalStatus(ownedBuildingUniqueId);
  void skipOneMinute() =>
      _parkActions.skipOneMinute(); // New skip minute method

  void setProviderState({
    String? lastLoginDate,
    double? coins,
    double? xp,
    double? playerEnergy,
    List<MainTask>? mainTasks,
    Map<String, dynamic>? completedByDay,
    List<OwnedArtifact>? artifacts,
    List<ArtifactTemplate>? artifactTemplatesList,
    List<EnemyTemplate>? enemyTemplatesList,
    List<GameLocation>? gameLocationsList,
    List<Rune>? runeTemplatesList,
    List<OwnedRune>? ownedRunes,
    Map<String, PlayerStat>? playerGameStats,
    Map<String, String?>? equippedItems,
    Map<String, String?>? equippedRunes,
    List<String>? defeatedEnemyIds,
    List<String>? clearedLocationIds, // Add for setProviderState
    CurrentGame? currentGame,
    Map<String, ActiveTimerInfo>? activeTimers,
    DateTime? lastSuccessfulSaveTimestamp,
    bool? isUsernameMissing,
    // Park Management
    List<DinosaurSpecies>? dinosaurSpeciesList,
    List<BuildingTemplate>? buildingTemplatesList,
    List<OwnedBuilding>? ownedBuildings,
    List<OwnedDinosaur>? ownedDinosaurs,
    List<FossilRecord>? fossilRecords,
    ParkManager? parkManager,
    bool doNotify = true,
    bool doPersist = true,
  }) {
    bool changed = false;
    int oldLevel = _playerLevel;

    if (lastLoginDate != null && _lastLoginDate != lastLoginDate) {
      _lastLoginDate = lastLoginDate;
      changed = true;
    }
    if (coins != null && _coins != coins) {
      _coins = coins;
      changed = true;
    }

    if (xp != null && _xp != xp) {
      _xp = xp;
      _recalculatePlayerLevel();
      changed = true;
    }

    if (playerEnergy != null && _playerEnergy != playerEnergy) {
      _playerEnergy = playerEnergy.clamp(0, calculatedMaxEnergy);
      changed = true;
    }

    // For lists and maps, ensure a change is detected if the reference changes or content changes
    if (mainTasks != null && !listEquals(_mainTasks, mainTasks)) {
      _mainTasks =
          List.from(mainTasks); // Create new list to ensure change detection
      changed = true;
    }
    if (completedByDay != null && !mapEquals(_completedByDay, completedByDay)) {
      _completedByDay = Map.from(completedByDay);
      changed = true;
    }

    bool itemsOrRunesOrEquippedChanged = false;
    if (artifacts != null && !listEquals(_artifacts, artifacts)) {
      _artifacts = List.from(artifacts);
      itemsOrRunesOrEquippedChanged = true;
      changed = true;
    }
    if (artifactTemplatesList != null &&
        !listEquals(_artifactTemplatesList, artifactTemplatesList)) {
      _artifactTemplatesList = List.from(artifactTemplatesList);
      changed = true;
    }
    if (enemyTemplatesList != null &&
        !listEquals(_enemyTemplatesList, enemyTemplatesList)) {
      _enemyTemplatesList = List.from(enemyTemplatesList);
      changed = true;
    }
    if (gameLocationsList != null &&
        !listEquals(_gameLocationsList, gameLocationsList)) {
      _gameLocationsList = List.from(gameLocationsList);
      changed = true;
    }
    if (clearedLocationIds != null &&
        !listEquals(_clearedLocationIds, clearedLocationIds)) {
      _clearedLocationIds = List.from(clearedLocationIds);
      changed = true;
    }
    if (runeTemplatesList != null &&
        !listEquals(_runeTemplatesList, runeTemplatesList)) {
      _runeTemplatesList = List.from(runeTemplatesList);
      changed = true;
    }
    if (ownedRunes != null && !listEquals(_ownedRunes, ownedRunes)) {
      _ownedRunes = List.from(ownedRunes);
      itemsOrRunesOrEquippedChanged = true;
      changed = true;
    }

    if (playerGameStats != null &&
        !mapEquals(_playerGameStats, playerGameStats)) {
      playerGameStats.forEach((key, newStat) {
        if (_playerGameStats.containsKey(key)) {
          _playerGameStats[key]!.base = newStat.base;
          _playerGameStats[key]!.value =
              newStat.value; // Ensure value is also updated
        } else {
          _playerGameStats[key] = newStat;
        }
      });
      _ensureBonusXpModStat();
      itemsOrRunesOrEquippedChanged = true;
      changed = true;
    }

    if (equippedItems != null && !mapEquals(_equippedItems, equippedItems)) {
      _equippedItems = Map.from(equippedItems);
      itemsOrRunesOrEquippedChanged = true;
      changed = true;
    }
    if (equippedRunes != null && !mapEquals(_equippedRunes, equippedRunes)) {
      _equippedRunes = Map.from(equippedRunes);
      itemsOrRunesOrEquippedChanged = true;
      changed = true;
    }

    if (itemsOrRunesOrEquippedChanged || oldLevel != _playerLevel) {
      _updatePlayerStatsFromItemsAndRunes();
    }

    if (defeatedEnemyIds != null &&
        !listEquals(_defeatedEnemyIds, defeatedEnemyIds)) {
      _defeatedEnemyIds = List.from(defeatedEnemyIds);
      changed = true;
    }
    if (currentGame != null && _currentGame != currentGame) {
      // This comparison might need to be deeper
      _currentGame = currentGame; // Assume currentGame is a new instance
      if (_playerGameStats['vitality'] != null &&
          _currentGame.playerCurrentHp > _playerGameStats['vitality']!.value) {
        _currentGame.playerCurrentHp = _playerGameStats['vitality']!.value;
      }
      changed = true;
    }
    if (activeTimers != null && !mapEquals(_activeTimers, activeTimers)) {
      _activeTimers = Map.from(activeTimers);
      changed = true;
    }
    if (lastSuccessfulSaveTimestamp != null &&
        _lastSuccessfulSaveTimestamp != lastSuccessfulSaveTimestamp) {
      _lastSuccessfulSaveTimestamp = lastSuccessfulSaveTimestamp;
      changed = true;
    }
    if (isUsernameMissing != null && _isUsernameMissing != isUsernameMissing) {
      _isUsernameMissing = isUsernameMissing;
      changed = true;
    }

    // Park Management State Updates
    if (dinosaurSpeciesList != null &&
        !listEquals(_dinosaurSpeciesList, dinosaurSpeciesList)) {
      _dinosaurSpeciesList = List.from(dinosaurSpeciesList);
      changed = true;
    }
    if (buildingTemplatesList != null &&
        !listEquals(_buildingTemplatesList, buildingTemplatesList)) {
      _buildingTemplatesList = List.from(buildingTemplatesList);
      changed = true;
    }
    if (ownedBuildings != null &&
        !listEquals(_ownedBuildings, ownedBuildings)) {
      _ownedBuildings = List.from(ownedBuildings);
      changed = true;
    }
    if (ownedDinosaurs != null &&
        !listEquals(_ownedDinosaurs, ownedDinosaurs)) {
      _ownedDinosaurs = List.from(ownedDinosaurs);
      changed = true;
    }
    if (fossilRecords != null && !listEquals(_fossilRecords, fossilRecords)) {
      _fossilRecords = List.from(fossilRecords);
      changed = true;
    }
    if (parkManager != null && _parkManager != parkManager) {
      // Simple comparison, might need deep compare if ParkManager becomes complex
      _parkManager = parkManager;
      // When ParkManager state is updated, ensure player energy is consistent if used for park ops
      if (_parkManager.parkEnergy != _playerEnergy ||
          _parkManager.maxParkEnergy != calculatedMaxEnergy) {
        _parkManager.parkEnergy = _playerEnergy;
        _parkManager.maxParkEnergy = calculatedMaxEnergy;
      }
      changed = true;
    }

    if (changed) {
      if (kDebugMode && doNotify) {
        print(
            "[GameProvider] setProviderState detected changes, will notify. Persist: $doPersist.");
      }
      if (doPersist) _hasUnsavedChanges = true;
      if (doNotify) notifyListeners();
    }
  }

  void setProviderAIGlobalLoading(bool isLoading,
      {double progress = 0.0, String statusMessage = ""}) {
    bool changed = false;
    if (_isGeneratingGlobalContent != isLoading) {
      _isGeneratingGlobalContent = isLoading;
      changed = true;
    }
    if (_aiGenerationProgress != progress) {
      _aiGenerationProgress = progress;
      changed = true;
    }
    if (_aiGenerationStatusMessage != statusMessage) {
      _aiGenerationStatusMessage = statusMessage;
      changed = true;
    }
    if (changed) {
      print(
          "[GameProvider] AI Global Loading set to: $isLoading, Progress: $progress, Message: $statusMessage");
      notifyListeners();
    }
  }

  void setProviderAISubquestLoading(bool isLoading) {
    if (_isGeneratingSubquestsForTask != isLoading) {
      _isGeneratingSubquestsForTask = isLoading;
      print("[GameProvider] AI Subquest Loading set to: $isLoading");
      notifyListeners();
    }
  }

  void setProviderApiKeyIndex(int index) {
    if (_apiKeyIndex != index) {
      _apiKeyIndex = index;
      print("[GameProvider] API Key Index set to: $index");
      // No need to notify listeners for this internal state unless UI depends on it directly
    }
  }
}

--- END OF FILE lib/src/providers/game_provider.dart ---
--- START OF FILE lib/src/providers/actions/ai_generation_actions.dart ---
// lib/src/providers/actions/ai_generation_actions.dart
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/services/ai_service.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:flutter/foundation.dart'; // For kDebugMode
import 'package:collection/collection.dart'; // For whereNotNull
import 'dart:math' as math_random;

class AIGenerationActions {
  final GameProvider _provider;
  final AIService _aiService = AIService();
  final math_random.Random _random = math_random.Random();



  AIGenerationActions(this._provider);

  // Helper to generate a unique ID
  String _generateUniqueId(String type, String name, String? theme, int level) {
    final namePart = name.replaceAll(RegExp(r'\s+'), '_').toLowerCase();
    final themePart = theme ?? 'general';
    return 'gen_${type}_${themePart}_${namePart}_lvl${level}_${_random.nextInt(100000)}';
  }

  // --- Programmatic Stat Generation ---
  Map<String, dynamic> _generateEnemyStats(
      String id, String name, String? theme, String description, int level, String specificLocationKey) {
    
    return {
      'id': id,
      'name': name,
      'theme': theme,
      'locationKey': specificLocationKey, // Use the provided specific location key
      'minPlayerLevel': level,
      'health': (40 + level * 10) + _random.nextInt(20 + level * 5),
      'attack': (7 + level * 1.5).toInt() + _random.nextInt(3 + level ~/ 2),
      'defense': (2 + level * 0.5).toInt() + _random.nextInt(2 + level ~/ 3),
      'coinReward': (15 + level * 4) + _random.nextInt(20 + level * 4),
      'xpReward': (25 + level * 6) + _random.nextInt(30 + level * 6),
      'description': description,
    };
  }

  Map<String, dynamic> _generateArtifactStats(String id, String name,
      String? theme, String description, String icon, String type, int level) {
    int cost = (30 + level * 10) + _random.nextInt(100 + level * 15);
    Map<String, dynamic> stats = {
      'id': id,
      'name': name,
      'type': type, // weapon, armor, talisman
      'theme': theme,
      'description': description,
      'cost': cost,
      'icon': icon,
      'maxLevel': _random.nextInt(3) + 2, // Max level 2, 3, or 4
    };

    if (type == 'weapon') {
      stats['baseAtt'] = (level * 0.2 + 1).toInt() + _random.nextInt(level ~/ 4 + 1);
      stats['baseRunic'] = (level * 0.15 + (_random.nextBool() ? 1 : 0)).toInt() + _random.nextInt(level ~/ 5 + 1);
      stats['upgradeBonus'] = {"att": 1 + _random.nextInt(level ~/ 8 + 1)};
    } else if (type == 'armor') {
      stats['baseDef'] = (level * 0.18 + 1).toInt() + _random.nextInt(level ~/ 5 + 1);
      stats['baseHealth'] = (level * 1.2 + 3).toInt() + _random.nextInt(level * 1 + 4);
      stats['upgradeBonus'] = {"def": 1 + _random.nextInt(level ~/ 8 + 1), "health": 2 + _random.nextInt(level ~/ 4 + 1)};
    } else if (type == 'talisman') {
      stats['baseLuck'] = _random.nextInt(level ~/ 2 + 2) + 1; // e.g., max 1 + 1 = 2 at L1, 1+3 = 4 at L5
      stats['baseCooldown'] = _random.nextInt(level ~/ 2 + 1);
      stats['bonusXPMod'] = _random.nextDouble() * 0.02; // Max 2%
      stats['upgradeBonus'] = _random.nextBool() ? {"luck": 1} : {"cooldown": 1};
       if (_random.nextDouble() < 0.2) { // 20% chance for talisman to also have a small baseAtt or baseRunic
        if(_random.nextBool()){
          stats['baseAtt'] = (level * 0.1).toInt() + 1;
        } else {
          stats['baseRunic'] = (level * 0.1).toInt() + 1;
        }
      }
    }
    // Ensure all numeric stat fields are present, defaulting to 0 or null
    for (var key in ['baseAtt', 'baseRunic', 'baseDef', 'baseHealth', 'baseLuck', 'baseCooldown']) {
        stats.putIfAbsent(key, () => 0);
    }
    stats.putIfAbsent('bonusXPMod', () => 0.0);


    return stats;
  }

  Map<String, dynamic> _generatePowerupStats(
      String id, String name, String? theme, String description, String icon, int level) {
    String effectType = _random.nextBool() ? 'direct_damage' : 'heal_player';
    int effectValue;
    if (effectType == 'direct_damage') {
      effectValue = (level * 3 + 10) + _random.nextInt(level * 2 + 10);
    } else {
      effectValue = (level * 2 + 8) + _random.nextInt(level * 2 + 8);
    }
    return {
      'id': id,
      'name': name,
      'type': 'powerup',
      'theme': theme,
      'description': description,
      'cost': (15 + level * 5) + _random.nextInt(30 + level * 5),
      'icon': icon,
      'effectType': effectType,
      'effectValue': effectValue,
      'uses': 1,
    };
  }

 Map<String, dynamic> _generateLocationStats(
      String id, String name, String description, String iconEmoji, String? theme, int level) {
    String? bossId;
    // If there are enemies, try to pick one as a boss. Prioritize by level and theme if possible.
    // This now needs to consider that enemies might not be generated *yet* if this location is generated first.
    // So, bossId might often be null initially and set later, or chosen from existing enemies if appropriate.
    final potentialBosses = _provider.enemyTemplatesList
            .where((e) => (e.theme == theme || theme == null) && e.minPlayerLevel >= level && e.minPlayerLevel <= level + 2)
            .toList();
    if (potentialBosses.isNotEmpty) {
        bossId = potentialBosses[_random.nextInt(potentialBosses.length)].id;
    }
    // If no suitable existing boss, it will remain null. GameProvider can later assign a newly generated enemy as boss.

    return {
      'id': id,
      'name': name,
      'description': description,
      'minPlayerLevelToUnlock': level + _random.nextInt(2), // Lvl or Lvl+1
      'iconEmoji': iconEmoji,
      'associatedTheme': theme,
      'bossEnemyIdToUnlockNextLocation': bossId, // Can be null
    };
  }


  Future<void> generateGameContent(int levelForContent,
      {bool isManual = false,
      bool isInitial = false,
      String contentType = "all",
      int numLocationsToGenerate = 0,
      int numEnemiesToGenerate = 0,
      String? specificLocationKeyForEnemies,
      }) async {
    try {
      if (_provider.isGeneratingContent && !isManual && !isInitial) {
        print("[AIActions] generateGameContent skipped, already in progress for $contentType.");
        return;
      }
      _provider.setProviderAIGlobalLoading(true,
          progress: 0.0,
          statusMessage: "Initializing AI protocol for names/icons generation ($contentType)...");

      List<String?> activeThemes = _provider.mainTasks.map((t) => t.theme).toSet().toList();
      if (activeThemes.isEmpty) activeThemes.add(null); // Ensure at least general theme for generation requests

      // Build request for AI
      List<Map<String, dynamic>> aiRequestedItems = [];
      int actualNumLocations = numLocationsToGenerate > 0 ? numLocationsToGenerate : ((contentType == "all" || contentType == "locations") ? (isInitial ? 2 : 1) : 0);
      int actualNumEnemies = numEnemiesToGenerate > 0 ? numEnemiesToGenerate : ((contentType == "all" || contentType == "enemies") ? (isInitial ? 2 : 1) : 0); // Total enemies, not per theme for simplicity here
      int numArtifactsPerSubtypePerTheme = (contentType == "all" || contentType == "artifacts") ? (isInitial ? 1 : 1) : 0;
      int numPowerupsPerTheme = (contentType == "all" || contentType == "artifacts") ? (isInitial ? 1 : 0) : 0;


      if (actualNumLocations > 0) {
         for (int i = 0; i < actualNumLocations; i++) {
            aiRequestedItems.add({"itemCategory": "location", "themeHint": activeThemes[_random.nextInt(activeThemes.length)]});
         }
      }
      if (actualNumEnemies > 0) {
        for (int i = 0; i < actualNumEnemies; i++) {
          // If specificLocationKeyForEnemies is provided, we need its theme.
          // Otherwise, pick a random theme from activeThemes.
          String? themeForEnemy;
          if (specificLocationKeyForEnemies != null) {
            final loc = _provider.gameLocationsList.firstWhereOrNull((l) => l.id == specificLocationKeyForEnemies);
            themeForEnemy = loc?.associatedTheme; // Could be null if loc theme is null
          } else {
            themeForEnemy = activeThemes[_random.nextInt(activeThemes.length)];
          }
          aiRequestedItems.add({"itemCategory": "enemy", "themeHint": themeForEnemy});
        }
      }
      if (numArtifactsPerSubtypePerTheme > 0) {
        for (var theme in activeThemes) {
          for (int i = 0; i < numArtifactsPerSubtypePerTheme; i++) {
            aiRequestedItems.add({"itemCategory": "artifact_weapon", "themeHint": theme});
            aiRequestedItems.add({"itemCategory": "artifact_armor", "themeHint": theme});
            aiRequestedItems.add({"itemCategory": "artifact_talisman", "themeHint": theme});
          }
        }
      }
      if (numPowerupsPerTheme > 0) {
        for (var theme in activeThemes) {
          for (int i = 0; i < numPowerupsPerTheme; i++) {
            aiRequestedItems.add({"itemCategory": "powerup", "themeHint": theme});
          }
        }
      }
      
      if (aiRequestedItems.isEmpty) {
         _provider.setProviderAIGlobalLoading(false, progress: 1.0, statusMessage: "No items requested for AI generation for $contentType.");
         return;
      }

      final String prompt = """
Generate creative game content. For each item in the 'requestedItems' list, provide a name, a short evocative description, a theme (from the 'themeHint' or null if 'themeHint' is null/general), and a single relevant emoji icon (for artifacts, powerups, locations).
The 'itemCategory' specifies the type of item.
Return a single JSON object with one key: "generatedItems". "generatedItems" should be an array of objects, each corresponding to a requested item.
Each object in "generatedItems" MUST have:
- "itemCategory": string (must match the category from the request)
- "name": string (creative and fitting the category and theme)
- "description": string (short, max 80 chars)
- "theme": string or null (must match or be consistent with the 'themeHint' from the request)
- "icon": string (single emoji, applicable for itemCategory 'location', 'artifact_weapon', 'artifact_armor', 'artifact_talisman', 'powerup'. For 'enemy', this can be a simple descriptive emoji or null.)

Example Request:
{ "requestedItems": [ {"itemCategory": "location", "themeHint": "nature"}, {"itemCategory": "enemy", "themeHint": "nature"} ] }

Example Response:
{
  "generatedItems": [
    { "itemCategory": "location", "name": "Verdant Grove", "description": "A lush, ancient forest.", "theme": "nature", "icon": "🌳" },
    { "itemCategory": "enemy", "name": "Grove Spider", "description": "A large, camouflaged arachnid.", "theme": "nature", "icon": "🕷️" }
  ]
}
Do NOT generate stats, costs, levels, or IDs. Only name, description, theme, and icon (where applicable).
Ensure the 'theme' in your response is the same as the 'themeHint' provided for that item, or null if the 'themeHint' was null.
Existing content IDs to avoid duplicating names for (informational only, focus on unique names):
Locations: ${_provider.gameLocationsList.map((e) => e.name).join(', ')}
Enemies: ${_provider.enemyTemplatesList.map((e) => e.name).join(', ')}
Artifacts: ${_provider.artifactTemplatesList.map((e) => e.name).join(', ')}

Request:
${({"requestedItems": aiRequestedItems})}
""";
      _provider.setProviderAIGlobalLoading(true, progress: 0.2, statusMessage: "Contacting AI for names & icons ($contentType)...");
      

      final Map<String, dynamic> aiResponse = await _aiService.makeAICall(
        prompt: prompt,
        currentApiKeyIndex: _provider.apiKeyIndex,
        onNewApiKeyIndex: _provider.setProviderApiKeyIndex,
        onLog: (log) {
          print("[AI Service Log - Content Type: $contentType]: $log");
          _logToGame(log);
        },
      );
       _provider.setProviderAIGlobalLoading(true, progress: 0.5, statusMessage: "AI response received. Processing $contentType items...");

      final List<Map<String, dynamic>> generatedAiItems =
          (aiResponse['generatedItems'] as List?)?.map((item) => item as Map<String, dynamic>).toList() ?? [];

      List<EnemyTemplate> newEnemies = [];
      List<ArtifactTemplate> newArtifacts = [];
      List<GameLocation> newLocations = [];

      for (var aiItem in generatedAiItems) {
        final String itemCategory = aiItem['itemCategory'] as String? ?? 'unknown';
        final String itemName = aiItem['name'] as String? ?? 'Unnamed';
        final String itemDescription = aiItem['description'] as String? ?? 'No description.';
        final String? itemTheme = aiItem['theme'] as String?; // Can be null
        final String itemIcon = aiItem['icon'] as String? ?? '❓';

        if (itemName == 'Unnamed' || _nameExists(itemName, itemCategory)) {
            print("[AIActions] Skipping item due to 'Unnamed' or duplicate name: $itemName (Category: $itemCategory)");
            continue; // Skip if name is default or already exists for that category
        }


        if (itemCategory == 'location') {
          final id = _generateUniqueId('loc', itemName, itemTheme, levelForContent);
          newLocations.add(GameLocation.fromJson(_generateLocationStats(id, itemName, itemDescription, itemIcon, itemTheme, levelForContent)));
        } else if (itemCategory == 'enemy') {
          final id = _generateUniqueId('enemy', itemName, itemTheme, levelForContent);
          final String locKeyForEnemy = specificLocationKeyForEnemies ?? 
                                        _provider.gameLocationsList.firstWhereOrNull((l) => l.associatedTheme == itemTheme)?.id ?? 
                                        _provider.gameLocationsList.firstOrNull?.id ?? 
                                        "default_zone_error";
          newEnemies.add(EnemyTemplate.fromJson(_generateEnemyStats(id, itemName, itemTheme, itemDescription, levelForContent, locKeyForEnemy)));
        } else if (itemCategory.startsWith('artifact_')) {
          final type = itemCategory.split('_')[1]; // weapon, armor, talisman
          final id = _generateUniqueId('art', itemName, itemTheme, levelForContent);
          newArtifacts.add(ArtifactTemplate.fromJson(_generateArtifactStats(id, itemName, itemTheme, itemDescription, itemIcon, type, levelForContent)));
        } else if (itemCategory == 'powerup') {
          final id = _generateUniqueId('pwp', itemName, itemTheme, levelForContent);
          newArtifacts.add(ArtifactTemplate.fromJson(_generatePowerupStats(id, itemName, itemTheme, itemDescription, itemIcon, levelForContent)));
        }
      }
      _provider.setProviderAIGlobalLoading(true, progress: 0.8, statusMessage: "Finalizing generated $contentType content...");

      if (newLocations.isNotEmpty) {
        _provider.setProviderState(gameLocationsList: [..._provider.gameLocationsList, ...newLocations], doPersist: false);
      }
      if (newEnemies.isNotEmpty) {
        _provider.setProviderState(enemyTemplatesList: [..._provider.enemyTemplatesList, ...newEnemies], doPersist: false);
      }
      if (newArtifacts.isNotEmpty) {
        _provider.setProviderState(artifactTemplatesList: [..._provider.artifactTemplatesList, ...newArtifacts], doPersist: false);
      }
      
      if (newLocations.isNotEmpty || newEnemies.isNotEmpty || newArtifacts.isNotEmpty) {
         _logToGame("<span style=\"color:${AppTheme.fhAccentGreen.value.toRadixString(16).substring(2)};\">AI has infused the world with new $contentType elements for level $levelForContent.</span>");
         _provider.setProviderState(doPersist: true, doNotify: true); // Trigger a single save and notify
      } else {
         _logToGame("<span style=\"color:var(--fh-accent-orange);\">AI generation for $contentType (L$levelForContent) did not yield new unique content.</span>");
      }

    } catch (e, stackTrace) {
      final errorMessage = e.toString();
      print("[AIActions] CRITICAL ERROR in generateGameContent ($contentType): $errorMessage");
      if (kDebugMode) print("[AIActions] StackTrace for generateGameContent ($contentType) error: $stackTrace");
      _logToGame("<span style=\"color:${AppTheme.fhAccentRed.value.toRadixString(16).substring(2)};\">AI content generation for $contentType failed critically: $errorMessage</span>");
    } finally {
      _provider.setProviderAIGlobalLoading(false,
          progress: 1.0,
          statusMessage: "Content generation protocol for $contentType finished.");
    }
  }

  bool _nameExists(String name, String itemCategory) {
    if (itemCategory == 'location') {
        return _provider.gameLocationsList.any((loc) => loc.name.toLowerCase() == name.toLowerCase());
    } else if (itemCategory == 'enemy') {
        return _provider.enemyTemplatesList.any((enemy) => enemy.name.toLowerCase() == name.toLowerCase());
    } else if (itemCategory.startsWith('artifact_') || itemCategory == 'powerup') {
        return _provider.artifactTemplatesList.any((art) => art.name.toLowerCase() == name.toLowerCase());
    }
    return false;
}


  void _logToGame(String logMessage) {
    if (kDebugMode) print("[AIActions - _logToGame]: $logMessage");
    _provider.setProviderState(
        currentGame: CurrentGame(
          enemy: _provider.currentGame.enemy,
          playerCurrentHp: _provider.currentGame.playerCurrentHp,
          log: [..._provider.currentGame.log, logMessage],
          currentPlaceKey: _provider.currentGame.currentPlaceKey,
        ),
        doPersist: false, // Persisted at the end of generateGameContent or when subquests are added
        doNotify: true);
  }

  Future<void> triggerAISubquestGeneration(MainTask mainTaskForSubquests,
      String generationMode, String userInput, int numSubquests) async {
    if (_provider.isGeneratingSubquests) {
      print("[AIActions] triggerAISubquestGeneration skipped, already in progress for task '${mainTaskForSubquests.name}'.");
      return;
    }
    _provider.setProviderAISubquestLoading(true);
    print("[AIActions] Starting triggerAISubquestGeneration for task '${mainTaskForSubquests.name}'. Mode: $generationMode, User Input: '$userInput', Num Subquests: $numSubquests");

    try {
      print("[AIActions] Attempting to call _aiService.generateAISubquests for task '${mainTaskForSubquests.name}'.");
      final generatedSubquestsRaw = await _aiService.generateAISubquests(
        mainTaskName: mainTaskForSubquests.name,
        mainTaskDescription: mainTaskForSubquests.description,
        mainTaskTheme: mainTaskForSubquests.theme,
        generationMode: generationMode,
        userInput: userInput,
        numSubquests: numSubquests,
        currentApiKeyIndex: _provider.apiKeyIndex,
        onNewApiKeyIndex: (newIndex) {
          print("[AIActions] API key index updated to $newIndex during subquest gen for task '${mainTaskForSubquests.name}'.");
          _provider.setProviderApiKeyIndex(newIndex);
        },
        onLog: (log) {
          print("[AI Service Log - Subquests - Task: ${mainTaskForSubquests.name}]: $log");
          _logToGame(log);
        },
      );

      print("[AIActions] _aiService.generateAISubquests returned for task '${mainTaskForSubquests.name}'. Raw data length: ${generatedSubquestsRaw.length}");
      if (kDebugMode && generatedSubquestsRaw.isNotEmpty) {
        print("[AIActions] Raw subquest data for task '${mainTaskForSubquests.name}': $generatedSubquestsRaw");
      }

      final List<SubTask> newSubTasksForParent = [];
      for (var subquestData in generatedSubquestsRaw) {
        if (kDebugMode) print("[AIActions] Processing raw subquest data: $subquestData");
        if (subquestData is! Map<String, dynamic>) {
          print("[AIActions] Skipping invalid raw subquest data (null or not a Map): $subquestData");
          continue;
        }

        final List<Map<String, dynamic>> subSubTasksDataList =
            (subquestData['subSubTasksData'] as List<dynamic>? ?? [])
                .map((item) {
                  if (item is Map<String, dynamic>) return item;
                  print("[AIActions] Invalid sub-sub-task data item, expected Map<String, dynamic>, got ${item.runtimeType}: $item");
                  return null; 
                })
                .whereNotNull()
                .toList();

        final List<SubSubTask> currentSubSubTasks = [];
        for (int i = 0; i < subSubTasksDataList.length; i++) {
          final sssData = subSubTasksDataList[i];
          if (kDebugMode) print("[AIActions] Processing raw sub-sub-task data: $sssData");
          try {
            currentSubSubTasks.add(SubSubTask(
              id: 'ssub_${DateTime.now().millisecondsSinceEpoch}_${newSubTasksForParent.length}_$i',
              name: sssData['name'] as String? ?? 'Unnamed Sub-Sub-Task',
              isCountable: sssData['isCountable'] as bool? ?? false,
              targetCount: (sssData['isCountable'] as bool? ?? false)
                  ? (sssData['targetCount'] as int? ?? 1)
                  : 0,
            ));
          } catch (e, s) {
            print("[AIActions] Error parsing SubSubTask from data: $sssData. Error: $e. Stacktrace: $s");
          }
        }

        try {
          final newSubTask = SubTask(
            id: 'sub_${DateTime.now().millisecondsSinceEpoch}_${newSubTasksForParent.length}',
            name: subquestData['name'] as String? ?? 'Unnamed Sub-Task',
            isCountable: subquestData['isCountable'] as bool? ?? false,
            targetCount: (subquestData['isCountable'] as bool? ?? false)
                ? (subquestData['targetCount'] as int? ?? 1)
                : 0,
            subSubTasks: currentSubSubTasks,
          );
          newSubTasksForParent.add(newSubTask);
          if (kDebugMode) print("[AIActions] Created SubTask: ${newSubTask.name} with ${currentSubSubTasks.length} sub-sub-tasks.");
        } catch (e, s) {
          print("[AIActions] Error parsing SubTask from data: $subquestData. Error: $e. Stacktrace: $s");
        }
      }

      if (newSubTasksForParent.isEmpty && generatedSubquestsRaw.isNotEmpty) {
        print("[AIActions] Warning: Raw subquests were received, but no valid SubTasks could be parsed for task '${mainTaskForSubquests.name}'.");
        _logToGame("<span style=\"color:var(--fh-accent-orange);\">AI returned sub-quest data for '${mainTaskForSubquests.name}', but it could not be fully processed.</span>");
      }

      final newMainTasks = _provider.mainTasks.map((task) {
        if (task.id == mainTaskForSubquests.id) {
          return MainTask(
            id: task.id,
            name: task.name,
            description: task.description,
            theme: task.theme,
            colorHex: task.colorHex,
            streak: task.streak,
            dailyTimeSpent: task.dailyTimeSpent,
            lastWorkedDate: task.lastWorkedDate,
            subTasks: [...task.subTasks, ...newSubTasksForParent],
          );
        }
        return task;
      }).toList();

      print("[AIActions] Generated ${newSubTasksForParent.length} new valid sub-quests for task '${mainTaskForSubquests.name}'.");

      _provider.setProviderState(
          mainTasks: newMainTasks,
          currentGame: CurrentGame(
            enemy: _provider.currentGame.enemy,
            playerCurrentHp: _provider.currentGame.playerCurrentHp,
            log: [
              ..._provider.currentGame.log,
              if (newSubTasksForParent.isNotEmpty)
                "<span style=\"color:${AppTheme.fhAccentGreen.value.toRadixString(16).substring(2)};\">AI successfully generated ${newSubTasksForParent.length} new sub-quests for '${mainTaskForSubquests.name}'.</span>"
              else if (generatedSubquestsRaw.isNotEmpty) 
                "<span style=\"color:var(--fh-accent-orange);\">AI sub-quest generation for '${mainTaskForSubquests.name}' returned data, but it could not be fully processed.</span>"
              else 
                "<span style=\"color:var(--fh-accent-orange);\">AI sub-quest generation for '${mainTaskForSubquests.name}' did not yield new quests.</span>"
            ],
            currentPlaceKey: _provider.currentGame.currentPlaceKey,
          ),
          doPersist: true, 
          doNotify: true);
      print("[AIActions] Subquest state update successful for task '${mainTaskForSubquests.name}', data persisted.");
    } catch (e, stackTrace) {
      final errorMessage = e.toString();
      print("[AIActions] CRITICAL ERROR in triggerAISubquestGeneration for task '${mainTaskForSubquests.name}': $errorMessage");
      if (kDebugMode) print("[AIActions] StackTrace for triggerAISubquestGeneration error: $stackTrace");
      _logToGame("<span style=\"color:${AppTheme.fhAccentRed.value.toRadixString(16).substring(2)};\">AI sub-quest generation for '${mainTaskForSubquests.name}' failed critically: $errorMessage</span>");
    } finally {
      _provider.setProviderAISubquestLoading(false);
      print("[AIActions] Finished triggerAISubquestGeneration for task '${mainTaskForSubquests.name}'.");
    }
  }
}
--- END OF FILE lib/src/providers/actions/ai_generation_actions.dart ---