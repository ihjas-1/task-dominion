--- START OF FILE lib/src/models/game_models.dart ---
// lib/src/models/game_models.dart
import 'package:flutter/material.dart';
import 'package:arcane/src/theme/app_theme.dart';

class Project {
  String id;
  String name;
  String description;
  String theme;
  String colorHex;
  int streak;
  int dailyTimeSpent;
  String? lastWorkedDate;
  List<Task> tasks;

  Project({
    required this.id,
    required this.name,
    required this.description,
    required this.theme,
    this.colorHex = "FF00BFFF", // Default to fortnite blue
    this.streak = 0,
    this.dailyTimeSpent = 0,
    this.lastWorkedDate,
    List<Task>? tasks,
  }) : tasks = tasks ?? [];

  factory Project.fromTemplate(ProjectTemplate template) {
    return Project(
      id: template.id,
      name: template.name,
      description: template.description,
      theme: template.theme,
      colorHex: template.colorHex,
    );
  }

  factory Project.fromJson(Map<String, dynamic> json) {
    return Project(
      id: json['id'] as String,
      name: json['name'] as String,
      description: json['description'] as String,
      theme: json['theme'] as String,
      colorHex: json['colorHex'] as String? ?? "FF00BFFF",
      streak: json['streak'] as int? ?? 0,
      dailyTimeSpent: json['dailyTimeSpent'] as int? ?? 0,
      lastWorkedDate: json['lastWorkedDate'] as String?,
      tasks: (json['tasks'] as List<dynamic>?)
              ?.map((tJson) => Task.fromJson(tJson as Map<String, dynamic>))
              .toList() ??
          [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'description': description,
      'theme': theme,
      'colorHex': colorHex,
      'streak': streak,
      'dailyTimeSpent': dailyTimeSpent,
      'lastWorkedDate': lastWorkedDate,
      'tasks': tasks.map((t) => t.toJson()).toList(),
    };
  }

  Color get color {
    try {
      return Color(int.parse("0x$colorHex"));
    } catch (e) {
      return AppTheme.fortniteBlue; // Fallback color
    }
  }
}

class Task {
  String id;
  String name;
  bool completed;
  int currentTimeSpent; // Storing as minutes
  String? completedDate;
  bool isCountable;
  int targetCount;
  int currentCount;
  List<Checkpoint> checkpoints;
  Map<String, double> skillXp;

  Task({
    required this.id,
    required this.name,
    this.completed = false,
    this.currentTimeSpent = 0,
    this.completedDate,
    this.isCountable = false,
    this.targetCount = 0,
    this.currentCount = 0,
    List<Checkpoint>? checkpoints,
    Map<String, double>? skillXp,
  })  : checkpoints = checkpoints ?? [],
        skillXp = skillXp ?? {};

  factory Task.fromJson(Map<String, dynamic> json) {
    // Legacy support for 'subSubTasks'
    final checkpointsData = json['checkpoints'] ?? json['subSubTasks'];

    return Task(
      id: json['id'] as String,
      name: json['name'] as String,
      completed: json['completed'] as bool? ?? false,
      currentTimeSpent: json['currentTimeSpent'] as int? ?? 0,
      completedDate: json['completedDate'] as String?,
      isCountable: json['isCountable'] as bool? ?? false,
      targetCount: json['targetCount'] as int? ?? 0,
      currentCount: json['currentCount'] as int? ?? 0,
      checkpoints: (checkpointsData as List<dynamic>?)
              ?.map((cpJson) =>
                  Checkpoint.fromJson(cpJson as Map<String, dynamic>))
              .toList() ??
          [],
      skillXp: (json['skillXp'] as Map<String, dynamic>?)?.map(
            (key, value) => MapEntry(key, (value as num).toDouble()),
          ) ??
          {},
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'completed': completed,
      'currentTimeSpent': currentTimeSpent,
      'completedDate': completedDate,
      'isCountable': isCountable,
      'targetCount': targetCount,
      'currentCount': currentCount,
      'checkpoints': checkpoints.map((cp) => cp.toJson()).toList(),
      'skillXp': skillXp,
    };
  }
}

class Checkpoint {
  String id;
  String name;
  bool completed;
  bool isCountable;
  int targetCount;
  int currentCount;
  String? completionTimestamp;
  Map<String, double> skillXp;

  Checkpoint({
    required this.id,
    required this.name,
    this.completed = false,
    this.isCountable = false,
    this.targetCount = 0,
    this.currentCount = 0,
    this.completionTimestamp,
    Map<String, double>? skillXp,
  }) : skillXp = skillXp ?? {};

  factory Checkpoint.fromJson(Map<String, dynamic> json) {
    return Checkpoint(
      id: json['id'] as String,
      name: json['name'] as String,
      completed: json['completed'] as bool? ?? false,
      isCountable: json['isCountable'] as bool? ?? false,
      targetCount: json['targetCount'] as int? ?? 0,
      currentCount: json['currentCount'] as int? ?? 0,
      completionTimestamp: json['completionTimestamp'] as String?,
      skillXp: (json['skillXp'] as Map<String, dynamic>?)?.map(
            (key, value) => MapEntry(key, (value as num).toDouble()),
          ) ??
          {},
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'completed': completed,
      'isCountable': isCountable,
      'targetCount': targetCount,
      'currentCount': currentCount,
      'completionTimestamp': completionTimestamp,
      'skillXp': skillXp,
    };
  }
}

class GameSettings {
  bool descriptionsVisible;
  int wakeupTimeHour;
  int wakeupTimeMinute;
  bool tutorialShown;

  GameSettings({
    this.descriptionsVisible = true,
    this.wakeupTimeHour = 7,
    this.wakeupTimeMinute = 0,
    this.tutorialShown = false,
  });

  factory GameSettings.fromJson(Map<String, dynamic> json) {
    return GameSettings(
      descriptionsVisible: json['descriptionsVisible'] as bool? ?? true,
      wakeupTimeHour: json['wakeupTimeHour'] as int? ?? 7,
      wakeupTimeMinute: json['wakeupTimeMinute'] as int? ?? 0,
      tutorialShown: json['tutorialShown'] as bool? ?? false,
    );
  }
  Map<String, dynamic> toJson() {
    return {
      'descriptionsVisible': descriptionsVisible,
      'wakeupTimeHour': wakeupTimeHour,
      'wakeupTimeMinute': wakeupTimeMinute,
      'tutorialShown': tutorialShown,
    };
  }
}

class ActiveTimerInfo {
  DateTime startTime;
  double accumulatedDisplayTime; // In seconds
  bool isRunning;
  String type; // 'task'
  String projectId;

  ActiveTimerInfo({
    required this.startTime,
    this.accumulatedDisplayTime = 0,
    required this.isRunning,
    required this.type,
    required this.projectId,
  });

  factory ActiveTimerInfo.fromJson(Map<String, dynamic> json) {
    return ActiveTimerInfo(
      startTime: DateTime.parse(json['startTime'] as String),
      accumulatedDisplayTime:
          (json['accumulatedDisplayTime'] as num? ?? 0).toDouble(),
      isRunning: json['isRunning'] as bool? ?? false,
      type: json['type'] as String? ?? 'task',
      // Legacy support for 'mainTaskId'
      projectId: json['projectId'] as String? ?? json['mainTaskId'] as String? ?? '',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'startTime': startTime.toIso8601String(),
      'accumulatedDisplayTime': accumulatedDisplayTime,
      'isRunning': isRunning,
      'type': type,
      'projectId': projectId,
    };
  }
}

class ProjectTemplate {
  final String id;
  final String name;
  final String description;
  final String theme;
  final String colorHex;

  ProjectTemplate({
    required this.id,
    required this.name,
    required this.description,
    required this.theme,
    this.colorHex = "FF00BFFF", // Default Blue
  });
}

class EmotionLog {
  final DateTime timestamp;
  final double rating; // 1-5

  EmotionLog({required this.timestamp, required this.rating});

  factory EmotionLog.fromJson(Map<String, dynamic> json) {
    return EmotionLog(
      timestamp: DateTime.parse(json['timestamp'] as String),
      rating: (json['rating'] as num? ?? 0.0).toDouble(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'timestamp': timestamp.toIso8601String(),
      'rating': rating,
    };
  }
}

// Chatbot models
enum MessageSender { user, bot }

class ChatbotMessage {
  final String id;
  final String text;
  final MessageSender sender;
  final DateTime timestamp;

  ChatbotMessage({
    required this.id,
    required this.text,
    required this.sender,
    required this.timestamp,
  });

  factory ChatbotMessage.fromJson(Map<String, dynamic> json) {
    return ChatbotMessage(
      id: json['id'] as String,
      text: json['text'] as String,
      sender: MessageSender.values
          .firstWhere((e) => e.toString() == json['sender'] as String),
      timestamp: DateTime.parse(json['timestamp'] as String),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'text': text,
      'sender': sender.toString(),
      'timestamp': timestamp.toIso8601String(),
    };
  }
}

class ChatbotMemory {
  List<ChatbotMessage> conversationHistory;
  List<String> userRememberedItems;

  ChatbotMemory({
    List<ChatbotMessage>? conversationHistory,
    List<String>? userRememberedItems,
  })  : conversationHistory = conversationHistory ?? [],
        userRememberedItems = userRememberedItems ?? [];

  factory ChatbotMemory.fromJson(Map<String, dynamic> json) {
    return ChatbotMemory(
      conversationHistory: (json['conversationHistory'] as List<dynamic>?)
              ?.map((msgJson) =>
                  ChatbotMessage.fromJson(msgJson as Map<String, dynamic>))
              .toList() ??
          [],
      userRememberedItems: (json['userRememberedItems'] as List<dynamic>?)
              ?.map((item) => item as String)
              .toList() ??
          [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'conversationHistory':
          conversationHistory.map((msg) => msg.toJson()).toList(),
      'userRememberedItems': userRememberedItems,
    };
  }
}

class Skill {
  String id; // Will match Project theme
  String name;
  double xp;
  int level;
  String description;
  String iconName;

  Skill({
    required this.id,
    required this.name,
    this.xp = 0,
    this.level = 1,
    this.description = '',
    this.iconName = 'default',
  });

  factory Skill.fromJson(Map<String, dynamic> json) {
    return Skill(
      id: json['id'] as String,
      name: json['name'] as String,
      xp: (json['xp'] as num? ?? 0).toDouble(),
      level: json['level'] as int? ?? 1,
      description: json['description'] as String? ?? '',
      iconName: json['iconName'] as String? ?? 'default',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'xp': xp,
      'level': level,
      'description': description,
      'iconName': iconName,
    };
  }
}
--- END OF FILE lib/src/models/game_models.dart ---

--- START OF FILE lib/src/providers/game_provider.dart ---
import 'package:arcane/src/services/notification_service.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:arcane/src/services/firebase_service.dart' as fb_service;
import 'package:arcane/src/services/storage_service.dart';
import 'package:arcane/src/utils/constants.dart';
import 'package:arcane/src/utils/helpers.dart' as helper;
import 'package:firebase_auth/firebase_auth.dart';
import 'package:intl/intl.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:collection/collection.dart';
import 'dart:async';
import 'dart:convert'; // For jsonEncode
import 'package:flutter/material.dart'; // For TimeOfDay

import 'package:arcane/src/models/game_models.dart';

import 'actions/task_actions.dart';
import 'actions/ai_generation_actions.dart';
import 'actions/timer_actions.dart';
import 'package:arcane/src/services/ai_service.dart'; // For chatbot AI service

class GameProvider with ChangeNotifier {
  final StorageService _storageService = StorageService();
  final AIService _aiService = AIService();
  final NotificationService _notificationService = NotificationService();
  Timer? _periodicUiTimer;
  Timer? _debounceSaveTimer;
  StreamSubscription? _gameStateSubscription;

  User? _currentUser;
  User? get currentUser => _currentUser;
  bool _authLoading = true;
  bool get authLoading => _authLoading;
  bool _isDataLoadingAfterLogin = false;
  bool get isDataLoadingAfterLogin => _isDataLoadingAfterLogin;
  bool _isUsernameMissing = false;
  bool get isUsernameMissing => _isUsernameMissing;

  String? _lastLoginDate;
  double _coins = 100;
  double _xp = 0;
  int _playerLevel = 1;
  double _playerEnergy = baseMaxPlayerEnergy;
  List<Project> _projects =
      initialProjectTemplates.map((t) => Project.fromTemplate(t)).toList();
  Map<String, dynamic> _completedByDay = {};
  List<String> _gameLog = [];
  List<Skill> _skills = [];

  GameSettings _settings = GameSettings();
  String? _selectedProjectId =
      initialProjectTemplates.isNotEmpty ? initialProjectTemplates[0].id : null;
  int _apiKeyIndex = 0;
  Map<String, ActiveTimerInfo> _activeTimers = {};

  bool _isManuallySaving = false;
  bool get isManuallySaving => _isManuallySaving;
  bool _isManuallyLoading = false;
  bool get isManuallyLoading => _isManuallyLoading;
  DateTime? _lastSuccessfulSaveTimestamp;
  DateTime? get lastSuccessfulSaveTimestamp => _lastSuccessfulSaveTimestamp;

  bool _isGeneratingGlobalContent = false;
  bool get isGeneratingContent => _isGeneratingGlobalContent;
  bool _isGeneratingSubquestsForTask = false;
  bool get isGeneratingSubquests => _isGeneratingSubquestsForTask;

  double _aiGenerationProgress = 0.0;
  double get aiGenerationProgress => _aiGenerationProgress;
  String _aiGenerationStatusMessage = "";
  String get aiGenerationStatusMessage => _aiGenerationStatusMessage;

  String? get lastLoginDate => _lastLoginDate;
  double get coins => _coins;
  double get xp => _xp;
  int get playerLevel => _playerLevel;
  double get playerEnergy => _playerEnergy;
  List<Project> get projects => _projects;
  Map<String, dynamic> get completedByDay => _completedByDay;
  List<String> get gameLog => _gameLog;
  List<Skill> get skills => _skills;

  GameSettings get settings => _settings;
  String? get selectedProjectId => _selectedProjectId;
  int get apiKeyIndex => _apiKeyIndex;
  Map<String, ActiveTimerInfo> get activeTimers => _activeTimers;

  double get calculatedMaxEnergy =>
      baseMaxPlayerEnergy + (_playerLevel - 1) * playerEnergyPerLevelVitality;
  double get xpNeededForNextLevel =>
      helper.xpToNext(_playerLevel, xpPerLevelBase, xpLevelMultiplier);
  double get currentLevelXPStart =>
      helper.xpForLevel(_playerLevel, xpPerLevelBase, xpLevelMultiplier);
  double get currentLevelXPProgress => _xp - currentLevelXPStart;
  double get xpProgressPercent => xpNeededForNextLevel > 0
      ? (currentLevelXPProgress / xpNeededForNextLevel).clamp(0.0, 1.0) * 100
      : 0;

  TimeOfDay get wakeupTime =>
      TimeOfDay(hour: _settings.wakeupTimeHour, minute: _settings.wakeupTimeMinute);

  ChatbotMemory _chatbotMemory = ChatbotMemory();
  ChatbotMemory get chatbotMemory => _chatbotMemory;
  bool _isChatbotMemoryInitialized = false;

  DateTime? _breakEndTime;
  DateTime? get breakEndTime => _breakEndTime;
  Timer? _breakTimer;
  int? _breakOriginalDurationMinutes;
  int? get breakOriginalDurationMinutes => _breakOriginalDurationMinutes;

  late final TaskActions _taskActions;
  late final AIGenerationActions _aiGenerationActions;
  late final TimerActions _timerActions;

  GameProvider() {
    _taskActions = TaskActions(this);
    _aiGenerationActions = AIGenerationActions(this);
    _timerActions = TimerActions(this);
    _initialize();
  }

  @override
  void dispose() {
    _periodicUiTimer?.cancel();
    _debounceSaveTimer?.cancel();
    _gameStateSubscription?.cancel();
    _breakTimer?.cancel();
    super.dispose();
  }

  void _initialize() {
    fb_service.authStateChanges.listen(_onAuthStateChanged);
    _periodicUiTimer?.cancel();
    _periodicUiTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_activeTimers.values.any((info) => info.isRunning)) {
        notifyListeners();
      }
    });
  }

  Future<void> _onAuthStateChanged(User? user) async {
    _authLoading = true;
    notifyListeners();

    _gameStateSubscription?.cancel();

    if (user != null) {
      _currentUser = user;
      _isDataLoadingAfterLogin = true;
      notifyListeners();

      _gameStateSubscription =
          _storageService.getUserDataStream(user.uid).listen((snapshot) {
        if (snapshot.metadata.hasPendingWrites) {
          return;
        }

        if (snapshot.exists) {
          _loadStateFromMap(snapshot.data()!);
          _handleDailyReset();
          _isChatbotMemoryInitialized = false;
          initializeChatbotMemory();
        } else {
          _resetToInitialState().then((_) async {
            _lastLoginDate = helper.getTodayDateString();
            await _performActualSave();
            _handleDailyReset();
            _isChatbotMemoryInitialized = false;
            initializeChatbotMemory();
          });
        }
        
        _isDataLoadingAfterLogin = false;
        _isUsernameMissing = (_currentUser?.displayName == null || _currentUser!.displayName!.trim().isEmpty);
        notifyListeners();
      }, onError: (error) {
         _isDataLoadingAfterLogin = false;
      });
    } else {
      _currentUser = null;
      await _resetToInitialState();
      _isDataLoadingAfterLogin = false;
      _isChatbotMemoryInitialized = false;
    }

    _authLoading = false;
    notifyListeners();
  }

  Map<String, dynamic> _gameStateToMap() {
    return {
      'lastLoginDate': _lastLoginDate,
      'coins': _coins,
      'xp': _xp,
      'playerLevel': _playerLevel,
      'playerEnergy': _playerEnergy,
      'projects': _projects.map((p) => p.toJson()).toList(),
      'completedByDay': _completedByDay,
      'gameLog': _gameLog,
      'skills': _skills.map((s) => s.toJson()).toList(),
      'settings': settings.toJson(),
      'selectedProjectId': _selectedProjectId,
      'apiKeyIndex': _apiKeyIndex,
      'activeTimers':
          _activeTimers.map((key, value) => MapEntry(key, value.toJson())),
      'lastSuccessfulSaveTimestamp':
          _lastSuccessfulSaveTimestamp?.toIso8601String(),
      'chatbotMemory': _chatbotMemory.toJson(),
    };
  }

  void _loadStateFromMap(Map<String, dynamic> data) {
    _lastLoginDate = data['lastLoginDate'] as String?;
    _coins = (data['coins'] as num? ?? 100).toDouble();
    _xp = (data['xp'] as num? ?? 0).toDouble();
    _playerLevel = data['playerLevel'] as int? ?? 1;
    _playerEnergy = (data['playerEnergy'] as num? ?? baseMaxPlayerEnergy).toDouble();

    // Legacy support for 'mainTasks'
    final projectsData = data['projects'] ?? data['mainTasks'];
    _projects = (projectsData as List<dynamic>?)
            ?.map((pJson) => Project.fromJson(pJson as Map<String, dynamic>))
            .toList() ??
        initialProjectTemplates.map((t) => Project.fromTemplate(t)).toList();

    _completedByDay = data['completedByDay'] as Map<String, dynamic>? ?? {};
    _gameLog = (data['gameLog'] as List<dynamic>?)?.map((entry) => entry as String).toList() ?? [];
    _skills = (data['skills'] as List<dynamic>?)?.map((sJson) => Skill.fromJson(sJson as Map<String, dynamic>)).toList() ?? [];
    _settings = data['settings'] != null ? GameSettings.fromJson(data['settings'] as Map<String, dynamic>) : GameSettings();

    // Legacy support for 'selectedTaskId'
    _selectedProjectId = data['selectedProjectId'] as String? ?? data['selectedTaskId'] as String? ?? (_projects.isNotEmpty ? _projects[0].id : null);
    _apiKeyIndex = data['apiKeyIndex'] as int? ?? 0;
    _activeTimers = (data['activeTimers'] as Map<String, dynamic>?)?.map(
            (key, value) => MapEntry(key, ActiveTimerInfo.fromJson(value as Map<String, dynamic>))) ?? {};

    final timestampString = data['lastSuccessfulSaveTimestamp'] as String?;
    _lastSuccessfulSaveTimestamp = timestampString != null ? DateTime.tryParse(timestampString) : null;
    _chatbotMemory = data['chatbotMemory'] != null ? ChatbotMemory.fromJson(data['chatbotMemory'] as Map<String, dynamic>) : ChatbotMemory();
    _isChatbotMemoryInitialized = true;

    _ensureSkillsList();
    _recalculatePlayerLevel();
  }

  Future<void> _resetToInitialState() async {
    _lastLoginDate = null;
    _coins = 100;
    _xp = 0;
    _playerLevel = 1;
    _playerEnergy = baseMaxPlayerEnergy;
    _projects = initialProjectTemplates.map((t) => Project.fromTemplate(t)).toList();
    _completedByDay = {};
    _gameLog = [];
    _skills = [];
    _settings = GameSettings();
    _selectedProjectId = _projects.isNotEmpty ? _projects[0].id : null;
    _apiKeyIndex = 0;
    _activeTimers = {};
    _isUsernameMissing = false;
    _lastSuccessfulSaveTimestamp = null;
    _chatbotMemory = ChatbotMemory();
    _isChatbotMemoryInitialized = true;
    _ensureSkillsList();
    _scheduleSave();
  }

  void _scheduleSave() {
    if (_debounceSaveTimer?.isActive ?? false) _debounceSaveTimer!.cancel();
    _debounceSaveTimer = Timer(const Duration(milliseconds: 1500), _performActualSave);
  }

  Future<void> _performActualSave() async {
    if (_currentUser != null && !_isManuallySaving) {
      final success = await _storageService.setUserData(_currentUser!.uid, _gameStateToMap());
      if (success) {
        _lastSuccessfulSaveTimestamp = DateTime.now();
        notifyListeners();
      } else {
        setProviderState(
            gameLog: [
              ..._gameLog,
              "<span style=\"color:${helper.colorToHex(AppTheme.fnAccentRed)}\">Error: Failed to save to cloud!</span>"
            ],
            doNotify: true);
      }
    }
  }

  Future<void> manuallySaveToCloud() async {
    if (_currentUser == null) throw Exception("Not logged in.");
    _isManuallySaving = true;
    notifyListeners();
    try {
      await _performActualSave();
    } finally {
      _isManuallySaving = false;
      notifyListeners();
    }
  }

  Future<void> manuallyLoadFromCloud() async {
    if (_currentUser == null) throw Exception("Not logged in.");
    _isManuallyLoading = true;
    notifyListeners();
    try {
      final data = await _storageService.getUserData(_currentUser!.uid);
      if (data != null) {
        _loadStateFromMap(data);
        _handleDailyReset();
        _isUsernameMissing = (_currentUser?.displayName == null || _currentUser!.displayName!.trim().isEmpty);
        _isChatbotMemoryInitialized = false;
        initializeChatbotMemory();
      } else {
        throw Exception("No data found on cloud.");
      }
    } finally {
      _isManuallyLoading = false;
      notifyListeners();
    }
  }

  Future<void> loginUser(String email, String password) async {
    await fb_service.signInWithEmail(email, password);
  }

  Future<void> signupUser(String email, String password, String username) async {
    _authLoading = true;
    notifyListeners();
    try {
      UserCredential userCredential = await fb_service.firebaseAuthInstance.createUserWithEmailAndPassword(email: email, password: password);
      _currentUser = userCredential.user;
      if (_currentUser != null) {
        await _currentUser!.updateDisplayName(username);
        await _currentUser!.reload();
        _currentUser = fb_service.firebaseAuthInstance.currentUser;
        await _resetToInitialState();
      } else {
        throw Exception("Signup successful but user object is null.");
      }
    } catch (e) {
      _currentUser = null;
      rethrow;
    } finally {
      _authLoading = false;
      notifyListeners();
    }
  }

  Future<void> logoutUser() async {
    await _performActualSave();
    await fb_service.signOut();
  }

  Future<void> changePasswordHandler(String newPassword) async {
    if (_currentUser != null) {
      await fb_service.changePassword(newPassword);
      _scheduleSave();
    } else {
      throw Exception("No user is currently signed in.");
    }
  }

  Future<void> updateUserDisplayName(String newUsername) async {
    if (_currentUser != null) {
      await _currentUser!.updateDisplayName(newUsername);
      await _currentUser!.reload();
      _currentUser = fb_service.firebaseAuthInstance.currentUser;
      _isUsernameMissing = false;
      _scheduleSave();
      notifyListeners();
    }
  }

  void setSelectedProjectId(String? projectId) {
    if (_selectedProjectId != projectId) {
      _selectedProjectId = projectId;
      _scheduleSave();
      notifyListeners();
    }
  }

  void setSettings(GameSettings newSettings) {
    _settings = newSettings;
    _scheduleSave();
    notifyListeners();
  }

  void completeTutorial() {
    _settings.tutorialShown = true;
    setSettings(_settings);
  }

  Project? getSelectedProject() {
    if (_selectedProjectId == null) return _projects.firstOrNull;
    return _projects.firstWhereOrNull((p) => p.id == _selectedProjectId) ?? _projects.firstOrNull;
  }

  void _recalculatePlayerLevel() {
    int newLevel = 1;
    double xpAtStartOfLvl = 0;
    while (true) {
      final double xpNeeded = helper.xpToNext(newLevel, xpPerLevelBase, xpLevelMultiplier);
      if (_xp >= xpAtStartOfLvl + xpNeeded) {
        xpAtStartOfLvl += xpNeeded;
        newLevel++;
      } else {
        break;
      }
    }
    if (_playerLevel != newLevel) {
      final oldLevel = _playerLevel;
      _playerLevel = newLevel;
      if (_playerLevel > oldLevel) {
        _handleLevelUpEffect();
      } else {
        _scheduleSave();
        notifyListeners();
      }
    }
  }

  void _handleLevelUpEffect() {
    if (_currentUser == null) return;
    _playerEnergy = calculatedMaxEnergy;
    _gameLog = [
      ..._gameLog,
      "<span style=\"color:#${helper.colorToHex(getSelectedProject()?.color ?? AppTheme.fortniteBlue)}\">Level up to $_playerLevel!</span>"
    ];
    _notificationService.showNotification('Level Up!', 'Congratulations! You reached level $_playerLevel.');
    _scheduleSave();
    notifyListeners();
  }

  String _generateSummaryForOlderDays() {
    if (_completedByDay.isEmpty) return "No activity logged before the last 7 days.";
    List<String> olderDaysSummaryLines = ["Summary of activity older than 7 days:"];
    int olderDaysActivityCount = 0;
    DateTime today = DateTime.now();
    List<String> sortedDates = _completedByDay.keys.toList()..sort();

    for (String dateString in sortedDates) {
      DateTime date = DateTime.parse(dateString);
      if (today.difference(date).inDays >= 7) {
        final dayData = _completedByDay[dateString] as Map<String, dynamic>;
        final taskTimes = dayData['taskTimes'] as Map<String, dynamic>? ?? {};
        int dailyTotalMinutes = taskTimes.values.fold<int>(0, (prev, time) => prev + (time as int));
        int dailySubtasks = (dayData['subtasksCompleted'] as List?)?.length ?? 0;
        int dailyCheckpoints = (dayData['checkpointsCompleted'] as List?)?.length ?? 0;
        int dailyEmotions = (dayData['emotionLogs'] as List?)?.length ?? 0;
        if (dailyTotalMinutes > 0 || dailySubtasks > 0 || dailyCheckpoints > 0 || dailyEmotions > 0) {
          olderDaysActivityCount++;
          String activityLine = "On $dateString: ${dailyTotalMinutes}m logged";
          if (dailySubtasks > 0) activityLine += ", $dailySubtasks tasks completed";
          if (dailyCheckpoints > 0) activityLine += ", $dailyCheckpoints checkpoints cleared";
          if (dailyEmotions > 0) activityLine += ", $dailyEmotions emotion logs";
          olderDaysSummaryLines.add("$activityLine.");
        }
      }
    }
    if (olderDaysActivityCount == 0) return "No significant activity logged before the last 7 days.";
    if (olderDaysSummaryLines.length > 21) return "${olderDaysSummaryLines.sublist(0, 21).join("\n")}\n... (older entries truncated)";
    return olderDaysSummaryLines.join("\n");
  }

  Future<void> _handleDailyReset() async {
    if (_currentUser == null) return;
    final today = helper.getTodayDateString();
    if (_lastLoginDate != today) {
      _projects = _projects.map((project) {
        int newStreak = project.streak;
        if (_lastLoginDate != null) {
          final yesterday = DateTime.now().subtract(const Duration(days: 1));
          final yesterdayStr = DateFormat('yyyy-MM-dd').format(yesterday);
          if (project.dailyTimeSpent < dailyTaskGoalMinutes &&
              project.lastWorkedDate != null &&
              project.lastWorkedDate != today &&
              project.lastWorkedDate != yesterdayStr) {
            newStreak = 0;
          }
        }
        project.dailyTimeSpent = 0;
        project.streak = newStreak;
        return project;
      }).toList();
      _playerEnergy = calculatedMaxEnergy;
      _lastLoginDate = today;
      _scheduleSave();
      scheduleEmotionReminders();
      notifyListeners();
    }
  }

  Future<void> clearAllGameData() async {
    if (_currentUser == null) return;
    await _storageService.deleteUserData(_currentUser!.uid);
    await _resetToInitialState();
    await _performActualSave();
    notifyListeners();
  }

  Future<void> resetPlayerLevelAndProgress() async {
    if (_currentUser == null) return;
    _playerLevel = 1;
    _xp = 0;
    _playerEnergy = calculatedMaxEnergy;
    _gameLog = [..._gameLog, "<span style=\"color:${helper.colorToHex(AppTheme.fnAccentOrange)}\">Player level and progress have been reset.</span>"];
    setProviderState(doNotify: true);
  }

  Future<void> resetAllSkills() async {
    if (_currentUser == null) return;
    final newSkills = _skills.map((skill) => Skill(
        id: skill.id, name: skill.name, description: skill.description,
        iconName: skill.iconName, xp: 0, level: 1)).toList();
    setProviderState(
      skills: newSkills,
      gameLog: [..._gameLog, "<span style=\"color:${helper.colorToHex(AppTheme.fnAccentOrange)}\">All skill progress has been reset.</span>"],
      doNotify: true,
    );
  }

  Future<void> editSkill(String skillId, {String? newName, String? newIconName}) async {
    final newSkills = _skills.map((skill) {
      if (skill.id == skillId) {
        return Skill(
          id: skill.id,
          name: newName ?? skill.name,
          iconName: newIconName ?? skill.iconName,
          xp: skill.xp,
          level: skill.level,
          description: skill.description,
        );
      }
      return skill;
    }).toList();
    setProviderState(
      skills: newSkills,
      gameLog: [..._gameLog, "<span style='color:${helper.colorToHex(AppTheme.fnAccentGreen)}'>Skill '${newName ?? '...'}' updated.</span>"],
      doNotify: true,
    );
  }

  Future<void> resetAndRecalculateSkillsFromLog() async {
    final Map<String, double> recalculatedXp = {};
    _completedByDay.forEach((date, dayData) {
      final List<dynamic> logs = [
        ...(dayData['subtasksCompleted'] as List<dynamic>? ?? []),
        ...(dayData['checkpointsCompleted'] as List<dynamic>? ?? []),
      ];
      for (var log in logs) {
        if (log is Map<String, dynamic> && log.containsKey('skillXp')) {
          final skillXpMap = log['skillXp'] as Map<String, dynamic>? ?? {};
          skillXpMap.forEach((skillId, xpValue) {
            if (xpValue is num) {
              recalculatedXp[skillId] = (recalculatedXp[skillId] ?? 0) + xpValue;
            }
          });
        }
      }
    });

    final List<Skill> newSkills = [];
    final existingThemes = _projects.map((p) => p.theme).toSet();

    for (String theme in existingThemes) {
      final double totalXp = recalculatedXp[theme] ?? 0.0;
      int newLevel = 1;
      while (totalXp >= helper.skillXpForLevel(newLevel + 1)) {
        newLevel++;
      }
      newSkills.add(Skill(
        id: theme,
        name: theme.replaceAll('_', ' ').split(' ').map((word) => word[0].toUpperCase() + word.substring(1)).join(' '),
        description: "Skill related to $theme.", iconName: themeToIconName[theme] ?? 'default',
        xp: totalXp, level: newLevel,
      ));
    }
    
    setProviderState(
      skills: newSkills,
      gameLog: [..._gameLog, "<span style=\"color:${helper.colorToHex(AppTheme.fnAccentGreen)}\">Skills recalculated from historical logs.</span>"],
      doNotify: true,
    );
  }

  List<EmotionLog> getEmotionLogsForDate(String date) {
    final dayData = _completedByDay[date] as Map<String, dynamic>?;
    if (dayData == null || dayData['emotionLogs'] == null) return [];
    return (dayData['emotionLogs'] as List<dynamic>).map((logJson) => EmotionLog.fromJson(logJson as Map<String, dynamic>)).toList()..sort((a, b) => a.timestamp.compareTo(b.timestamp));
  }

  void logEmotion(String date, double rating, [DateTime? customTimestamp]) {
    final timestamp = customTimestamp ?? DateTime.now();
    final emotionLog = EmotionLog(timestamp: timestamp, rating: rating);
    final newCompletedByDay = Map<String, dynamic>.from(_completedByDay);
    final dayData = Map<String, dynamic>.from(newCompletedByDay[date] ?? {'taskTimes': <String, int>{}, 'subtasksCompleted': <Map<String, dynamic>>[], 'checkpointsCompleted': <Map<String, dynamic>>[], 'emotionLogs': <Map<String, dynamic>>[]});
    final emotionLogsList = List<Map<String, dynamic>>.from(dayData['emotionLogs'] as List? ?? []);
    emotionLogsList.add(emotionLog.toJson());
    emotionLogsList.sort((a, b) => (a['timestamp'] as String).compareTo(b['timestamp'] as String));
    dayData['emotionLogs'] = emotionLogsList;
    newCompletedByDay[date] = dayData;
    setProviderState(
        completedByDay: newCompletedByDay,
        gameLog: [..._gameLog, "<span style='color:${helper.colorToHex(AppTheme.fortnitePurple)}'>Emotion logged: ${rating.toStringAsFixed(1)}/5 for $date.</span>"],
        doNotify: true);
  }

  void deleteLatestEmotionLog(String date) {
    final currentLogs = getEmotionLogsForDate(date);
    if (currentLogs.isEmpty) return;
    final newCompletedByDay = Map<String, dynamic>.from(_completedByDay);
    final dayData = Map<String, dynamic>.from(newCompletedByDay[date] ?? {});
    final emotionLogsList = List<Map<String, dynamic>>.from(dayData['emotionLogs'] as List? ?? []);
    if (emotionLogsList.isNotEmpty) emotionLogsList.removeLast();
    dayData['emotionLogs'] = emotionLogsList;
    newCompletedByDay[date] = dayData;
    setProviderState(
        completedByDay: newCompletedByDay,
        gameLog: [..._gameLog, "<span style='color:${helper.colorToHex(AppTheme.fnAccentOrange)}'>Latest emotion log for $date deleted.</span>"],
        doNotify: true);
  }

  void setWakeupTime(TimeOfDay newTime) {
    _settings.wakeupTimeHour = newTime.hour;
    _settings.wakeupTimeMinute = newTime.minute;
    setSettings(_settings);
    scheduleEmotionReminders();
  }

  List<DateTime> calculateNotificationTimes() {
    final now = DateTime.now();
    final wakeupDateTime = DateTime(now.year, now.month, now.day, wakeupTime.hour, wakeupTime.minute);
    const int loggingDurationMinutes = 16 * 60, numberOfLogs = 10;
    final int intervalMinutes = (loggingDurationMinutes / (numberOfLogs - 1)).floor();
    List<DateTime> times = [];
    DateTime currentTime = wakeupDateTime;
    for (int i = 0; i < numberOfLogs; i++) {
      times.add(currentTime);
      currentTime = currentTime.add(Duration(minutes: intervalMinutes));
    }
    if (now.day == wakeupDateTime.day) return times.where((t) => t.isAfter(now)).toList();
    return times;
  }

  void scheduleEmotionReminders() {
    if (kDebugMode) {
      print("[GameProvider] Conceptual: Would schedule notifications for: ${calculateNotificationTimes().map((t) => DateFormat('HH:mm').format(t)).join(', ')}");
    }
  }

  void initializeChatbotMemory() {
    if (_isChatbotMemoryInitialized) return;
    if (_chatbotMemory.conversationHistory.isEmpty) {
      _chatbotMemory.conversationHistory.add(ChatbotMessage(
          id: 'init_${DateTime.now().millisecondsSinceEpoch}', text: "Hello! I am Arcane Advisor. How can I assist you?",
          sender: MessageSender.bot, timestamp: DateTime.now()));
    }
    _isChatbotMemoryInitialized = true;
    notifyListeners();
  }

  Future<void> sendMessageToChatbot(String userMessageText) async {
    if (!_isChatbotMemoryInitialized) initializeChatbotMemory();
    final userMessage = ChatbotMessage(id: 'user_${DateTime.now().millisecondsSinceEpoch}', text: userMessageText, sender: MessageSender.user, timestamp: DateTime.now());
    _chatbotMemory.conversationHistory.add(userMessage);
    if (_chatbotMemory.conversationHistory.length > 20) {
      _chatbotMemory.conversationHistory.removeAt(0);
    }
    if (userMessageText.toLowerCase().startsWith("remember:")) {
      final itemToRemember = userMessageText.substring("remember:".length).trim();
      if (itemToRemember.isNotEmpty) {
        _chatbotMemory.userRememberedItems.add(itemToRemember);
        if (_chatbotMemory.userRememberedItems.length > 10) {
          _chatbotMemory.userRememberedItems.removeAt(0);
        }
        final botResponse = ChatbotMessage(id: 'bot_${DateTime.now().millisecondsSinceEpoch}', text: "Okay, I will remember: \"$itemToRemember\"", sender: MessageSender.bot, timestamp: DateTime.now());
        _chatbotMemory.conversationHistory.add(botResponse);
        setProviderState(chatbotMemory: _chatbotMemory);
        return;
      }
    }
    if (userMessageText.toLowerCase().startsWith("forget last") || userMessageText.toLowerCase().startsWith("forget everything")) {
      bool forgetEverything = userMessageText.toLowerCase().startsWith("forget everything");
      String responseText;
      if (forgetEverything) {
        _chatbotMemory.userRememberedItems.clear();
        responseText = "Okay, I've cleared all remembered items.";
      } else if (_chatbotMemory.userRememberedItems.isNotEmpty) {
        String forgottenItem = _chatbotMemory.userRememberedItems.removeLast();
        responseText = "Okay, I've forgotten: \"$forgottenItem\"";
      } else {
        responseText = "I don't have any items to forget.";
      }
      final botResponse = ChatbotMessage(id: 'bot_${DateTime.now().millisecondsSinceEpoch}', text: responseText, sender: MessageSender.bot, timestamp: DateTime.now());
      _chatbotMemory.conversationHistory.add(botResponse);
      setProviderState(chatbotMemory: _chatbotMemory);
      return;
    }
    notifyListeners();
    Map<String, dynamic> completedByDayLast7DaysData = {};
    DateTime today = DateTime.now();
    _completedByDay.forEach((dateString, data) {
      DateTime date = DateTime.parse(dateString);
      if (today.difference(date).inDays < 7) {
        completedByDayLast7DaysData[dateString] = data;
      }
    });
    String completedByDayJsonForAI = jsonEncode(completedByDayLast7DaysData);
    String olderDaysSummaryForAI = _generateSummaryForOlderDays();
    try {
      final botResponseText = await _aiService.getChatbotResponse(memory: _chatbotMemory, userMessage: userMessageText,
        completedByDayJsonLast7Days: completedByDayJsonForAI, olderDaysSummary: olderDaysSummaryForAI,
        currentApiKeyIndex: _apiKeyIndex, onNewApiKeyIndex: (newIndex) => _apiKeyIndex = newIndex, onLog: (logMsg) => _gameLog.add(logMsg));
      final botMessage = ChatbotMessage(id: 'bot_${DateTime.now().millisecondsSinceEpoch}', text: botResponseText, sender: MessageSender.bot, timestamp: DateTime.now());
      _chatbotMemory.conversationHistory.add(botMessage);
    } catch (e) {
      final errorMessage = ChatbotMessage(id: 'error_${DateTime.now().millisecondsSinceEpoch}', text: "I'm having trouble connecting. Please try again later.", sender: MessageSender.bot, timestamp: DateTime.now());
      _chatbotMemory.conversationHistory.add(errorMessage);
    }
    setProviderState(chatbotMemory: _chatbotMemory);
  }

  Future<void> triggerAIEnhanceTask(Project project, Task taskToEnhance, String userInput) =>
    _aiGenerationActions.triggerAIEnhanceTask(project, taskToEnhance, userInput);

  void addProject({required String name, required String description, required String theme, required String colorHex}) =>
      _taskActions.addProject(name: name, description: description, theme: theme, colorHex: colorHex);
  void editProject(String projectId, {required String name, required String description, required String theme, required String colorHex}) =>
      _taskActions.editProject(projectId, name: name, description: description, theme: theme, colorHex: colorHex);
  void deleteProject(String projectId) => _taskActions.deleteProject(projectId);
  void logToDailySummary(String type, Map<String, dynamic> data) =>
      _taskActions.logToDailySummary(type, data);
  String addTask(String projectId, Map<String, dynamic> taskData) => _taskActions.addTask(projectId, taskData);
  void updateTask(String projectId, String taskId, Map<String, dynamic> updates) => _taskActions.updateTask(projectId, taskId, updates);
  void replaceTask(String projectId, String oldTaskId, Task newTask) => _taskActions.replaceTask(projectId, oldTaskId, newTask);
  bool completeTask(String projectId, String taskId) => _taskActions.completeTask(projectId, taskId);
  void deleteTask(String projectId, String taskId) => _taskActions.deleteTask(projectId, taskId);
  void duplicateCompletedTask(String projectId, String taskId) => _taskActions.duplicateCompletedTask(projectId, taskId);
  void addCheckpoint(String projectId, String parentTaskId, Map<String, dynamic> checkpointData) =>
      _taskActions.addCheckpoint(projectId, parentTaskId, checkpointData);
  void updateCheckpoint(String projectId, String parentTaskId, String checkpointId, Map<String, dynamic> updates) =>
      _taskActions.updateCheckpoint(projectId, parentTaskId, checkpointId, updates);
  void completeCheckpoint(String projectId, String parentTaskId, String checkpointId) =>
      _taskActions.completeCheckpoint(projectId, parentTaskId, checkpointId);
  void deleteCheckpoint(String projectId, String parentTaskId, String checkpointId) =>
      _taskActions.deleteCheckpoint(projectId, parentTaskId, checkpointId);

  void startTimer(String id, String type, String projectId) => _timerActions.startTimer(id, type, projectId);
  void pauseTimer(String id) => _timerActions.pauseTimer(id);
  void logTimerAndReset(String id) => _timerActions.logTimerAndReset(id);

  void _ensureSkillsList() {
    for (var project in _projects) {
      if (!_skills.any((s) => s.id == project.theme)) {
        _skills.add(Skill(
          id: project.theme,
          name: project.theme.replaceAll('_', ' ').split(' ').map((word) => word[0].toUpperCase() + word.substring(1)).join(' '),
          description: "Skill related to ${project.name}.",
          iconName: themeToIconName[project.theme] ?? 'default',
        ));
      }
    }
  }

  void addSkillXp(String skillId, double amount) {
    Skill? skill = _skills.firstWhereOrNull((s) => s.id == skillId);
    if (skill != null) {
      skill.xp += amount;
      int newLevel = 1;
      while (skill.xp >= helper.skillXpForLevel(newLevel + 1)) {
        newLevel++;
      }
      skill.level = newLevel;
      setProviderState(skills: _skills);
    }
  }
  
  void takeBreak(int minutes) {
    double energyCost = minutes.toDouble();
    if (_playerEnergy >= energyCost) {
      _playerEnergy -= energyCost;
      _breakOriginalDurationMinutes = minutes;
      _breakEndTime = DateTime.now().add(Duration(minutes: minutes));
      _breakTimer?.cancel();
      _breakTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
        if (_breakEndTime == null || DateTime.now().isAfter(_breakEndTime!)) {
          _breakTimer?.cancel();
          _breakEndTime = null;
          _breakOriginalDurationMinutes = null;
          _notificationService.showNotification('Break Over!', 'Time to get back to the mission.');
           setProviderState(gameLog: [..._gameLog, "<span style='color:${helper.colorToHex(AppTheme.fnAccentGreen)}'>Break finished. Time to get back to the mission.</span>"], doNotify: true);
        } else {
          notifyListeners();
        }
      });
      setProviderState(
        playerEnergy: _playerEnergy,
        gameLog: [..._gameLog, "<span style='color:${helper.colorToHex(AppTheme.fortnitePurple)}'>Took a $minutes minute break.</span>"],
        doNotify: true,
      );
    } else {
        setProviderState(gameLog: [..._gameLog, "<span style='color:${helper.colorToHex(AppTheme.fnAccentOrange)}'>Not enough energy for a $minutes minute break.</span>"]);
    }
  }

  void cancelBreak() {
    if (_breakEndTime == null || _breakOriginalDurationMinutes == null) return;
    final double energyCost = _breakOriginalDurationMinutes!.toDouble();
    final double energyRefund = energyCost / 2;
    _breakTimer?.cancel();
    _breakEndTime = null;
    _breakOriginalDurationMinutes = null;
    setProviderState(
      playerEnergy: (_playerEnergy + energyRefund).clamp(0, calculatedMaxEnergy),
      gameLog: [..._gameLog, "<span style='color:${helper.colorToHex(AppTheme.fnAccentOrange)}'>Break cancelled. Regained ${energyRefund.toStringAsFixed(0)} energy.</span>"],
      doNotify: true,
    );
  }

  void refillEnergyWithCoins(int energyAmount) {
    double totalCost = energyAmount * coinsPerEnergy;
    if (_coins >= totalCost) {
      setProviderState(
        coins: _coins - totalCost,
        playerEnergy: (_playerEnergy + energyAmount).clamp(0, calculatedMaxEnergy),
        gameLog: [..._gameLog, "<span style='color:${helper.colorToHex(AppTheme.fnAccentGreen)}'>Purchased $energyAmount energy for ${totalCost.toStringAsFixed(0)} coins.</span>"],
      );
    } else {
       setProviderState(gameLog: [..._gameLog, "<span style='color:${helper.colorToHex(AppTheme.fnAccentOrange)}'>Not enough coins to purchase $energyAmount energy.</span>"]);
    }
  }

  void setProviderState({
    String? lastLoginDate, double? coins, double? xp, double? playerEnergy,
    List<Project>? projects, Map<String, dynamic>? completedByDay, List<String>? gameLog,
    List<Skill>? skills, Map<String, ActiveTimerInfo>? activeTimers,
    DateTime? lastSuccessfulSaveTimestamp, bool? isUsernameMissing, ChatbotMemory? chatbotMemory,
    bool doNotify = true,
  }) {
    bool changed = false;
    if (lastLoginDate != null && _lastLoginDate != lastLoginDate) { _lastLoginDate = lastLoginDate; changed = true; }
    if (coins != null && _coins != coins) { _coins = coins; changed = true; }
    if (xp != null && _xp != xp) { _xp = xp; _recalculatePlayerLevel(); changed = true; }
    if (playerEnergy != null && _playerEnergy != playerEnergy) { _playerEnergy = playerEnergy.clamp(0, calculatedMaxEnergy); changed = true; }
    if (projects != null && !listEquals(_projects, projects)) { _projects = List.from(projects); _ensureSkillsList(); changed = true; }
    if (completedByDay != null && !mapEquals(_completedByDay, completedByDay)) { _completedByDay = Map.from(completedByDay); changed = true; }
    if (gameLog != null && !listEquals(_gameLog, gameLog)) { _gameLog = List.from(gameLog); changed = true; }
    if (skills != null && !listEquals(_skills, skills)) { _skills = List.from(skills); changed = true; }
    if (activeTimers != null && !mapEquals(_activeTimers, activeTimers)) { _activeTimers = Map.from(activeTimers); changed = true; }
    if (lastSuccessfulSaveTimestamp != null && _lastSuccessfulSaveTimestamp != lastSuccessfulSaveTimestamp) { _lastSuccessfulSaveTimestamp = lastSuccessfulSaveTimestamp; changed = true; }
    if (isUsernameMissing != null && _isUsernameMissing != isUsernameMissing) { _isUsernameMissing = isUsernameMissing; changed = true; }
    if (chatbotMemory != null && _chatbotMemory != chatbotMemory) { _chatbotMemory = chatbotMemory; changed = true; }
    if (changed) {
      _scheduleSave();
      if (doNotify) notifyListeners();
    }
  }

  void setProviderAIGlobalLoading(bool isLoading, {double progress = 0.0, String statusMessage = ""}) {
    bool changed = false;
    if (_isGeneratingGlobalContent != isLoading) { _isGeneratingGlobalContent = isLoading; changed = true; }
    if (_aiGenerationProgress != progress) { _aiGenerationProgress = progress; changed = true; }
    if (_aiGenerationStatusMessage != statusMessage) { _aiGenerationStatusMessage = statusMessage; changed = true; }
    if (changed) notifyListeners();
  }

  void setProviderAISubquestLoading(bool isLoading) {
    if (_isGeneratingSubquestsForTask != isLoading) {
      _isGeneratingSubquestsForTask = isLoading;
      notifyListeners();
    }
  }

  void setProviderApiKeyIndex(int index) {
    if (_apiKeyIndex != index) {
      _apiKeyIndex = index;
    }
  }
}
--- END OF FILE lib/src/providers/game_provider.dart ---

--- START OF FILE lib/src/providers/actions/task_actions.dart ---
// lib/src/providers/actions/task_actions.dart
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/utils/constants.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/utils/helpers.dart';
import 'package:collection/collection.dart';
import 'package:flutter/foundation.dart';

class TaskActions {
  final GameProvider _provider;

  TaskActions(this._provider);

  void addProject(
      {required String name,
      required String description,
      required String theme,
      required String colorHex}) {
    final newProject = Project(
      id: 'proj_${DateTime.now().millisecondsSinceEpoch}',
      name: name,
      description: description,
      theme: theme,
      colorHex: colorHex,
    );
    _provider.setProviderState(projects: [..._provider.projects, newProject]);
  }

  void editProject(String projectId,
      {required String name,
      required String description,
      required String theme,
      required String colorHex}) {
    final newProjects = _provider.projects.map((project) {
      if (project.id == projectId) {
        return Project(
          id: project.id,
          name: name,
          description: description,
          theme: theme,
          colorHex: colorHex,
          streak: project.streak,
          dailyTimeSpent: project.dailyTimeSpent,
          lastWorkedDate: project.lastWorkedDate,
          tasks: project.tasks,
        );
      }
      return project;
    }).toList();
    _provider.setProviderState(projects: newProjects);
  }
  
  void deleteProject(String projectId) {
    final newProjects = List<Project>.from(_provider.projects);
    final projectToDelete = newProjects.firstWhereOrNull((p) => p.id == projectId);
    if (projectToDelete == null) return;

    newProjects.removeWhere((p) => p.id == projectId);

    String? newSelectedId = _provider.selectedProjectId;
    if (_provider.selectedProjectId == projectId) {
      newSelectedId = newProjects.isNotEmpty ? newProjects.first.id : null;
    }
    
    final themeOfDeletedProject = projectToDelete.theme;
    final isThemeStillInUse = newProjects.any((p) => p.theme == themeOfDeletedProject);
    
    List<Skill> newSkills = List<Skill>.from(_provider.skills);
    if (!isThemeStillInUse) {
      newSkills.removeWhere((s) => s.id == themeOfDeletedProject);
    }
    
    _provider.setProviderState(
      projects: newProjects,
      skills: newSkills
    );
    // setSelectedProjectId will trigger its own notify and save
    _provider.setSelectedProjectId(newSelectedId);
  }


  void logToDailySummary(String type, Map<String, dynamic> data) {
    final today = getTodayDateString();
    final newCompletedByDay = Map<String, dynamic>.from(_provider.completedByDay);
    final dayData = Map<String, dynamic>.from(newCompletedByDay[today] ??
        {'taskTimes': <String, int>{}, 'subtasksCompleted': <Map<String, dynamic>>[], 'checkpointsCompleted': <Map<String, dynamic>>[], 'emotionLogs': <Map<String, dynamic>>[]});

    if (type == 'taskTime') {
      final taskTimes = Map<String, int>.from(dayData['taskTimes'] as Map? ?? {});
      taskTimes[data['projectId'] as String] = (taskTimes[data['projectId'] as String] ?? 0) + (data['time'] as int);
      dayData['taskTimes'] = taskTimes;
    } else if (type == 'taskCompleted') {
      final tasksCompleted = List<Map<String, dynamic>>.from(dayData['subtasksCompleted'] as List? ?? []);
      tasksCompleted.add(data);
      dayData['subtasksCompleted'] = tasksCompleted;
    } else if (type == 'checkpointCompleted') {
      final checkpointsCompleted = List<Map<String, dynamic>>.from(dayData['checkpointsCompleted'] as List? ?? []);
      if (!data.containsKey('completionTimestamp')) {
          data['completionTimestamp'] = DateTime.now().toIso8601String();
      }
      checkpointsCompleted.add(data);
      dayData['checkpointsCompleted'] = checkpointsCompleted;
    }

    newCompletedByDay[today] = dayData;
    _provider.setProviderState(completedByDay: newCompletedByDay);
  }

  String addTask(String projectId, Map<String, dynamic> taskData) {
    final newTask = Task(
      id: 'task_${DateTime.now().millisecondsSinceEpoch}_${(_provider.projects.fold<int>(0, (prev, p) => prev + p.tasks.length) + 1)}',
      name: taskData['name'] as String,
      isCountable: taskData['isCountable'] as bool? ?? false,
      targetCount: taskData['isCountable'] as bool? ?? false ? (taskData['targetCount'] as int? ?? 1) : 0,
      checkpoints: (taskData['checkpointsData'] as List<Map<String, dynamic>>?)?.map((cpData) => Checkpoint(
            id: 'cp_${DateTime.now().millisecondsSinceEpoch}_${(_provider.projects.fold<int>(0, (prev, p) => prev + p.tasks.fold<int>(0, (pSt, st) => pSt + st.checkpoints.length)) + 1)}_${cpData['name']?.hashCode ?? 0}',
            name: cpData['name'] as String,
            isCountable: cpData['isCountable'] as bool? ?? false,
            targetCount: cpData['isCountable'] as bool? ?? false ? (cpData['targetCount'] as int? ?? 1) : 0,
      )).toList() ?? [],
    );

    final newProjects = _provider.projects.map((project) {
      if (project.id == projectId) {
        project.tasks.add(newTask);
      }
      return project;
    }).toList();
    _provider.setProviderState(projects: newProjects);
    return newTask.id;
  }

  void updateTask(String projectId, String taskId, Map<String, dynamic> updates) {
    Project? projectToUpdate = _provider.projects.firstWhereOrNull((p) => p.id == projectId);
    if (projectToUpdate == null) return;
    Task? taskToUpdate = projectToUpdate.tasks.firstWhereOrNull((t) => t.id == taskId);
    if (taskToUpdate == null) return;

    final int oldTaskTime = taskToUpdate.currentTimeSpent;

    if (updates.containsKey('name')) taskToUpdate.name = updates['name'] as String;
    if (updates.containsKey('isCountable')) taskToUpdate.isCountable = updates['isCountable'] as bool;
    if (updates.containsKey('targetCount')) taskToUpdate.targetCount = updates['targetCount'] as int;
    if (updates.containsKey('currentCount')) taskToUpdate.currentCount = (updates['currentCount'] as int).clamp(0, taskToUpdate.targetCount);
    if (updates.containsKey('currentTimeSpent')) taskToUpdate.currentTimeSpent = updates['currentTimeSpent'] as int;

    int timeDifference = 0;
    if (updates.containsKey('currentTimeSpent')) timeDifference = taskToUpdate.currentTimeSpent - oldTaskTime;

    if (timeDifference != 0) {
      projectToUpdate.dailyTimeSpent = (projectToUpdate.dailyTimeSpent) + timeDifference;
      projectToUpdate.lastWorkedDate = getTodayDateString();
      logToDailySummary('taskTime', {'projectId': projectId, 'time': timeDifference});
      if (timeDifference > 0) {
        _provider.setProviderState(playerEnergy: (_provider.playerEnergy + timeDifference * energyRegenPerMinuteTasked).clamp(0, _provider.calculatedMaxEnergy));
      }
    }

    if (projectToUpdate.dailyTimeSpent - timeDifference < dailyTaskGoalMinutes && projectToUpdate.dailyTimeSpent >= dailyTaskGoalMinutes) {
      projectToUpdate.streak++;
    }

    final newProjects = _provider.projects.map((p) => p.id == projectId ? projectToUpdate : p).toList();
    _provider.setProviderState(projects: newProjects);
  }

  bool completeTask(String projectId, String taskId) {
    Project? project = _provider.projects.firstWhereOrNull((p) => p.id == projectId);
    if (project == null) return false;
    Task? task = project.tasks.firstWhereOrNull((t) => t.id == taskId);
    if (task == null || task.completed) return false;

    if (task.isCountable && task.currentCount < task.targetCount) return false;
    if (task.currentTimeSpent <= 0 && !task.isCountable) {
      if (task.checkpoints.isNotEmpty && !task.checkpoints.every((cp) => cp.completed)) return false;
      if (task.checkpoints.isEmpty) return false;
    }

    ActiveTimerInfo? timerForTask = _provider.activeTimers[taskId];
    Task updatedTaskForRewards = task;

    if (timerForTask != null) {
      double totalSecondsToLog = timerForTask.accumulatedDisplayTime;
      if (timerForTask.isRunning) totalSecondsToLog += (DateTime.now().difference(timerForTask.startTime).inMilliseconds) / 1000;
      final int elapsedMinutes = (totalSecondsToLog / 60).round();
      if (elapsedMinutes > 0) {
        updateTask(projectId, taskId, {'currentTimeSpent': task.currentTimeSpent + elapsedMinutes});
        final Project? refetchedProject = _provider.projects.firstWhereOrNull((p) => p.id == projectId);
        if (refetchedProject != null) {
          updatedTaskForRewards = refetchedProject.tasks.firstWhereOrNull((t) => t.id == taskId) ?? task;
        }
      }
      final newActiveTimers = Map<String, ActiveTimerInfo>.from(_provider.activeTimers)..remove(taskId);
      _provider.setProviderState(activeTimers: newActiveTimers);
    }

    double proportionalXp = updatedTaskForRewards.isCountable ? updatedTaskForRewards.targetCount * xpPerCountUnitSubtask : updatedTaskForRewards.currentTimeSpent * xpPerMinuteSubtask;
    double proportionalCoins = updatedTaskForRewards.isCountable ? updatedTaskForRewards.targetCount * coinsPerCountUnitSubtask : updatedTaskForRewards.currentTimeSpent * coinsPerMinuteSubtask;
    final double baseCompletionXp = subtaskCompletionXpBase + _provider.playerLevel + project.streak;
    final double baseCompletionCoins = subtaskCompletionCoinBase + (_provider.playerLevel * 0.5) + (project.streak * 0.2);
    final int finalXpReward = (baseCompletionXp + proportionalXp).floor();
    final int finalCoinReward = (baseCompletionCoins + proportionalCoins).floor();

    final newProjects = _provider.projects.map((p) {
      if (p.id == projectId) {
        p.tasks = p.tasks.map((t) {
          if (t.id == taskId) t.completed = true; t.completedDate = getTodayDateString();
          return t;
        }).toList();
      }
      return p;
    }).toList();

    _provider.setProviderState(projects: newProjects, xp: _provider.xp + finalXpReward, coins: _provider.coins + finalCoinReward);
    updatedTaskForRewards.skillXp.forEach((skillId, xpAmount) => _provider.addSkillXp(skillId, xpAmount));
    logToDailySummary('taskCompleted', {'projectId': project.id, 'name': updatedTaskForRewards.name, 'timeLogged': updatedTaskForRewards.currentTimeSpent,
      'isCountable': updatedTaskForRewards.isCountable, 'currentCount': updatedTaskForRewards.currentCount, 'targetCount': updatedTaskForRewards.targetCount, 'skillXp': updatedTaskForRewards.skillXp});
    return true;
  }

  void deleteTask(String projectId, String taskId) {
    final newProjects = _provider.projects.map((project) {
      if (project.id == projectId) {
        project.tasks.removeWhere((t) => t.id == taskId);
      }
      return project;
    }).toList();
    final newActiveTimers = Map<String, ActiveTimerInfo>.from(_provider.activeTimers)..remove(taskId);
    _provider.setProviderState(projects: newProjects, activeTimers: newActiveTimers);
  }

  void replaceTask(String projectId, String oldTaskId, Task newTask) {
    final newProjects = _provider.projects.map((project) {
      if (project.id == projectId) {
        final taskIndex = project.tasks.indexWhere((t) => t.id == oldTaskId);
        if (taskIndex != -1) project.tasks[taskIndex] = newTask;
      }
      return project;
    }).toList();
    _provider.setProviderState(projects: newProjects);
  }

  void duplicateCompletedTask(String projectId, String taskId) {
    Project? projectToUpdate = _provider.projects.firstWhereOrNull((p) => p.id == projectId);
    if (projectToUpdate == null) return;
    Task? taskToDuplicate = projectToUpdate.tasks.firstWhereOrNull((t) => t.id == taskId);
    if (taskToDuplicate == null || !taskToDuplicate.completed) return;

    final newTask = Task(
      id: 'task_${DateTime.now().millisecondsSinceEpoch}_${(projectToUpdate.tasks.length + 1)}',
      name: taskToDuplicate.name, completed: false, currentTimeSpent: 0, completedDate: null,
      isCountable: taskToDuplicate.isCountable, targetCount: taskToDuplicate.targetCount, currentCount: 0,
      skillXp: taskToDuplicate.skillXp,
      checkpoints: taskToDuplicate.checkpoints.map((cp) => Checkpoint(
            id: 'cp_${DateTime.now().millisecondsSinceEpoch}_${(taskToDuplicate.checkpoints.length + 1)}_${cp.name.hashCode}',
            name: cp.name, completed: false, isCountable: cp.isCountable, targetCount: cp.targetCount,
            currentCount: 0, completionTimestamp: null, skillXp: cp.skillXp,
      )).toList(),
    );
    projectToUpdate.tasks.add(newTask);
    final newProjects = _provider.projects.map((p) => p.id == projectId ? projectToUpdate : p).toList();
    _provider.setProviderState(projects: newProjects);
  }

  void addCheckpoint(String projectId, String parentTaskId, Map<String, dynamic> checkpointData) {
    final newCheckpoint = Checkpoint(
      id: 'cp_${DateTime.now().millisecondsSinceEpoch}_${checkpointData['name']?.hashCode ?? 0}',
      name: checkpointData['name'] as String,
      isCountable: checkpointData['isCountable'] as bool? ?? false,
      targetCount: checkpointData['isCountable'] as bool? ?? false ? (checkpointData['targetCount'] as int? ?? 1) : 0,
    );

    final newProjects = _provider.projects.map((project) {
      if (project.id == projectId) {
        project.tasks.firstWhereOrNull((t) => t.id == parentTaskId)?.checkpoints.add(newCheckpoint);
      }
      return project;
    }).toList();
    _provider.setProviderState(projects: newProjects);
  }

  void updateCheckpoint(String projectId, String parentTaskId, String checkpointId, Map<String, dynamic> updates) {
    final newProjects = _provider.projects.map((project) {
      if (project.id == projectId) {
        project.tasks.firstWhereOrNull((t) => t.id == parentTaskId)?.checkpoints = project.tasks
            .firstWhere((t) => t.id == parentTaskId).checkpoints.map((cp) {
          if (cp.id == checkpointId) {
            cp.name = updates['name'] as String? ?? cp.name;
            cp.completed = updates['completed'] as bool? ?? cp.completed;
            cp.isCountable = updates['isCountable'] as bool? ?? cp.isCountable;
            cp.targetCount = updates['targetCount'] as int? ?? cp.targetCount;
            cp.currentCount = updates['currentCount'] as int? ?? cp.currentCount;
            cp.completionTimestamp = updates['completionTimestamp'] as String? ?? cp.completionTimestamp;
            cp.skillXp = (updates['skillXp'] as Map<String, double>?) ?? cp.skillXp;
            if (cp.isCountable) cp.currentCount = cp.currentCount.clamp(0, cp.targetCount);
          }
          return cp;
        }).toList();
      }
      return project;
    }).toList();
    _provider.setProviderState(projects: newProjects);
  }

  void completeCheckpoint(String projectId, String parentTaskId, String checkpointId) {
    double xpReward = 0; double coinReward = 0;
    bool checkpointCompletedSuccessfully = false;
    Checkpoint? completedCheckpointInstanceForLog;

    Project? project = _provider.projects.firstWhereOrNull((p) => p.id == projectId);
    Task? task = project?.tasks.firstWhereOrNull((t) => t.id == parentTaskId);
    Checkpoint? checkpoint = task?.checkpoints.firstWhereOrNull((cp) => cp.id == checkpointId);

    if (checkpoint == null || checkpoint.completed) return;
    if (checkpoint.isCountable && checkpoint.currentCount < checkpoint.targetCount) return;

    final double proportionalXp = checkpoint.isCountable ? checkpoint.targetCount * xpPerCountUnitSubSubtask : 0;
    final double proportionalCoins = checkpoint.isCountable ? checkpoint.targetCount * coinsPerCountUnitSubSubtask : 0;
    xpReward = (subSubtaskCompletionXpBase + proportionalXp).floorToDouble();
    coinReward = (subSubtaskCompletionCoinBase + proportionalCoins).floorToDouble();
    
    checkpoint.completed = true;
    checkpoint.completionTimestamp = DateTime.now().toIso8601String();
    completedCheckpointInstanceForLog = checkpoint;
    checkpointCompletedSuccessfully = true;

    final newProjects = _provider.projects.map((p) => p.id == projectId ? project! : p).toList();

    if (checkpointCompletedSuccessfully && completedCheckpointInstanceForLog != null) {
      _provider.setProviderState(projects: newProjects, xp: _provider.xp + xpReward, coins: _provider.coins + coinReward);
      completedCheckpointInstanceForLog.skillXp.forEach((skillId, xpAmount) => _provider.addSkillXp(skillId, xpAmount));
      logToDailySummary('checkpointCompleted', {
        'projectId': projectId, 'parentTaskId': parentTaskId, 'checkpointId': checkpointId, 'name': completedCheckpointInstanceForLog.name,
        'isCountable': completedCheckpointInstanceForLog.isCountable, 'currentCount': completedCheckpointInstanceForLog.currentCount, 'targetCount': completedCheckpointInstanceForLog.targetCount,
        'completionTimestamp': completedCheckpointInstanceForLog.completionTimestamp, 'skillXp': completedCheckpointInstanceForLog.skillXp,
        'parentTaskName': task?.name ?? 'N/A', 'projectName': project?.name ?? 'N/A'
      });
    }
  }

  void deleteCheckpoint(String projectId, String parentTaskId, String checkpointId) {
    final newProjects = _provider.projects.map((project) {
      if (project.id == projectId) {
        project.tasks.firstWhereOrNull((t) => t.id == parentTaskId)?.checkpoints.removeWhere((cp) => cp.id == checkpointId);
      }
      return project;
    }).toList();
    _provider.setProviderState(projects: newProjects);
  }
}
--- END OF FILE lib/src/providers/actions/task_actions.dart ---

--- START OF FILE lib/src/screens/home_screen.dart ---
import 'package:arcane/src/widgets/break_timer_banner.dart';
import 'package:arcane/src/widgets/dialogs/username_prompt_dialog.dart';
import 'package:arcane/src/widgets/views/logbook_view.dart';
import 'package:arcane/src/widgets/views/skills_view.dart';
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/widgets/header_widget.dart';
import 'package:arcane/src/widgets/project_navigation_drawer.dart';
import 'package:arcane/src/widgets/skill_drawer.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:arcane/src/widgets/views/task_details_view.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:arcane/src/screens/chatbot_screen.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  late GameProvider _gameProvider;
  bool _isUsernameDialogShowing = false;
  bool _isTutorialShowing = false;
  int _mobileSelectedIndex = 0; // 0: Tasks, 1: Logbook, 2: Skills
  bool _isHovering = true;

  @override
  void initState() {
    super.initState();
    _gameProvider = Provider.of<GameProvider>(context, listen: false);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _initializeScreen();
    });
    _gameProvider.addListener(_handleProviderChanges);
  }
  
  void _initializeScreen() {
     if (_gameProvider.selectedProjectId == null &&
          _gameProvider.projects.isNotEmpty) {
        _gameProvider.setSelectedProjectId(_gameProvider.projects.first.id);
      }
      _checkAndPromptForUsername(_gameProvider);
      _checkAndShowTutorial(_gameProvider);
  }

  void _handleProviderChanges() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    _checkAndPromptForUsername(gameProvider);
    _checkAndShowTutorial(gameProvider);
  }

  void _checkAndShowTutorial(GameProvider gameProvider) {
     if (mounted && !gameProvider.settings.tutorialShown && !_isTutorialShowing &&
        !gameProvider.authLoading && !gameProvider.isDataLoadingAfterLogin && !_isUsernameDialogShowing) {
       setState(() => _isTutorialShowing = true);
       _startTutorial(context).then((_) {
         if (mounted) setState(() => _isTutorialShowing = false);
       });
     }
  }

  void _checkAndPromptForUsername(GameProvider gameProvider) {
    if (mounted &&
        gameProvider.isUsernameMissing &&
        gameProvider.currentUser != null &&
        !_isUsernameDialogShowing &&
        !gameProvider.authLoading &&
        !gameProvider.isDataLoadingAfterLogin) {
      setState(() => _isUsernameDialogShowing = true);
      showDialog<void>(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext dialogContext) => const UsernamePromptDialog(),
      ).then((_) {
        if (mounted) setState(() => _isUsernameDialogShowing = false);
      });
    }
  }

  @override
  void dispose() {
    _gameProvider.removeListener(_handleProviderChanges);
    super.dispose();
  }

  Widget _buildLogbookFab(BuildContext context, ThemeData theme) {
    return FloatingActionButton.extended(
      onPressed: () => Navigator.push(context, MaterialPageRoute(builder: (context) => const ChatbotScreen())),
      label: const Text('Advisor'),
      icon: Icon(MdiIcons.robotHappyOutline),
      backgroundColor: theme.colorScheme.secondary,
      foregroundColor: ThemeData.estimateBrightnessForColor(theme.colorScheme.secondary) == Brightness.dark
          ? AppTheme.fnTextPrimary
          : AppTheme.fnBgDark,
      isExtended: false,
    );
  }

  void _showTakeBreakDialog(BuildContext context, GameProvider gameProvider) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text('Take a Break', style: TextStyle(color: (gameProvider.getSelectedProject()?.color ?? AppTheme.fortniteBlue))),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('Spend energy to take a break and recover focus.'),
            const SizedBox(height: 16),
            _buildBreakButton(ctx, gameProvider, 5, '5-min break'),
            _buildBreakButton(ctx, gameProvider, 15, '15-min break'),
            _buildBreakButton(ctx, gameProvider, 30, '30-min break'),
          ],
        ),
        actions: [
          TextButton(onPressed: () => Navigator.of(ctx).pop(), child: const Text('Cancel')),
        ],
      ),
    );
  }

  Widget _buildBreakButton(BuildContext context, GameProvider gameProvider, int minutes, String text) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: ElevatedButton(
        onPressed: gameProvider.playerEnergy >= minutes ? () {
          gameProvider.takeBreak(minutes);
          Navigator.of(context).pop();
        } : null,
        style: ElevatedButton.styleFrom(minimumSize: const Size(double.infinity, 40), disabledBackgroundColor: AppTheme.fnBgLight),
        child: Text('$text'),
      ),
    );
  }

  Widget _buildTaskDetailsFab(BuildContext context, ThemeData theme) {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    return FloatingActionButton.extended(
      onPressed: () => _showTakeBreakDialog(context, gameProvider),
      label: const Text('Take Break'),
      icon: Icon(MdiIcons.coffeeOutline),
      backgroundColor: theme.colorScheme.secondary,
      foregroundColor: ThemeData.estimateBrightnessForColor(theme.colorScheme.secondary) == Brightness.dark
          ? AppTheme.fnTextPrimary
          : AppTheme.fnBgDark,
        isExtended: false,
    );
  }
  
  Future<void> _startTutorial(BuildContext context) async {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    
    await _showTutorialStep(
      title: 'Welcome to Arcane!',
      content: 'This is your command center for turning goals into achievements. Let\'s walk through the key features.',
      isFirst: true
    );
    await _showTutorialStep(
      title: 'Projects Panel (Left)',
      content: 'Projects are your major goals (e.g., "Learn a New Skill", "Fitness Journey"). Tap the list icon on mobile, or see it on the left on desktop. Create new projects and switch between them here.',
    );
     await _showTutorialStep(
      title: 'Task View (Center)',
      content: 'This is where you manage the specific tasks for your selected project. You can add tasks, track time with the session timer, and break them down into smaller checkpoints.',
    );
     await _showTutorialStep(
      title: 'Skills Panel (Right)',
      content: 'Completing tasks and checkpoints earns you XP in related skills. Level up your skills to see your progress and unlock new potential! View your skills by tapping the atom icon.',
    );
     await _showTutorialStep(
      title: 'The Header',
      content: 'At the top, you\'ll find your vital stats: Coins, Energy, and your current Player Level & XP. Use energy for breaks and coins to replenish energy.',
    );
    await _showTutorialStep(
      title: 'Ready to Begin?',
      content: 'You\'re all set to start your journey. Define your projects, break them into tasks, and start conquering your goals!',
      isLast: true,
      onNext: () {
        gameProvider.completeTutorial();
      }
    );
  }

  Future<void> _showTutorialStep({
    required String title, 
    required String content, 
    bool isFirst = false, 
    bool isLast = false,
    VoidCallback? onNext,
  }) async {
    if (!mounted) return;
    return showDialog<void>(
      context: context,
      barrierDismissible: false,
      builder: (ctx) => AlertDialog(
        title: Row(children: [Icon(MdiIcons.schoolOutline, color: Theme.of(context).primaryColor), const SizedBox(width: 8), Text(title)]),
        content: Text(content, style: Theme.of(context).textTheme.bodyMedium),
        actions: [
          if(!isFirst)
            TextButton(child: const Text('Back'), onPressed: (){
              // This simple implementation doesn't support 'back'.
              // A more complex state management (like a tutorial provider) would be needed.
            },),
          ElevatedButton(
            child: Text(isLast ? 'FINISH' : 'NEXT'),
            onPressed: () {
              onNext?.call();
              Navigator.of(ctx).pop();
            },
          ),
        ],
      )
    );
  }


  @override
  Widget build(BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;
    final bool isLargeScreen = screenWidth > 900;

    final gameProvider = context.watch<GameProvider>();
    final Color currentProjectColor =
        gameProvider.getSelectedProject()?.color ?? AppTheme.fortniteBlue;
    final ThemeData dynamicTheme =
        AppTheme.getThemeData(primaryAccent: currentProjectColor);

    const List<Widget> mobileViews = [TaskDetailsView(), LogbookView(), SkillsView()];
    const List<String> viewLabels = ["TASKS", "LOGBOOK", "SKILLS"];

    return Theme(
      data: dynamicTheme,
      child: Scaffold(
        body: MouseRegion(
          onEnter: (_) => setState(() => _isHovering = true),
          onExit: (_) => setState(() => _isHovering = true),
          child: AnimatedContainer(
            duration: const Duration(milliseconds: 300),
            decoration: BoxDecoration(
              gradient: LinearGradient(
                colors: [currentProjectColor.withOpacity(0.1), AppTheme.fnBgDark],
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
              ),
            ),
            child: Column(
              children: [
                if (gameProvider.breakEndTime != null) const BreakTimerBanner(),
                Expanded(
                  child: SafeArea(
                    bottom: false,
                    child: Column(
                      children: [
                        HeaderWidget(
                          currentViewLabel: viewLabels[_mobileSelectedIndex],
                          isMobile: !isLargeScreen,
                        ),
                        Expanded(
                          child: isLargeScreen
                              ? Row(
                                  children: [
                                    Container(
                                      width: 280,
                                      decoration: BoxDecoration(
                                        color: dynamicTheme.cardTheme.color,
                                        border: Border(right: BorderSide(color: dynamicTheme.dividerTheme.color ?? AppTheme.fnBorderColor, width: 1)),
                                      ),
                                      child: const ProjectNavigationDrawer(),
                                    ),
                                     const Expanded(child: Center(child:  TaskDetailsView())),
                                     Container(
                                      width: 280,
                                      decoration: BoxDecoration(
                                        color: dynamicTheme.cardTheme.color,
                                        border: Border(left: BorderSide(color: dynamicTheme.dividerTheme.color ?? AppTheme.fnBorderColor, width: 1)),
                                      ),
                                      child: const SkillDrawer(),
                                    ),
                                  ],
                                )
                              : IndexedStack(index: _mobileSelectedIndex, children: mobileViews),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
        drawer: isLargeScreen ? null : const ProjectNavigationDrawer(),
        endDrawer: isLargeScreen ? null : const SkillDrawer(),
        floatingActionButton: !isLargeScreen && _mobileSelectedIndex == 0
            ? _buildTaskDetailsFab(context, dynamicTheme)
            : (!isLargeScreen && _mobileSelectedIndex == 1 ? _buildLogbookFab(context, dynamicTheme) : null),
        bottomNavigationBar: isLargeScreen ? null : BottomNavigationBar(
          items:  <BottomNavigationBarItem>[
             BottomNavigationBarItem(icon: Icon(MdiIcons.target), label: 'Tasks'),
             BottomNavigationBarItem(icon: Icon(MdiIcons.bookOpenVariant), label: 'Logbook'),
             BottomNavigationBarItem(icon: Icon(MdiIcons.atom), label: 'Skills'),
          ],
          currentIndex: _mobileSelectedIndex,
          onTap: (index) => setState(() => _mobileSelectedIndex = index),
        ),
      ),
    );
  }
}
--- END OF FILE lib/src/screens/home_screen.dart ---

--- START OF FILE lib/src/screens/settings_screen.dart ---
import 'package:arcane/src/widgets/views/settings_sections/cloud_sync_settings.dart';
import 'package:arcane/src/widgets/views/settings_sections/danger_zone_settings.dart';
import 'package:arcane/src/widgets/views/settings_sections/energy_management_settings.dart';
import 'package:arcane/src/widgets/views/settings_sections/project_management_settings.dart';
import 'package:arcane/src/widgets/views/settings_sections/skill_management_settings.dart';
import 'package:arcane/src/widgets/views/settings_sections/user_access_settings.dart';
import 'package:arcane/src/widgets/views/settings_sections/user_interface_settings.dart';
import 'package:flutter/material.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('System Config'),
        backgroundColor: AppTheme.fnBgMedium,
      ),
      body: Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 800),
          child: const SingleChildScrollView(
            padding: EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                CloudSyncSettings(),
                UserAccessSettings(),
                ProjectManagementSettings(),
                EnergyManagementSettings(),
                UserInterfaceSettings(),
                SkillManagementSettings(),
                DangerZoneSettings(),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- END OF FILE lib/src/screens/settings_screen.dart ---

--- START OF FILE lib/src/widgets/project_navigation_drawer.dart ---
// lib/src/widgets/project_navigation_drawer.dart
import 'package:arcane/src/widgets/dialogs/project_edit_dialog.dart';
import 'package:flutter/material.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:provider/provider.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/utils/constants.dart';

class ProjectNavigationDrawer extends StatelessWidget {
  const ProjectNavigationDrawer({super.key});

  IconData _getThemeIcon(String? themeName) {
    final iconString = themeToIconName[themeName] ?? 'targetAccount';
    return MdiIcons.fromString(iconString) ?? MdiIcons.targetAccount;
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = Provider.of<GameProvider>(context);
    final theme = Theme.of(context);

    return Drawer(
      backgroundColor: AppTheme.fnBgDark,
      child: Column(
        children: [
          AppBar(
            title: Text('PROJECTS',
                style: theme.textTheme.headlineSmall
                    ?.copyWith(color: AppTheme.fnTextPrimary, letterSpacing: 1)),
            automaticallyImplyLeading: false,
            backgroundColor: AppTheme.fnBgMedium,
            elevation: 0,
            actions: [
              IconButton(
                icon: Icon(MdiIcons.plusCircleOutline,
                    color: AppTheme.fortniteBlue),
                onPressed: () => showDialog(
                  context: context,
                  builder: (ctx) => const ProjectEditDialog(),
                ),
                tooltip: 'Add New Project',
              ),
            ],
          ),
          Expanded(
            child: gameProvider.projects.isEmpty
                ? Center(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Text(
                          'No projects available. Add one to begin.',
                          style: theme.textTheme.bodyMedium?.copyWith(
                              color: AppTheme.fnTextSecondary,
                              fontStyle: FontStyle.italic),
                          textAlign: TextAlign.center),
                    ),
                  )
                : ListView.builder(
                    padding: EdgeInsets.zero,
                    itemCount: gameProvider.projects.length,
                    itemBuilder: (context, index) {
                      final project = gameProvider.projects[index];
                      final isSelected =
                          gameProvider.selectedProjectId == project.id;
                      final projectColor = project.color;

                      return Material(
                        color: isSelected
                            ? projectColor.withAlpha(64)
                            : Colors.transparent,
                        child: ListTile(
                          leading: Icon(
                              _getThemeIcon(project.theme),
                              color: isSelected
                                  ? projectColor
                                  : AppTheme.fnTextSecondary,
                              size: 22),
                          title: Text(project.name,
                              style: theme.textTheme.titleMedium?.copyWith(
                                  color: isSelected
                                      ? projectColor
                                      : AppTheme.fnTextPrimary,
                                  fontWeight: isSelected
                                      ? FontWeight.bold
                                      : FontWeight.w500),
                              overflow: TextOverflow.ellipsis),
                          trailing: Wrap(spacing: 0, children: [
                            if (project.streak > 0)
                              Chip(
                                avatar: Icon(MdiIcons.fire,
                                    color: AppTheme.fnAccentOrange, size: 14),
                                label: Text('${project.streak}',
                                    style: const TextStyle(
                                        color: AppTheme.fnAccentOrange,
                                        fontSize: 11,
                                        fontWeight: FontWeight.bold)),
                                backgroundColor:
                                    const Color.fromARGB(55, 0, 0, 0),
                                padding: const EdgeInsets.symmetric(
                                    horizontal: 6, vertical: 0),
                                visualDensity: VisualDensity.compact,
                              ),
                            IconButton(
                              icon: Icon(MdiIcons.pencilOutline,
                                  size: 18,
                                  color: AppTheme.fnTextSecondary
                                      .withAlpha(179)),
                              onPressed: () => showDialog(
                                context: context,
                                builder: (ctx) =>
                                    ProjectEditDialog(project: project),
                              ),
                              tooltip: 'Edit Project',
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 6, vertical: 6),
                              constraints: const BoxConstraints(),
                            ),
                          ]),
                          selected: isSelected,
                          onTap: () {
                            FocusScope.of(context).unfocus();
                            gameProvider.setSelectedProjectId(project.id);
                            if (MediaQuery.of(context).size.width < 900) {
                              Navigator.pop(context);
                            }
                          },
                          selectedTileColor: projectColor.withAlpha(38),
                          contentPadding: const EdgeInsets.symmetric(
                              horizontal: 16, vertical: 8),
                        ),
                      );
                    },
                  ),
          ),
        ],
      ),
    );
  }
}
--- END OF FILE lib/src/widgets/project_navigation_drawer.dart ---

--- START OF FILE lib/src/widgets/dialogs/project_edit_dialog.dart ---
// lib/src/widgets/dialogs/project_edit_dialog.dart
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:arcane/src/utils/constants.dart';
import 'package:flutter/material.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:provider/provider.dart';

class ProjectEditDialog extends StatefulWidget {
  final Project? project;

  const ProjectEditDialog({super.key, this.project});

  bool get isEditMode => project != null;

  @override
  State<ProjectEditDialog> createState() => _ProjectEditDialogState();
}

class _ProjectEditDialogState extends State<ProjectEditDialog> {
  late TextEditingController _nameController;
  late TextEditingController _descController;
  late String _selectedTheme;
  late String _selectedColorHex;

  final List<Map<String, dynamic>> _availableThemes =
      themeToIconName.entries.map((entry) {
    Color color;
    switch (entry.key) {
      case 'tech': color = AppTheme.fortniteBlue; break;
      case 'knowledge': color = AppTheme.fortnitePurple; break;
      case 'learning': color = AppTheme.fnAccentOrange; break;
      case 'discipline': color = AppTheme.fnAccentRed; break;
      case 'order': color = AppTheme.fnAccentGreen; break;
      case 'health': color = const Color(0xFF58D68D); break;
      case 'finance': color = const Color(0xFFF1C40F); break;
      case 'creative': color = const Color(0xFFEC7063); break;
      case 'exploration': color = const Color(0xFF5DADE2); break;
      case 'social': color = const Color(0xFFE59866); break;
      case 'nature': color = const Color(0xFF2ECC71); break;
      default: color = AppTheme.fnTextSecondary;
    }
    return {'name': entry.key, 'icon': MdiIcons.fromString(entry.value), 'color': color};
  }).toList();

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController(text: widget.project?.name ?? '');
    _descController = TextEditingController(text: widget.project?.description ?? '');
    _selectedTheme = widget.project?.theme ?? 'tech';
    _selectedColorHex = widget.project?.colorHex ?? _colorToHex(_getColorForTheme(_selectedTheme));
  }

  @override
  void dispose() {
    _nameController.dispose();
    _descController.dispose();
    super.dispose();
  }

  String _colorToHex(Color color) {
    return color.value.toRadixString(16).padLeft(8, '0').substring(2).toUpperCase();
  }

  Color _getColorForTheme(String themeName) {
    return _availableThemes.firstWhere((t) => t['name'] == themeName,
        orElse: () => {'color': AppTheme.fortniteBlue})['color'] as Color;
  }

  void _handleSaveChanges() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    if (_nameController.text.isNotEmpty) {
      if (widget.isEditMode) {
        gameProvider.editProject(
          widget.project!.id,
          name: _nameController.text,
          description: _descController.text,
          theme: _selectedTheme,
          colorHex: _selectedColorHex,
        );
      } else {
        gameProvider.addProject(
          name: _nameController.text,
          description: _descController.text,
          theme: _selectedTheme,
          colorHex: _selectedColorHex,
        );
      }
      Navigator.of(context).pop();
    }
  }
  
  void _handleDelete() {
    final gameProvider = Provider.of<GameProvider>(context, listen: false);
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text('Delete Project?', style: TextStyle(color: AppTheme.fnAccentRed)),
        content: Text('Are you sure you want to delete "${widget.project!.name}"? This action cannot be undone.'),
        actions: [
          TextButton(onPressed: () => Navigator.of(ctx).pop(), child: Text('Cancel')),
          ElevatedButton(
            onPressed: () {
              gameProvider.deleteProject(widget.project!.id);
              Navigator.of(ctx).pop(); // Close confirmation dialog
              Navigator.of(context).pop(); // Close edit dialog
            },
            style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fnAccentRed),
            child: Text('Delete'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      backgroundColor: AppTheme.fnBgMedium,
      title: Text(widget.isEditMode ? 'Edit Project' : 'Add New Project'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: <Widget>[
            TextField(controller: _nameController, decoration: const InputDecoration(labelText: 'Project Name')),
            const SizedBox(height: 8),
            TextField(controller: _descController, decoration: const InputDecoration(labelText: 'Description'), maxLines: 2),
            const SizedBox(height: 8),
            DropdownButtonFormField<String>(
              decoration: const InputDecoration(labelText: 'Theme'),
              dropdownColor: AppTheme.fnBgLight,
              value: _selectedTheme,
              items: _availableThemes.map((themeMap) {
                return DropdownMenuItem<String>(
                  value: themeMap['name'] as String,
                  child: Row(
                    children: [
                      Icon(themeMap['icon'] as IconData, size: 18, color: themeMap['color'] as Color),
                      const SizedBox(width: 8),
                      Text(themeMap['name'] as String),
                    ],
                  ),
                );
              }).toList(),
              onChanged: (String? newValue) {
                if (newValue != null) {
                  setState(() {
                    _selectedTheme = newValue;
                    _selectedColorHex = _colorToHex(_getColorForTheme(newValue));
                  });
                }
              },
            ),
            const SizedBox(height: 16),
            Text("Select Theme Color:", style: Theme.of(context).textTheme.labelMedium),
            const SizedBox(height: 8),
            Wrap(
              spacing: 8.0, runSpacing: 8.0,
              children: _availableThemes.map((themeMap) {
                Color color = themeMap['color'] as Color;
                String colorHex = _colorToHex(color);
                bool isSelectedColor = _selectedColorHex == colorHex;
                return GestureDetector(
                  onTap: () => setState(() => _selectedColorHex = colorHex),
                  child: Container(
                    width: 30, height: 30,
                    decoration: BoxDecoration(
                      color: color,
                      borderRadius: BorderRadius.circular(4),
                      border: isSelectedColor
                          ? Border.all(color: Colors.white, width: 2)
                          : Border.all(color: Colors.white.withAlpha(77), width: 1),
                    ),
                    child: isSelectedColor
                        ? Icon(MdiIcons.check, color: ThemeData.estimateBrightnessForColor(color) == Brightness.dark ? Colors.white : Colors.black, size: 18)
                        : null,
                  ),
                );
              }).toList(),
            ),
          ],
        ),
      ),
      actions: <Widget>[
        if (widget.isEditMode)
          IconButton(
            icon: Icon(MdiIcons.deleteForeverOutline, color: AppTheme.fnAccentRed),
            onPressed: _handleDelete,
            tooltip: 'Delete Project',
          ),
        const Spacer(),
        TextButton(child: const Text('Cancel'), onPressed: () => Navigator.of(context).pop()),
        ElevatedButton(
          child: Text(widget.isEditMode ? 'Save Changes' : 'Add Project'),
          onPressed: _handleSaveChanges,
        ),
      ],
    );
  }
}
--- END OF FILE lib/src/widgets/dialogs/project_edit_dialog.dart ---

--- START OF FILE lib/src/widgets/dialogs/username_prompt_dialog.dart ---
// lib/src/widgets/dialogs/username_prompt_dialog.dart
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

class UsernamePromptDialog extends StatefulWidget {
  const UsernamePromptDialog({super.key});

  @override
  State<UsernamePromptDialog> createState() => _UsernamePromptDialogState();
}

class _UsernamePromptDialogState extends State<UsernamePromptDialog> {
  final _usernameController = TextEditingController();
  final _dialogFormKey = GlobalKey<FormState>();

  @override
  void dispose() {
    _usernameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final gameProvider = context.read<GameProvider>();
    final Color currentAccentColor =
        gameProvider.getSelectedProject()?.color ?? Theme.of(context).colorScheme.secondary;

    return AlertDialog(
      title: Text('Set Your Callsign', style: TextStyle(color: currentAccentColor)),
      content: Form(
        key: _dialogFormKey,
        child: TextFormField(
          controller: _usernameController,
          decoration: const InputDecoration(hintText: "Enter callsign"),
          validator: (value) {
            if (value == null || value.trim().isEmpty) return 'Callsign cannot be empty.';
            if (value.trim().length < 3) return 'Must be at least 3 characters.';
            return null;
          },
        ),
      ),
      actions: <Widget>[
        ElevatedButton(
          style: ElevatedButton.styleFrom(backgroundColor: currentAccentColor),
          child: Text(
            'CONFIRM',
            style: TextStyle(
              color: ThemeData.estimateBrightnessForColor(currentAccentColor) == Brightness.dark
                  ? AppTheme.fnTextPrimary
                  : AppTheme.fnBgDark,
            ),
          ),
          onPressed: () async {
            if (_dialogFormKey.currentState!.validate()) {
              String newUsername = _usernameController.text.trim();
              Navigator.of(context).pop();
              await gameProvider.updateUserDisplayName(newUsername);
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Callsign updated!'),
                    backgroundColor: AppTheme.fnAccentGreen,
                  ),
                );
              }
            }
          },
        ),
      ],
    );
  }
}
--- END OF FILE lib/src/widgets/dialogs/username_prompt_dialog.dart ---

--- START OF FILE lib/src/widgets/views/settings_sections/project_management_settings.dart ---
// lib/src/widgets/views/settings_sections/project_management_settings.dart
import 'package:arcane/src/models/game_models.dart';
import 'package:arcane/src/providers/game_provider.dart';
import 'package:arcane/src/theme/app_theme.dart';
import 'package:arcane/src/widgets/dialogs/project_edit_dialog.dart';
import 'package:arcane/src/widgets/views/settings_sections/settings_section_card.dart';
import 'package:flutter/material.dart';
import 'package:material_design_icons_flutter/material_design_icons_flutter.dart';
import 'package:provider/provider.dart';

class ProjectManagementSettings extends StatelessWidget {
  const ProjectManagementSettings({super.key});

  void _confirmAndDelete(BuildContext context, GameProvider gameProvider, Project project) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text('Delete Project?', style: TextStyle(color: AppTheme.fnAccentRed)),
        content: Text('Are you sure you want to delete "${project.name}"? This action is irreversible.'),
        actions: [
          TextButton(onPressed: () => Navigator.of(ctx).pop(), child: const Text('Cancel')),
          ElevatedButton(
            onPressed: () {
              gameProvider.deleteProject(project.id);
              Navigator.of(ctx).pop();
            },
            style: ElevatedButton.styleFrom(backgroundColor: AppTheme.fnAccentRed),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<GameProvider>(
      builder: (context, gameProvider, child) {
        return SettingsSectionCard(
          icon: MdiIcons.formatListChecks,
          title: 'Project Configuration',
          children: [
            Text(
              'Manage your active projects. You can edit their details or remove them entirely.',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(color: AppTheme.fnTextSecondary, height: 1.5),
            ),
            const SizedBox(height: 16),
            if (gameProvider.projects.isEmpty)
              const Center(
                child: Padding(
                  padding: EdgeInsets.symmetric(vertical: 16.0),
                  child: Text('No projects to configure.', style: TextStyle(fontStyle: FontStyle.italic, color: AppTheme.fnTextSecondary)),
                ),
              )
            else
              ListView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                itemCount: gameProvider.projects.length,
                itemBuilder: (ctx, index) {
                  final project = gameProvider.projects[index];
                  return ListTile(
                    leading: Icon(MdiIcons.circle, color: project.color),
                    title: Text(project.name),
                    trailing: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        IconButton(
                          icon: const Icon(Icons.edit_outlined, size: 20),
                          tooltip: 'Edit Project',
                          onPressed: () => showDialog(
                            context: context,
                            builder: (_) => ProjectEditDialog(project: project),
                          ),
                        ),
                        IconButton(
                          icon: Icon(MdiIcons.deleteOutline, size: 20),
                          tooltip: 'Delete Project',
                          color: AppTheme.fnAccentRed.withOpacity(0.8),
                          onPressed: () => _confirmAndDelete(context, gameProvider, project),
                        ),
                      ],
                    ),
                    contentPadding: const EdgeInsets.symmetric(horizontal: 4),
                  );
                },
              ),
            const SizedBox(height: 16),
            ElevatedButton.icon(
              icon: Icon(MdiIcons.plus, size: 18),
              label: const Text('ADD NEW PROJECT'),
              onPressed: () => showDialog(context: context, builder: (_) => const ProjectEditDialog()),
              style: ElevatedButton.styleFrom(minimumSize: const Size(double.infinity, 44)),
            )
          ],
        );
      },
    );
  }
}
--- END OF FILE lib/src/widgets/views/settings_sections/project_management_settings.dart ---
